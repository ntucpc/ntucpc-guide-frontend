{"pageProps":{"props":{"mdxPath":"guide/content/BasicDynamicProgramming/state_and_transition/state_and_transition.mdx","code":"BasicDynamicProgramming/state_and_transition","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","Implementation/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","Implementation/buglist"],"coming":false},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/basic_knowledge","article":"basic_knowledge","topic":"Implementation","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"Implementation/buglist","article":"buglist","topic":"Implementation","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/variable"],"coming":false},{"code":"Implementation/compiler","article":"compiler","topic":"Implementation","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/debug","article":"debug","topic":"Implementation","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["Implementation/buglist"],"coming":false},{"code":"Implementation/error_message","article":"error_message","topic":"Implementation","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/compiler"],"coming":false},{"code":"Implementation/input","article":"input","topic":"Implementation","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"Implementation/reference","article":"reference","topic":"Implementation","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/variable","article":"variable","topic":"Implementation","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"],"coming":false},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"Implementation","title":"實作技巧","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","Implementation/debug"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["Implementation"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["BasicMath"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicMath/basicalgo","BasicMath/number_theory"]}]},"content":[["guide/content/BasicDynamicProgramming/state_and_transition/state_and_transition.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Info, Problem, Refcode, Theorem} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  if (!Theorem) _missingMdxReference(\"Theorem\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"不再是線性遞迴\",\n      children: \"不再是線性遞迴\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們來看看一道跟先前都不一樣的題目：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/481\",\n      src: \"NCOJ 481\",\n      name: \"[Tutorial] 別離太遠 續\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/NCOJ/481/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/481/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/481/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/481/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讀者可以注意到，這次我們要解的問題已經不再是方法數，而是「最大值」了！相信讀者已經在先前見識過不少這種找到「最佳解」的題目，而理所當然的，在動態規劃的世界中，這種「最佳化問題」的佔比也不小。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"同時，伴隨著問題形式的改變，我們的輸入也不再只是單純的一個參數，而是一整串序列！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過別慌，問題形式雖然變了，解法其實並沒有什麼變。在原本數方法數的問題中，我們是令 $f(n)$ 為 $n$ 個人的答案；而在最佳化的問題中，我們只要想成 $f(n)$ 是「前 $n$ 個人的答案」就好了！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"遞迴式大同小異，這裡就直接先寫出來：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"$$\", _jsx(_components.br, {}), \"\\n\", \"f(n) =\", _jsx(_components.br, {}), \"\\n\", \"\\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"a_1 & n=1 \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"a_1 + a_2 & n=2\\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\max(f(n - 1), f(n - 2)) + a_n & \\\\text{otherwise}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以發現，在解決前 $n$ 個人的答案時，我們同樣是在窮舉站在第 $n$ 個人左邊的是誰，並得到一個子問題，只要已知每個子問題的答案的最大值，再補上第 $n$ 個人，我們就可以在考慮到所有狀況後得到整個問題的最大值！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這邊就先不附上程式碼，供讀者自行練習。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"敘述一個動態規劃演算法\",\n      children: \"敘述一個動態規劃演算法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讀者可以發現在前面的問題中，$f(n)$ 已經不再單純的是 $n$ 個人的答案，而是「前」$n$ 個人的答案。這是因為單單一個數字 $n$ 已經不夠描述該問題的全貌，就好比今天我們說 $f(5)$ 是 $5$ 個人的答案，這樣究竟是哪 $5$ 個人呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，在設計動態規劃演算法的時候我們必須知道，我們在定義要解決的函數時是可以使用「一句話」來描述的。而在競賽程式中，為了溝通方便，我們會開始使用與「函數」、「遞迴式」這類名詞較為不一樣的用語，就讓我們來透過這些常用的用語來帶讀者認識如何在競賽程式中「敘述」一個動態規劃演算法。\"\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"definition\",\n      title: \"動態規劃演算法的用語\",\n      refId: \"dpterms\",\n      number: \"1\",\n      children: [_jsx(_components.p, {\n        children: \"在動態規劃演算法中，會有三個重要的元素\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"狀態：用少少的幾個參數，來描繪出答案被構建出來的「\", _jsx(_components.strong, {\n            children: \"過程\"\n          }), \"」。\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"轉移：狀態與狀態之間的\", _jsx(_components.strong, {\n            children: \"關係\"\n          }), \"，用來表示「過程」之間是如何轉換的、以及其轉換後造成的變化。\", \"\\n\", _jsxs(_components.ul, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"而將轉移產生的變化寫成數學式子後，就變成了「轉移式」。\"\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"初始狀態：要進入一段過程就必須有一個開始，你的答案是從何開始算起的？\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"敘述一個動態規劃演算法-複習三個例子\",\n      children: \"複習三個例子\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就拿我們前面學過的例子來重新用上面的用語講過一遍：\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"敘述一個動態規劃演算法-複習三個例子-爬樓梯問題\",\n      children: \"爬樓梯問題\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"狀態：$dp[i]$ 是爬到第 $i$ 階的方法數\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"轉移：在爬到第 $i$ 階前，一定是先爬到 $i-1$ 階或 $i-2$ 階\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"初始狀態：主角是\", _jsx(_components.strong, {\n          children: \"從第零階出發\"\n        }), \"的\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在爬樓梯問題中，一步一步經過若干個階層爬上來的，每當他停在特定的第 $i$ 階，我們就把這個關鍵的停留過程當成一種「狀態」。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而要如何停留在第 $i$ 階呢？一定是從第 $i-1$ 階的狀態或第 $i-2$ 階的狀態轉變過來，兩種轉變方法都給予了停留在第 $i$ 階的可能性。因而產生了轉移式：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] =\", _jsx(_components.br, {}), \"\\n\", \"\\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"0 & i = 0\\\\text{（初始狀態）} \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"1 & i = 1 \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"dp[i - 1] + dp[i - 2] & \\\\text{otherwise}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"敘述一個動態規劃演算法-複習三個例子-別離太遠\",\n      children: \"別離太遠\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"狀態：$dp[i]$ 是挑了編號 $i$ 的人時的方法數\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"轉移：在挑了第 $i$ 個人之前，上一個挑的人一定是編號 $i-1$ 的人或編號 $i-2$ 的人\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"初始狀態：我們從已經挑了編號 $1$ 的人開始\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在別離太遠中，我們可以依序考慮編號 $1$ 的人、編號 $2$ 的人、編號 $3$ 的人、……就可以觀察到每次挑選編號 $i$ 個人時，便產生了一個值得記憶的「過程」，進而讓我們設計出狀態。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而補上初始狀態的「從編號 $1$ 開始」後，也就有了轉移式：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] =\", _jsx(_components.br, {}), \"\\n\", \"\\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"1 & i = 1\\\\text{（初始狀態）} \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"1 & i = 2 \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"dp[i - 1] + dp[i - 2] & \\\\text{otherwise}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"敘述一個動態規劃演算法-複習三個例子-別離太遠 續\",\n      children: \"別離太遠 續\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"回到了引發我們重新敘述一遍動態規劃的罪魁禍首，這時候我們再來看一遍：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"狀態：$dp[i]$ 是挑了編號 $i$ 的人時的最大總能力值\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"轉移：在挑了第 $i$ 個人之前，上一個挑的人一定是編號 $i-1$ 的人或編號 $i-2$ 的人\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"初始狀態：我們從已經挑了編號 $1$ 的人開始\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以發現就和前一個問題幾乎一模一樣，只是我們在意的值從「方法數」變成了「最大總能力值」，其狀態與狀態間的影響上也從「加法」變成了「取 $\\\\max$」，才有了轉移式：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] =\", _jsx(_components.br, {}), \"\\n\", \"\\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"a_1 & i = 1\\\\text{（初始狀態）} \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"a_1 + a_2 & i = 2 \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\max(dp[i - 1], dp[i - 2]) + a_i & \\\\text{otherwise}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"敘述一個動態規劃演算法-時間複雜度\",\n      children: \"時間複雜度\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"找出狀態和轉移後，往往最簡單計算時間複雜度的方法就是\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"狀態數 \\\\times 轉移時間\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"就像前面的三個例子都有 $O(N)$ 個狀態、轉移式的計算都是 $O(1)$，因此總時間複雜度就是 $O(N)\\\\times O(1)=O(N)$。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"還記得別離太近嗎？若不特別開一個變數紀錄總和，照著一開始所寫下的轉移式寫成程式的話，就會獲得一個「$O(N)$ 個狀態、轉移 $O(N)$」的演算法，進而讓總時間複雜度是 $O(N)\\\\times O(N)=O(N^2)$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"當然還存在著更複雜的狀況，不過這裡就不再多提了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"敘述一個動態規劃演算法-空間複雜度\",\n      children: \"空間複雜度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"空間複雜度通常總是比時間複雜度來得單純，這是因為動態規劃的本質就是「記下每個狀態的答案」，也因此空間上的花費就理所當然的是「狀態數量」啦！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"到目前為止，我們講解過動態規劃問題的空間複雜度都是 $O(N)$，未來讀者就能逐漸看到不同的空間複雜度了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"敘述一個動態規劃演算法-整理一下\",\n      children: \"整理一下\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"若將稍早我們重新提到的前兩個例子與我們之前使用「函數」講解的方式做比較的話，就會發現我們\", _jsx(_components.strong, {\n        children: \"強調了過程的重要性\"\n      }), \"。這也是使用「狀態」這個詞的一大用意之一。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在動態規劃中，意識到自己設計的動態規劃演算法實際上是在對所有可能的「過程」進行歸納是一件很重要的事情。當然，初學時可能還不太能完全掌握以上概念，筆者這邊推薦讀者可以在試圖設計動態規劃演算法是先試著遵守以下守則解題：\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"tips\",\n      title: \"動態規劃的解題守則\",\n      refId: \"dptips\",\n      number: \"1\",\n      children: _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"設計狀態\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"寫出轉移式\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"找出初始狀態\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"找出所求答案\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"計算複雜度\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"寫成程式碼\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們會順著這個守則帶大家解決以下幾道例題：\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"例題\",\n      children: \"例題\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"例題-例題一 ― 小心狀態陷阱\",\n      children: \"例題一 ― 小心狀態陷阱\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=b589\",\n      src: \"ZeroJudge b589\",\n      name: \"超級馬拉松賽\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/ZeroJudge/b589/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/b589/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b589/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b589/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題一 ― 小心狀態陷阱-設計狀態\",\n      children: \"設計狀態\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先是設計狀態，若天真的令 $dp[i]$ 是「跑完前 $i$ 段路徑的最大得分」那就錯了！\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這是因為當我們要寫出轉移式時，會想著第 $i$ 段路徑的結束應該是來自第 $i-1$ 段，但問題就在於\", _jsx(_components.strong, {\n        children: \"我們不知道第 $i-1$ 段是否加速了\"\n      }), \"，進而讓我們不知道對於第 $i$ 段路徑的變化是否要歸零處理。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此這裡讀者必須意識到，所謂「狀態」內必須包含所有跟「變化」有關的資訊，那要怎麼設計呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"筆者這邊提供的方式是：令 $dp[i]$ 為「跑完前 $i$ 段路徑，且第 $i$ 段並沒有加速的最大得分」。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"為何要這樣設計呢？就讓我們接續後面的步驟。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題一 ― 小心狀態陷阱-寫出轉移式\",\n      children: \"寫出轉移式\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有了前述定義後，對於 $dp[i]$ 就會有兩種轉移：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"正常的跑第 $i$ 段，這時候第 $i-1$ 段不能加速\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"加速跑第 $i-1$ 段，第 $i$ 段休息\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這分別對應到什麼呢？假設第 $i$ 段的分數是 $p_i$，寫成式子的話就會是\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] = \\\\max(dp[i - 1] + p_i, dp[i - 2] + 2 \\\\times p_{i - 1})\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"沒錯！有了「最後一段不能加速」的限制後，對於上述的兩種轉移，我們就不會因為前面的加速發生「加速後還不休息」的狀況了。換句話說，也可以想成我們在轉移時強迫加速後一定要跟著一次休息，才完美避免了這個狀況。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題一 ― 小心狀態陷阱-找出初始狀態\",\n      children: \"找出初始狀態\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"除了 $dp[0]$，也就是什麼都還沒跑，的值是 $0$ 外，其實 $dp[1]$ 應該也最好要被當成一個初始狀態。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"為什麼要定義這個值呢？這是因為 $dp[1]$ 如果直接呼叫我們的轉移式就會存取到 $dp[-1]$，是直接超出我們想像的非法值，也因此會直接想讓 $dp[1]$ 在一開始就被定義清楚，也就讓完整的 dp 式變成：\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] = \\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"0 & i=0\\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"p_i & i=1\\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\max(dp[i - 1] + p_i, dp[i - 2] + 2 \\\\times p_{i - 1}) & \\\\text{otherwise}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"當然，有另一種做法就是「令 $dp[-1]$ 為負無限大」。這是什麼意思呢？可以想成是因為 $dp[-1]$ 已經是一個「不應該存在的狀態」，所以如果真的想使用這個狀態，就應該給予「無限大的懲罰」，來讓該次轉移肯定會失敗。寫成 dp 式的話就是：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] = \\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"-\\\\infty & i=-1\\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"0 & i=0\\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\max(dp[i - 1] + p_i, dp[i - 2] + 2 \\\\times p_{i - 1}) & \\\\text{otherwise}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然如此，這個負無限大要多大呢？最好是一個「只要採用了，就一定不會是最佳解」的值來避免這個轉移發生，例如因為最大的分數為 $100$，我們知道得分最大最大也就 $2\\\\times 100\\\\times n$ 而已，所以只要設得比 $-200n$ 還小，那麼一旦把這個值加進答案裡，不管後續的狀態再怎麼轉移，也不可能成為最佳答案了。\"\n    }), \"\\n\", _jsxs(Info, {\n      type: \"warning\",\n      children: [_jsxs(_components.p, {\n        children: [\"實際寫程式時，千萬不要真的寫出 \", _jsx(_components.code, {\n          children: \"dp[-1]\"\n        }), \" 這種東西，這可是妥妥的 Undefined behavior！詳見\", _jsx(ContentReference, {\n          type: \"content\",\n          code: \"Implementation/buglist\",\n          mode: \"default\",\n          topicTitle: \"實作技巧\",\n          articleTitle: \"常見錯誤列表\"\n        }), \"對未定義行為的講解。\"]\n      }), _jsxs(_components.p, {\n        children: [\"具體解決方法通常就是靠一個 \", _jsx(_components.code, {\n          children: \"if\"\n        }), \" 來進行特判，也可以試著改成\"]\n      }), _jsx(Refcode, {\n        lang: \"cpp\",\n        lineno: \"false\",\n        code: \"int get_dp(int idx) {\\n    if (idx == -1) return -INF;\\n    return dp[idx];\\n}\",\n        startFrom: \"1\"\n      }), _jsxs(_components.p, {\n        children: [\"這種寫法來透過 \", _jsx(_components.code, {\n          children: \"get_dp(i)\"\n        }), \" 獲取 dp 值，其中 \", _jsx(_components.code, {\n          children: \"INF\"\n        }), \" 是一個夠大的常數，可以宣告在全域。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題一 ― 小心狀態陷阱-找出所求答案\",\n      children: \"找出所求答案\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以為答案就是 $dp[n]$ 嗎？別忘了 $dp[n]$ 有著「第 $n$ 條路徑不能加速」的限制，所以我們可能會不小心遺漏這個情況！因此，正確的所求答案其實為 $\\\\max(dp[n-1] + 2 \\\\times p_n, dp[n])$ 才對。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有另一個作法是自行加入額外的「第 $n+1$ 條路徑」，但讓他的得分為 $0$，這樣 $dp[n+1]$ 肯定兩種狀況都可以顧慮到！這裡就交給讀者自行思考了。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題一 ― 小心狀態陷阱-計算複雜度\",\n      children: \"計算複雜度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由於有 $O(n)$ 個狀態，轉移又是 $O(1)$，總時間複雜度自然就是 $O(n)\\\\times O(1)=O(n)$。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題一 ― 小心狀態陷阱-寫成程式碼\",\n      children: \"寫成程式碼\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"從上面的各種方法中挑選後，寫成程式碼就如下：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <iostream>\\nusing namespace std;\\n\\nconst int MAXN = 40;\\n\\nint p[MAXN + 5], dp[MAXN + 5];\\n\\nint main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    int n;\\n    while (cin >> n && n) {\\n        for (int i = 1; i <= n; ++i)\\n            cin >> p[i];\\n        dp[1] = p[1];\\n        for (int i = 2; i <= n + 1; ++i)\\n            dp[i] = max(dp[i - 1] + p[i], dp[i - 2] + p[i - 1] * 2);\\n        cout << dp[n + 1] << \\\"\\\\n\\\";\\n    }\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"例題-例題二 ― 序列切割問題\",\n      children: \"例題二 ― 序列切割問題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://www.luogu.com.cn/problem/P1569\",\n      src: \"洛谷 P1569\",\n      name: \"Generic Cow Protests\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Luogu/P1569/description.mdx\",\n      constraintsMdx: \"guide/problems/Luogu/P1569/constraints.mdx\",\n      importMdx: \"guide/problems/Luogu/P1569/description.mdx\",\n      importMdx: \"guide/problems/Luogu/P1569/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題二 ― 序列切割問題-設計狀態\",\n      children: \"設計狀態\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不如就令 $dp[i]$ 為「前 $i$ 個數字的最佳解」。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題二 ― 序列切割問題-寫出轉移式\",\n      children: \"寫出轉移式\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在這類「將序列切成若干段」的題目有一個常見的轉移招數：那就是枚舉最後一段的長相為何。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"因此，想像以 $i$ 結尾的最後一段的上一段結尾是 $j$ 的話，就可以寫出轉移式：\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] = \\\\max_{1\\\\leq j<i}\\\\{dp[j] + 1 \\\\mid \\\\text{if }\\\\sum^{i}_{k=j+1}a_k\\\\geq 0\\\\}\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也就是窮舉 $j$，並檢查 $j+1\\\\sim i$ 的總和有沒有 $\\\\geq 0$ 就可以嘗試使用 $j$ 轉移了。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"不過這裡會有一個疑慮：如果\", _jsx(_components.strong, {\n        children: \"沒有一個合法的 $j$ 時\"\n      }), \"該怎麼辦？\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這時候最簡單的做法就是拿出前一個例題有提過的方法：賦予 $dp[i]$ 負無限大！讓「嘗試使用該狀態轉移」的獲得無可挽回的懲罰就可以了。讀者可以想想看這裡的負無限大應該設置成多少，配合待會「找出所求答案」的階段做思考。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題二 ― 序列切割問題-找出初始狀態\",\n      children: \"找出初始狀態\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"很單純的，令 $dp[0]=0$ 可以解決所有事情。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題二 ― 序列切割問題-找出所求答案\",\n      children: \"找出所求答案\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"很單純的，$dp[n]$ 就會是答案。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過要怎麼判斷「無解」呢？直接判斷其為負無限大是不對的！這是因為有可能 $dp[n]$ 是嘗試從別的不合法狀態轉移過來的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這裡只需要利用「負無限大」真的很小的特性，就可以單純用 $dp[n]$ 的值做判斷了，這裡一樣交給讀者思考看看。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題二 ― 序列切割問題-計算複雜度\",\n      children: \"計算複雜度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"狀態數為 $O(n)$，那轉移呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"若貿然實作前述的轉移式，就會直接獲得 $O(n^2)$ 的轉移時間，這是因為窮舉 $j$ 需要 $O(n)$、計算總和又需要 $O(n)$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過還請別太死的照抄轉移式，別忘了我們之前有教過大家「開個變數儲存總和」的技巧，這裡我們只要「倒著窮舉 $j$」，就可以邊窮舉 $j$ 邊維護到當前為止的和了。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"又或者，這其實就是仰賴\", _jsx(ContentReference, {\n          type: \"content\",\n          code: \"BasicAlgorithm/partial_sum\",\n          mode: \"article\",\n          topicTitle: \"基礎演算法\",\n          articleTitle: \"前綴和與差分\"\n        }), \"就能 $O(1)$ 得出的東西。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題二 ― 序列切割問題-寫成程式碼\",\n      children: \"寫成程式碼\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"參考實作如下，若上述的解說有想不通的地方的話，也可以來這裡看答案：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\nconst int MAXN = 100005;\\n\\nint arr[MAXN], dp[MAXN];\\n\\nint main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    int n;\\n    cin >> n;\\n    for (int i = 1; i <= n; ++i)\\n        cin >> arr[i];\\n    for (int i = 1; i <= n; ++i) {\\n        dp[i] = -n; // 初始化成一個使用了便無法挽回的值\\n        int sum = 0;\\n        for (int j = i - 1; j >= 0; --j) { // 倒著計算總和以省去重新計算的時間\\n            sum += arr[j + 1]; \\n            if (sum >= 0)\\n                dp[i] = max(dp[i], dp[j] + 1);\\n        }\\n    }\\n    if (dp[n] <= 0) cout << \\\"Impossible\\\\n\\\"; // 正是因為使用了負無限大，答案才會 <= 0\\n    else cout << dp[n] << \\\"\\\\n\\\";\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"例題-例題三 ― 整理轉移式\",\n      children: \"例題三 ― 整理轉移式\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://www.luogu.com.cn/problem/U425829\",\n      src: \"洛谷 U425829\",\n      name: \"股票买卖 V\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Luogu/U425829/description.mdx\",\n      constraintsMdx: \"guide/problems/Luogu/U425829/constraints.mdx\",\n      importMdx: \"guide/problems/Luogu/U425829/description.mdx\",\n      importMdx: \"guide/problems/Luogu/U425829/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題三 ― 整理轉移式-設計狀態\",\n      children: \"設計狀態\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這裡如果令 $dp[i]$ 為「第 $i$ 天結束的最佳解」又會造成問題了，這次的問題是什麼呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"非常明顯的，除了需要多等 $1$ 天的限制之外，還有一個大問題就是「不知道現在手上是否有股票」。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，這裡的狀態就定義為「第 $i$ 天結束，且手上沒有股票的最佳解」。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題三 ― 整理轉移式-寫出轉移式\",\n      children: \"寫出轉移式\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然如此，$dp[i]$ 就會有兩種轉移\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"繼承 $i-1$ 的狀態，在第 $i$ 天什麼都不做\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"試圖在第 $i$ 天賣股票，因此我們必須找到一個買股票的日期 $j$\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"寫成轉移式的話就會是\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"dp[i] = \\\\max(dp[i - 1], \\\\max_{1\\\\leq j<i}\\\\{ a_i - a_j + {\\\\color{red}{dp[j-2]}}\\\\})\", _jsx(_components.br, {}), \"\\n\", \"$$\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"注意到為了處理多等 $1$ 天的問題，由於我們在後半部分是嘗試在第 $j$ 天買股票，因此 $j-1$ 天是不能有任何動作的，我們才使用 $dp[j-2]$ 作為轉移來源。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，如果繼續跟著步驟走，就會發現到了複雜度的步驟，轉移的所花時間是 $O(N)$，整體時間複雜度算起來就會是 $O(N^2)$，肯定會超時！\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這裡就得用到本章節最後一個技巧：\", _jsx(_components.strong, {\n        children: \"整理轉移式\"\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"轉移式可不是寫出來就結束的，仔細看著上面式子的右半部份：\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"\\\\max_{1\\\\leq j<i}\\\\{ a_i - a_j + dp[j-2]\\\\}\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"注意到因為這個 $\\\\max$ 函數是在窮舉 $j$，所以我們可以把 $a_i$ 提出來變成\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"a_i + \\\\max_{1\\\\leq j<i}\\\\{- a_j + dp[j-2]\\\\}\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"如此一來，右邊的部分就跟 $i$ 完全無關了！\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"不過這樣有什麼用呢？非常有用！如果看一下 $i+1$ 同樣部份的長相：\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"a_{i+1} + \\\\max_{1\\\\leq j<i+1}\\\\{- a_j + dp[j-2]\\\\}\", _jsx(_components.br, {}), \"\\n\", \"$$\", _jsx(_components.br, {}), \"\\n\", \"就會發現 $\\\\max$ 函數內部的取值會剛好比 $i$ 多一個 $-a_i + dp[i-2]$ 而已，這代表我們可以開一個共同變數維護到當前為止的最大值！\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，轉移複雜度就在這裡優化成了 $O(1)$，非常漂亮。而具體的細節就交給讀者自己思考看看了。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題三 ― 整理轉移式-找出初始狀態\",\n      children: \"找出初始狀態\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"雖然一樣能令 $dp[0]=0$，但別忘了我們在嘗試買第 $1$ 天的股票時會不小心取到 $dp[-1]$ 的值，不過這時候就不算是不合法取值了，直接一起當成 $0$ 就可以了。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"想一想，這跟前面提到 $dp[-1]$ 的差別是什麼？\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題三 ― 整理轉移式-找出所求答案\",\n      children: \"找出所求答案\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"當然，$dp[N]$ 就是我們的所求。\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題三 ― 整理轉移式-計算複雜度\",\n      children: \"計算複雜度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"經過先前的努力，時間複雜度成功優化至 $O(N)\\\\times O(1)=O(N)$！\"\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"例題-例題三 ― 整理轉移式-寫成程式碼\",\n      children: \"寫成程式碼\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這裡就一樣供讀者參考：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <iostream>\\n#include <algorithm>\\nusing namespace std;\\n\\nconst int MAXN = 100005;\\n\\nint arr[MAXN], dp[MAXN];\\n\\nint main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    int n;\\n    cin >> n;\\n    for (int i = 1; i <= n; ++i)\\n        cin >> arr[i];\\n    int mx = -2e9;\\n    for (int i = 2; i <= n; ++i) {\\n        int val = -arr[i - 1];\\n        if (i >= 3) val += dp[i - 3];\\n        mx = max(mx, val);\\n        dp[i] = max(arr[i] + mx, dp[i - 1]);\\n    }\\n    cout << dp[n] << \\\"\\\\n\\\";\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"小結\",\n      children: \"小結\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有一套守則好像就能解決所有動態規劃問題了嗎？是也不是！在上述的守則當中，每一步都可以衍伸出更複雜的狀況，這使得動態規劃有了獨立成一個大主題的價值。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過讀者也不必太恐慌，光是單純的跟隨著上面這套守則，再了解過幾個常見的解題套路過後，極大多數的動態規劃題目都能迎刃而解，而這也是我們要率先傳授給讀者的——畢竟藝術總是得先從模仿開始。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此在接下來的章節中，我們會開始帶大家了解設計動態規劃演算法時各種常見的招數，下一個章節就從最基本的「增加維度」開始講起。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://atcoder.jp/contests/dp/tasks/dp_a\",\n      src: \"AtCoder Educational DP Contest Problem A\",\n      name: \"Frog 1\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/AtCoder/dp_a/description.mdx\",\n      constraintsMdx: \"guide/problems/AtCoder/dp_a/constraints.mdx\",\n      importMdx: \"guide/problems/AtCoder/dp_a/description.mdx\",\n      importMdx: \"guide/problems/AtCoder/dp_a/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://atcoder.jp/contests/dp/tasks/dp_b\",\n      src: \"AtCoder Educational DP Contest Problem B\",\n      name: \"Frog 2\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/AtCoder/dp_b/description.mdx\",\n      constraintsMdx: \"guide/problems/AtCoder/dp_b/constraints.mdx\",\n      importMdx: \"guide/problems/AtCoder/dp_b/description.mdx\",\n      importMdx: \"guide/problems/AtCoder/dp_b/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://atcoder.jp/contests/abc129/tasks/abc129_c\",\n      src: \"AtCoder Beginner Contest 129 Problem C\",\n      name: \"Typical Stairs\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/AtCoder/abc129_c/description.mdx\",\n      constraintsMdx: \"guide/problems/AtCoder/abc129_c/constraints.mdx\",\n      importMdx: \"guide/problems/AtCoder/abc129_c/description.mdx\",\n      importMdx: \"guide/problems/AtCoder/abc129_c/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/482\",\n      src: \"NCOJ 482\",\n      name: \"[Tutorial] 別離太近 續\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NCOJ/482/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/482/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/482/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/482/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/481/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"今天，臺大程式解題社的其中 $N$ 位選手面向你站成了一個橫排，由左至右的編號為 $1\\\\sim N$，身為這次活動負責人的你，被社長指派必須挑出一些人站出來進行機智問答，這些站出來的人只會往你的方向前進一步，並不會左右移動。不過，邪惡的社長為了增添你的麻煩，特別告訴你說你選出來參加問答的人選必須要滿足以下條件：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"一定要挑編號 $1$ 的人。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"一定要挑編號 $N$ 的人。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"對於任兩個在選出來的人當中相鄰的人，他們兩個人的編號差不可以\", _jsx(_components.strong, {\n          children: \"超過\"\n        }), \" $2$。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://oj.ntucpc.org/problems/94\",\n        children: \"你已經知道有幾種挑人的方法\"\n      }), \"，因此調查了一遍每個人的問答能力值，分別為 $a_1, a_2, \\\\ldots, a_N$，代表若第 $i$ 個人被挑選出來參加機智問答，他可以讓總能力值增加 $a_i$，注意到有些人的能力值是負的，代表你挑選他出來參加機智問答反而會讓總能力值變小（可能是因為他身體不舒服吧！）。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在你的目標是要最大化挑選出來的人的總能力值，請問這個最大值會是多少呢？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/481/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq N \\\\leq 10^6$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$-10^9 \\\\leq a_i\\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b589/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"一個超級馬拉松比賽將開始。在遊戲中，選手每天需要跑不同的路徑。假設遊戲全部有 $n$ 條路徑；每個路徑得分可以是不同的。如果一名選手不能在規定時間內完成一條路徑，他該路徑得到 $0$ 分；如果玩家完成了一條路徑在一個規定的時間，他得到該路徑設定的得分；如果玩家完成了一條路徑，用較短的時間，他可以得兩倍分數。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"小愛想參加這個比賽，她如果在一條路徑上按正常速度來跑，就只能拿到原始分數，如果他加速跑，就能拿到兩倍分數，不過她就會需要在加速跑完後的下一條路徑上休息而速度變慢得到 $0$ 分，請寫一個程式幫助小愛計算哪些路徑應該加速得到兩倍分數而能獲得最高的總得分。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b589/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 40$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"分數皆介於 $10\\\\sim 100$ 之間\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"單一測試檔案有多組資料，輸入至 $0$ 結束\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Luogu/P1569/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"約翰家的 $n$ 頭奶牛聚集在一起，排成一列，正在進行一項抗議活動。第 $i$ 頭奶牛的理智度為 $a_i$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"約翰希望奶牛在抗議時保持理性，為此，他打算將所有的奶牛隔離成若干個小組，每個小組內的奶牛的理智度總和都要不小於零。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由於奶牛是按直線排列的，所以一個小組內的奶牛位置必須是連續的。請幫助約翰計算一下，最多分成幾組。或告訴約翰這是不可能的。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Luogu/P1569/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 1000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$|a_i| \\\\leq 10^5$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Luogu/U425829/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"給定一個長度為 $N$ 序列，序列中的第 $i$ 個數字 $a_i$ 表示一個給定股票在第 $i$ 天的價格。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"請設計一個演算法計算出最大利潤。在滿足以下條件的情況下，你可以盡可能地完成數次交易（多次買賣一支股票）:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"你不能同時參與多筆交易（你必須在再次購買前出售掉之前的股票）。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"賣出股票的隔天無法買入股票，需要多等 $1$ 天才可以買。\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Luogu/U425829/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N \\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$a_i \\\\leq 10^4$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/dp_a/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 顆石頭，第 $i$ 顆的高度為 $h_i$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有一隻青蛙一開始在 $1$ 號石頭，他會持續以下動作直到跳到 $N$ 號石頭：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"如果該隻青蛙在 $i$ 號石頭，他可以選擇跳到 $i+1$ 號石頭或 $i+2$ 號石頭。若他選擇跳到 $j$ 號石頭，則他需要花費 $|h_i - h_j|$。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"試求青蛙跳到 $N$ 號石頭的最小總花費。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/dp_a/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$2\\\\leq N \\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq h_i \\\\leq 10^4$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/dp_b/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 顆石頭，第 $i$ 顆的高度為 $h_i$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有一隻青蛙一開始在 $1$ 號石頭，他會持續以下動作直到跳到 $N$ 號石頭：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"如果該隻青蛙在 $i$ 號石頭，他可以選擇跳到 $i+1, i+2, \\\\ldots$ 或 $i+K$ 號石頭。若他選擇跳到 $j$ 號石頭，則他需要花費 $|h_i - h_j|$。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"試求青蛙跳到 $N$ 號石頭的最小總花費。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/dp_b/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$2\\\\leq N \\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq K\\\\leq 100$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq h_i \\\\leq 10^4$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/abc129_c/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 個階梯，Takahashi 現在在第 $0$ 層階梯，他每次可以往上爬 $1$ 或 $2$ 層階梯。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，第 $a_1, a_2, \\\\ldots, a_M$ 層階梯都壞了，不可以踩在這些層數上。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"請問 Takahashi 有幾種爬到第 $N$ 層階梯的方法？輸出答案模 $10^9+7$。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/abc129_c/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq N \\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq M\\\\leq N - 1$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq a_1< a_2<\\\\cdots<a_M \\\\leq N-1$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/482/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"今天，臺大程式解題社的其中 $N$ 位選手面向你站成了一個橫排，由左至右的編號為 $1\\\\sim N$，身為這次活動負責人的你，被社長指派必須挑出一些人站出來進行機智問答，這些站出來的人只會往你的方向前進一步，並不會左右移動。不過，邪惡的社長為了增添你的麻煩，特別告訴你說你選出來參加問答的人選必須要滿足以下條件：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"一定要挑編號 $1$ 的人。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"一定要挑編號 $N$ 的人。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"對於任兩個在選出來的人當中相鄰的人，他們兩個人的編號差不可以\", _jsx(_components.strong, {\n          children: \"小於\"\n        }), \" $2$。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://oj.ntucpc.org/problems/95\",\n        children: \"你已經知道有幾種挑人的方法\"\n      }), \"，因此調查了一遍每個人的問答能力值，分別為 $a_1, a_2, \\\\ldots, a_N$，代表若第 $i$ 個人被挑選出來參加機智問答，他可以讓總能力值增加 $a_i$，注意到有些人的能力值是負的，代表你挑選他出來參加機智問答反而會讓總能力值變小（可能是因為他身體不舒服吧！）。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在你的目標是要最大化挑選出來的人的總能力值，請問這個最大值會是多少呢？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/482/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$3 \\\\leq N \\\\leq 10^6$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$-10^9 \\\\leq a_i\\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"不再是線性遞迴","depth":1,"code":"不再是線性遞迴"},{"text":"敘述一個動態規劃演算法","depth":1,"code":"敘述一個動態規劃演算法"},{"text":"複習三個例子","depth":2,"code":"敘述一個動態規劃演算法-複習三個例子"},{"text":"爬樓梯問題","depth":3,"code":"敘述一個動態規劃演算法-複習三個例子-爬樓梯問題"},{"text":"別離太遠","depth":3,"code":"敘述一個動態規劃演算法-複習三個例子-別離太遠"},{"text":"別離太遠 續","depth":3,"code":"敘述一個動態規劃演算法-複習三個例子-別離太遠 續"},{"text":"時間複雜度","depth":2,"code":"敘述一個動態規劃演算法-時間複雜度"},{"text":"空間複雜度","depth":2,"code":"敘述一個動態規劃演算法-空間複雜度"},{"text":"整理一下","depth":2,"code":"敘述一個動態規劃演算法-整理一下"},{"text":"例題","depth":1,"code":"例題"},{"text":"例題一 ― 小心狀態陷阱","depth":2,"code":"例題-例題一 ― 小心狀態陷阱"},{"text":"設計狀態","depth":3,"code":"例題-例題一 ― 小心狀態陷阱-設計狀態"},{"text":"寫出轉移式","depth":3,"code":"例題-例題一 ― 小心狀態陷阱-寫出轉移式"},{"text":"找出初始狀態","depth":3,"code":"例題-例題一 ― 小心狀態陷阱-找出初始狀態"},{"text":"找出所求答案","depth":3,"code":"例題-例題一 ― 小心狀態陷阱-找出所求答案"},{"text":"計算複雜度","depth":3,"code":"例題-例題一 ― 小心狀態陷阱-計算複雜度"},{"text":"寫成程式碼","depth":3,"code":"例題-例題一 ― 小心狀態陷阱-寫成程式碼"},{"text":"例題二 ― 序列切割問題","depth":2,"code":"例題-例題二 ― 序列切割問題"},{"text":"設計狀態","depth":3,"code":"例題-例題二 ― 序列切割問題-設計狀態"},{"text":"寫出轉移式","depth":3,"code":"例題-例題二 ― 序列切割問題-寫出轉移式"},{"text":"找出初始狀態","depth":3,"code":"例題-例題二 ― 序列切割問題-找出初始狀態"},{"text":"找出所求答案","depth":3,"code":"例題-例題二 ― 序列切割問題-找出所求答案"},{"text":"計算複雜度","depth":3,"code":"例題-例題二 ― 序列切割問題-計算複雜度"},{"text":"寫成程式碼","depth":3,"code":"例題-例題二 ― 序列切割問題-寫成程式碼"},{"text":"例題三 ― 整理轉移式","depth":2,"code":"例題-例題三 ― 整理轉移式"},{"text":"設計狀態","depth":3,"code":"例題-例題三 ― 整理轉移式-設計狀態"},{"text":"寫出轉移式","depth":3,"code":"例題-例題三 ― 整理轉移式-寫出轉移式"},{"text":"找出初始狀態","depth":3,"code":"例題-例題三 ― 整理轉移式-找出初始狀態"},{"text":"找出所求答案","depth":3,"code":"例題-例題三 ― 整理轉移式-找出所求答案"},{"text":"計算複雜度","depth":3,"code":"例題-例題三 ― 整理轉移式-計算複雜度"},{"text":"寫成程式碼","depth":3,"code":"例題-例題三 ― 整理轉移式-寫成程式碼"},{"text":"小結","depth":1,"code":"小結"},{"text":"習題","depth":1,"code":"習題"}]}},"__N_SSG":true}