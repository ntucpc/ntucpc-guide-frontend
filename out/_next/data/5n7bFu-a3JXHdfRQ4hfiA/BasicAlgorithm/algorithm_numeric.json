{"pageProps":{"props":{"mdxPath":"guide/content/BasicAlgorithm/algorithm_numeric/algorithm_numeric.mdx","content":[["guide/content/BasicAlgorithm/algorithm_numeric/algorithm_numeric.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Info, Problem, Refcode} = _components;\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"不要造輪子\",\n      children: \"不要造輪子\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"別人已經幫你做好的事，就別再自己做了。我們在用的 C++ 其實有提供「標準函式庫（Standard Library，簡稱 STL）」來輔助程式設計者引用各式各樣常用的功能來簡化程式碼，避免寫程式時還要浪費時間寫一堆已經寫過的東西。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們來複習一下在排序演算法時學過的插入排序法演算法：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void selection_sort(int a[], int n) {\\n    for (int i = 1; i < n; ++i) {\\n        int min_pos = i;\\n        for (int j = i + 1; j <= n; ++j) {\\n            if (a[min_pos] > a[j]) {\\n                min_pos = j;\\n            }\\n        }\\n        if (min_pos != i) { \\n            int tmp = a[min_pos];\\n            a[min_pos] = a[i];\\n            a[i] = tmp;\\n        }\\n    }\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果好好運用 \", _jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \" 的幫助，就可以簡化成這樣！\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void selection_sort(int a[], int n) {\\n    for (int i = 1; i < n; ++i) {\\n        swap(a[i], *min_element(a + i, a + n + 1));\\n    }\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"是不是簡潔多了呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下我們就來跟大家介紹幾個在演算法競賽中常用的函式。只要能熟悉的使用函式庫提供的函式，在比賽中往往都會是有利的加速。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"<algorithm>\",\n      children: _jsx(_components.code, {\n        children: \"<algorithm>\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-介紹\",\n      children: \"介紹\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \" 是 C++ 用來提供各式簡易演算法操作的函式庫，在裡面可以找到各種寫程式常常會用到的演算法。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只要在程式的開頭寫上 \", _jsx(_components.code, {\n        children: \"#include <algorithm>\"\n      }), \" 就可以使用裡面的函式們。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-swap(val1, val2)\",\n      children: _jsx(_components.code, {\n        children: \"swap(val1, val2)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"交換兩個元素時，如果總是要花三行寫\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int tmp = a;\\na = b;\\nb = tmp;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不覺得很麻煩嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這時候你只要使用\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"swap(a, b);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以乾淨的搞定！\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      refId: \"<algorithm>-min(val1, val2)\",\n      children: [_jsx(_components.code, {\n        children: \"min(val1, val2)\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"max(val1, val2)\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"每次要問兩個元素誰小誰大時，總是要多寫一個 \", _jsx(_components.code, {\n        children: \"if\"\n      }), \" 很麻煩嗎？只要使用\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"min(a, b);\\nmax(a, b);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以分別回傳兩個元素中較小和較大的值，\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"更進階一點，如果希望一次知道多個元素的最小或最大值時，只要多加一個大括號在外面，例如\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"min({a, b, c});\\nmax({a, b, c});\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以了。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      refId: \"<algorithm>-min_element(first, last)\",\n      children: [_jsx(_components.code, {\n        children: \"min_element(first, last)\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"max_element(first, last)\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，如果是要尋找一個陣列的最小值的話怎麼辦？自己寫的話得多開一個變數、寫一個迴圈遍歷元素才能搞定。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但如果使用函式庫的話，在 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" ~ \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 之間找最小值，就只需要寫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int min_val = *min_element(a + 1, a + n + 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"需要特別注意的是，\", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 裡面第一個放的參數是「陣列開始位置的指標」，第二個則是「陣列結束位置的\", _jsx(_components.strong, {\n        children: \"後一個位置\"\n      }), \"的指標」。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"註：\", _jsx(_components.br, {}), \"\\n\", \"大多數 STL 函式庫的函式在指定「範圍」的時候，結尾都是用「陣列結束位置的\", _jsx(_components.strong, {\n          children: \"後一個位置\"\n        }), \"的指標」傳入的。其理由有非常多種，其中一個筆者認為最合理的理由就是當傳入的範圍是空的時候，STL 可以直接用「開始跟結尾相同」來直接判斷。這在數學上又稱作「左閉右開」。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"那前面的 \", _jsx(_components.code, {\n        children: \"*\"\n      }), \" 是來幹嘛的？這是因為我們偶爾尋找最小值時，不一定只是需要這個最小值的「值」，而是可能會希望知道「最小值位於哪個位置」。因此，\", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 回傳的值其實是「指標」，因此要加一個 \", _jsx(_components.code, {\n        children: \"*\"\n      }), \" 來把值取出來。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以，如果想知道位置的話，就可以寫\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int min_pos = min_element(a + 1, a + n + 1) - a;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"那如果有多個最小值呢？這時候得到的位置會是「最前面的最小值」，也就是從 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 掃到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \"，最早碰到的最小值。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最大值的用法也完全一樣，供參考\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int max_val = *max_element(a + 1, a + n + 1);\\nint max_pos = max_element(a + 1, a + n + 1) - a;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-sort(first, last)\",\n      children: _jsx(_components.code, {\n        children: \"sort(first, last)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"程式競賽最重要的武器之一，排序！要把一個序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 排序，用法也跟 \", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 等函式一樣，只要呼叫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整個序列就會在 $O(n\\\\log n)$ 的時間內被排序好了！是不是很方便呢？\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-nth_element(first, nth_pos, last)\",\n      children: _jsx(_components.code, {\n        children: \"nth_element(first, nth_pos, last)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然有最小、最大，那就有第 $k$ 小！如果要找出一個序列中第 $k$ 小的數字，聰明的讀者應該可以馬上想到以下寫法\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1);\\nint kth_val = a[k];\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這樣的缺點是，時間複雜度是 $O(n\\\\log n)$，但實際上尋找第 $k$ 小可以 $O(n)$ 搞定！因此，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 就實作了足夠快的演算法來完成這件事。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"註：\", _jsx(_components.br, {}), \"\\n\", \"實際上在 C++ 的規範中，\", _jsx(_components.code, {\n          children: \"nth_element\"\n        }), \" 只需要實作在「平均情況複雜度」是 $O(n)$ 的演算法即可，這意味著在運氣很差的情況下，呼叫 \", _jsx(_components.code, {\n          children: \"nth_element\"\n        }), \" 還是有可能比 $O(n)$ 還慢。但這種情況是不容易遇到的，甚至可以打亂整個序列來迴避特別設計過的測試資料。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 的用法與 \", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 有些差別，假設要找第 $k$ 小，可以這樣寫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"nth_element(a + 1, a + k, a + n + 1);\\nint kth_val = a[k];\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 的第一個和第三個參數與 \", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 一樣，而第二個參數就是「第 $k$ 小的值的位置」。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"沒錯，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 不直接回傳第 $k$ 小的值，而是讓使用者告訴他第 $k$ 小的值的位置，之後他就會幫忙把這個值放在這個位置。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"更準確的說，讀者可以想像 \", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 在做的事就是把「排序好後，會出現在第二個參數位置的值放過去」。不僅如此，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 還會額外保證函式執行完後，「第 $1\\\\sim k-1$ 小」會放在第 $k$ 小的值的左邊；「第 $k+1\\\\sim n$ 小」則會放在第 $k$ 小的值的右邊，但不保證排序的順序。舉例來說，如果序列是\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"3 1 4 1 5 9 2 6\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"呼叫找第四小的話，一種可能的長相是\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"1 2 1 \\\"3\\\" 9 4 6 5\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在已知第四小的數字是 \", _jsx(_components.code, {\n        children: \"3\"\n      }), \" 的情況下，\", _jsx(_components.code, {\n        children: \"3\"\n      }), \" 就會出現在第四個位置，而比較小的數字就會出現在左邊，但順序不一定；反之，比較大的數字就會出現在右邊，順序一樣不一定。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 在未來優化搜尋演算法時會有妙用，但現階段讀者可以先知道其存在就好。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-unique(first, last)\",\n      children: _jsx(_components.code, {\n        children: \"unique(first, last)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"unique\"\n      }), \" 從字面意義上來看，很像是在「把一樣的數字過濾到只剩一個」，但實際上略有差異。準確的說，\", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 在做的事情是「把\", _jsx(_components.strong, {\n        children: \"相鄰\"\n      }), \"一樣的數字過濾到只剩一個」，舉例來說，如果 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[10]\"\n      }), \" 是\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"1 3 3 2 4 4 4 3 3 5\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"呼叫 \", _jsx(_components.code, {\n        children: \"unique(a + 1, a + 11)\"\n      }), \" 之後會變成\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"1 3 2 4 3 5 ? ? ? ?\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其中 \", _jsx(_components.code, {\n        children: \"?\"\n      }), \" 的值代表不重要，這是因為我們需要的就是前六個「過濾完」的值。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但要怎麼知道呼叫完 \", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 後，過濾完的值有幾個呢？這時候就要仰賴 \", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 的回傳值，在上面的例子中，\", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 會回傳的值是 \", _jsx(_components.code, {\n        children: \"a + 7\"\n      }), \"，其實可以想像成「過濾完後序列結尾的下一個位置」，就跟我們傳入結尾時是一樣的概念。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"unique\"\n      }), \" 一個簡單的應用，就是可以真的把一樣的數字過濾掉，要達成這件事，我們勢必得讓所有一樣的數字「相鄰」。這要怎麼做呢？其實只要呼叫 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 就完事了！也就是說，對於給定的序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \"，只要先呼叫一次 \", _jsx(_components.code, {\n        children: \"sort(a + 1, a + n + 1)\"\n      }), \"，再 \", _jsx(_components.code, {\n        children: \"unique(a + 1, a + n + 1)\"\n      }), \"，就完成一樣數字的過濾了。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"<numeric>\",\n      children: _jsx(_components.code, {\n        children: \"<numeric>\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"<numeric>\"\n      }), \" 很類似 \", _jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \"，但專注在提供各式\", _jsx(_components.strong, {\n        children: \"數值相關\"\n      }), \"簡易演算法操作的函式庫，只要牽扯到數值（例如：四則運算），就容易被分類進 \", _jsx(_components.code, {\n        children: \"<numeric>\"\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只要在程式的開頭寫上 \", _jsx(_components.code, {\n        children: \"#include <numeric>\"\n      }), \" 就可以使用裡面的函式們。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<numeric>-accumulate(first, last, init_value)\",\n      children: _jsx(_components.code, {\n        children: \"accumulate(first, last, init_value)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"計算一個序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 的總和，最直接的做法就是開一個變數紀錄總和、再用一個迴圈掃過所有序列的值並加進變數內。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但 \", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 可以一行完成總和的計算，用法大致如下：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"accumulate(a + 1, a + n + 1, 0);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"前兩個參數跟我們前面學的一樣，是序列的開頭和結尾的後一個位置，最後一個參數則是「起始值」，也就是說，\", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 函式回傳的數值會是「起始值加上整段序列的總和」。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"為什麼需要起始值呢？可以想成是其實 C++ 把「開好一個存值的變數」的決定權交給使用者了，讀者可以執行下面這段程式碼看看效果：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int a[3] = {1000000000, 1000000000, 1000000000};\\ncout << accumulate(a, a + 3, 0) << \\\"\\\\n\\\";\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"理想上，上面這段程式碼的輸出應該要是 $3\\\\times 10^9$，但實際上，讀者可能會得到 \", _jsx(_components.code, {\n        children: \"-1294967296\"\n      }), \" 之類的輸出，應該不難猜到，總和吃了整數溢位（overflow），才會輸出不了超過 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 上限的 $3\\\\times 10^9$。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這時候如果是一般跑迴圈算總和的寫法，修正方法應該是把一開始開好的變數設成 \", _jsx(_components.code, {\n        children: \"long long int\"\n      }), \"。而這就是 \", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 讓使用者自己給起始值的一種用意，使用者可以直接讓起始值的變數型態是 \", _jsx(_components.code, {\n        children: \"long long int\"\n      }), \" 來迴避這樣基本的溢位問題。因此，只要改成以下模樣，就可以正常輸出了！\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int a[3] = {1000000000, 1000000000, 1000000000};\\ncout << accumulate(a, a + 3, 0LL) << \\\"\\\\n\\\";\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣「指定起始值」的功能其實還可以配合自定義運算子（Operator overloading）等來產生一些妙用，但這就稍微進階一些了，這裡不再贅述。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<numeric>-iota(first, last, init_value)\",\n      children: _jsx(_components.code, {\n        children: \"iota(first, last, init_value)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"iota\"\n      }), \" 在做的事情其實非常單純，他可以在給定的序列範圍中填入一段連續的數字，例如以下的 code\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"for (int i = 1; i <= n; ++i)\\n    a[i] = i;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"用 \", _jsx(_components.code, {\n        children: \"iota\"\n      }), \" 取代的話就是\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"iota(a + 1, a + n + 1, 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"前兩個參數跟一樣是序列的開頭和結尾的後一個位置，最後一個參數則是「連續數字的起始值」，代表這個範圍中藥填入的數字開頭是多少。因此，如果要改填入 \", _jsx(_components.code, {\n        children: \"10\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"n + 9\"\n      }), \" 的話，可以呼叫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"iota(a + 1, a + n + 1, 10);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"來達成。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"自定義比較函式\",\n      children: \"自定義比較函式\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"自定義比較函式-簡介\",\n      children: \"簡介\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"有了上述工具可以用確實很方便，但感覺缺少了一點自由度。舉例來說，如果想用 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 來把數字大到小排序該怎麼辦呢？或甚至複雜一點，如果我們要讓奇數擺前面、偶數擺後面，兩邊再各自比大小怎麼辦呢？又或者我們要排序自定義的 \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \"，C++ 要怎麼在我們沒有告訴他誰要擺前面的情況下知道要怎麼排序呢？\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"C++ 為了應付這種情況，其實大多數的函式他都提供了「自定義比較函式」的功能，我們用排序來當例子白話一點的說，還記得我們在排序時介紹過「 基於比較的排序演算法」這個概念嗎？在大多數的排序問題中，程式其實只需要不斷的詢問「元素 $x$ 和元素 $y$ 誰要擺前面？」就可以排出使用者期望的順序，而這個問題預設的答案就是「$x$ 比 $y$ 小的話，就擺前面」。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"因此，如果要把數字大排到小的話，只需要把問題的答案改成「$x$ 比 $y$ \", _jsx(_components.strong, {\n        children: \"大\"\n      }), \"的話，就擺前面」，這樣就好了！\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"自定義比較函式-實作\",\n      children: \"實作\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"要告訴 C++「誰擺前面」的指示時，使用者需要寫一個 \", _jsx(_components.code, {\n        children: \"bool\"\n      }), \" 函式，支援傳入兩個元素的值 $x$ 和 $y$ 後，回傳 $x$ 是不是\", _jsx(_components.strong, {\n        children: \"一定\"\n      }), \"要在 $y$ 前面。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"大致上會寫出如下的東西，拿大排到小當範例：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"bool cmp(int x, int y) {\\n    return x > y;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"上述這個函式，會在傳入的 \", _jsx(_components.code, {\n        children: \"x\"\n      }), \" 比 \", _jsx(_components.code, {\n        children: \"y\"\n      }), \" 大時回傳 \", _jsx(_components.code, {\n        children: \"true\"\n      }), \"，也就達成了我們前面說的結果，\", _jsx(_components.code, {\n        children: \"x\"\n      }), \" 必須要在 \", _jsx(_components.code, {\n        children: \"y\"\n      }), \" 前面。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"而要呼叫 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 時，排序 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 只需要寫成\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1, cmp);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"也就是在原本呼叫 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 時在後面多加一個參數負責傳入比較函式，就完成大到小排序的操作了！\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"再拿自定義 \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \" 當例子，如果要對自定義的 \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \" 排序時，可以寫成以下樣子：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"struct Data {\\n    int key;\\n    Custom_Type something_else;\\n};\\n\\nbool cmp(Data a, Data b) {\\n    return a.key < b.key;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這樣一樣對型態是 \", _jsx(_components.code, {\n        children: \"Data\"\n      }), \" 的序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 排序時，一樣寫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1, cmp);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以完成排序，是不是很方便呢？\"\n    }), \"\\n\", _jsxs(Info, {\n      type: \"warning\",\n      children: [_jsxs(_components.p, {\n        children: [\"文章內有特別強調函式的作用是「$x$ 是不是\", _jsx(_components.strong, {\n          children: \"一定\"\n        }), \"要在 $y$ 前面」，這個「一定」非常的重要，如果不巧把比較函式寫成\"]\n      }), _jsx(Refcode, {\n        lang: \"cpp\",\n        lineno: \"true\",\n        code: \"bool cmp(int x, int y) {\\n    return x <= y;\\n}\",\n        startFrom: \"1\"\n      }), _jsx(_components.p, {\n        children: \"就會讓 C++ 在兩數相等時，搞不清楚誰要在前面，造成自相矛盾出現不預期的行為。\"\n      }), _jsxs(_components.p, {\n        children: [\"最簡單避免這件事發生的方法，就是多確認一下如果傳入兩個一樣的元素給自己的函式作比較時，函式會回傳 \", _jsx(_components.code, {\n          children: \"false\"\n        }), \"。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"自定義比較函式-延伸\",\n      children: \"延伸\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"自定義比較函式的使用範圍，其實不只有 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 而已，包含前面提到的 \", _jsx(_components.code, {\n        children: \"min\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 其實都適用，可以想成 \", _jsx(_components.code, {\n        children: \"min\"\n      }), \" 就是指要擺在最前面的元素，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 當然就一樣是把第 $k$ 小的基準想成是利用給予的比較函式排序後的第 $k$ 個位置。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"unique\"\n      }), \" 則比較特殊，因為他是要把相鄰一樣的元素過濾掉，所以他的比較函式反而是「詢問兩個元素 $x$ 和 $y$ 是不是一樣？」，這聽起來很奇怪，但其實在一些特殊的狀況下是真的需要自定義的喔！\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"實作上一樣，比較函式只需要擺在最後面當一個額外的參數就可以了。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"再順帶一提，\", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 其實也可以額外傳入自定義函式，但講起來有點複雜，有興趣的讀者可以去他的說明頁面看看。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下提供一些題目讓讀者做函式庫的練習。\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1287\",\n      src: \"TIOJ 1287\",\n      name: \"基礎排序\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/TIOJ/1287/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1287/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=k026\",\n      src: \"ZeroJudge k026\",\n      name: \"中位數\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/ZeroJudge/k026/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/k026/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1621\",\n      src: \"CSES 1621\",\n      name: \"Distinct Numbers\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/CSES/1621/description.mdx\",\n      importMdx: \"guide/problems/CSES/1621/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/2193\",\n      src: \"2021 TOI 入營考 pA\",\n      name: \"原始人排序\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/TOI/2021_pre_A/description.mdx\",\n      importMdx: \"guide/problems/TOI/2021_pre_A/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1617\",\n      src: \"IOI 2000 Day 1\",\n      name: \"中位數\",\n      expanded: \"false\",\n      difficulty: \"4\",\n      descriptionMdx: \"guide/problems/TIOJ/1617/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1617/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1617/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1617/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"小結\",\n      children: \"小結\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"C++ 提供的內建函式可不只以上這些，只是礙於篇幅，我們這裡只特別挑了一些常用的出來講，更有一些函式需要對演算法有一定程度的認識才好使用，讀者若有興趣，可以參考 \", _jsx(_components.a, {\n        href: \"https://cppreference.com/\",\n        children: \"https://cppreference.com/\"\n      }), \" 內 \", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/algorithm\",\n        children: _jsx(_components.code, {\n          children: \"<algorithm>\"\n        })\n      }), \" 和 \", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/numeric\",\n        children: _jsx(_components.code, {\n          children: \"<numeric>\"\n        })\n      }), \" 的章節，搞不好可以找到更多可以讓程式碼更簡潔的工具。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1287/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"輸入一個 $n$ 與 $n$ 個數字，輸出排序後的結果。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"*本題需要輸入到 EOF（檔案結尾，End of File）\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/k026/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"輸入 $n$ 和 $n$ 個數字，輸出這些數字的中位數。若 $n$ 為偶數，需要輸出中間兩個數字的平均值。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1621/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"輸入一個 $n$ 與 $n$ 個數字，輸出這 $n$ 個數字有多少種數字。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TOI/2021_pre_A/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"布朗博士搭乘著時光機器回到了原始人出現的年代，他打算教導原始人現代的資訊技術。首先，布朗博士教原始人們數字的二進位表示法，他由小而大列下了幾個數字：\", _jsx(_components.br, {}), \"\\n\", \"$000, 001, 010, 011, 100, 101, 110, 111$\", _jsx(_components.br, {}), \"\\n\", \"剛列完，原始人的首領就糾正他，說下面的列法才是正確由小到大的順序：\", _jsx(_components.br, {}), \"\\n\", \"$000, 001, 010, 100, 011, 101, 110, 111$\", _jsx(_components.br, {}), \"\\n\", \"爭吵了半天，布朗博士才發現，原來原始人在計數時是用石頭在牆上刻劃一道道的痕跡，每道痕跡 就算計數一次，因此在二進位的表示法下，$1$ 的次數愈多，在原始人心中認定的數值愈大。\", _jsx(_components.br, {}), \"\\n\", \"請你寫一支程式幫助布朗博士，將 $n$ 個十進位表示的數字依原始人認定的順序（即二進位表示法中 $1$ 的個數）由小而大排序；倘若兩數字的二進位表示中 $1$ 的個數相同，則視為相同，依輸入時的順序輸出。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1617/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"本題為互動題\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在你面前有 $n$ 個箱子，編號依序為 $1 \\\\sim n$。每個箱子裡面都有一個數字 $Y_i$，$1 \\\\le Y_i \\\\le n$ 且每個箱子的數字都不重複，換句話說箱子裡的數字，$1 \\\\sim n$ 都會剛好出現一次。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你必須要使用給定的函式 \", _jsx(_components.code, {\n        children: \"Med3(a, b, c)\"\n      }), \" 來求出這些數字的中位數在哪個位置。其中 \", _jsx(_components.code, {\n        children: \"Med3(a, b, c)\"\n      }), \" 會回傳一個數字 $k$ 表示 $Y_a, Y_b, Y_c$ 三個數的中位數是 $Y_k$。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1617/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\le 1499$，而且 $n$ 是奇數\"\n    }), \"\\n\", _jsxs(_components.li, {\n      children: [\"你只能呼叫 \", _jsx(_components.code, {\n        children: \"Med3\"\n      }), \" $7777$ 次\"]\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"prereqs":[{"code":"BasicAlgorithm/sorting","text":"基礎演算法 / 排序演算法"}],"sections":[{"text":"不要造輪子","depth":1,"code":"不要造輪子"},{"text":"<algorithm>","depth":1,"code":"<algorithm>"},{"text":"介紹","depth":2,"code":"<algorithm>-介紹"},{"text":"swap(val1, val2)","depth":2,"code":"<algorithm>-swap(val1, val2)"},{"text":"min(val1, val2)","depth":2,"code":"<algorithm>-min(val1, val2)"},{"text":"min_element(first, last)","depth":2,"code":"<algorithm>-min_element(first, last)"},{"text":"sort(first, last)","depth":2,"code":"<algorithm>-sort(first, last)"},{"text":"nth_element(first, nth_pos, last)","depth":2,"code":"<algorithm>-nth_element(first, nth_pos, last)"},{"text":"unique(first, last)","depth":2,"code":"<algorithm>-unique(first, last)"},{"text":"<numeric>","depth":1,"code":"<numeric>"},{"text":"accumulate(first, last, init_value)","depth":2,"code":"<numeric>-accumulate(first, last, init_value)"},{"text":"iota(first, last, init_value)","depth":2,"code":"<numeric>-iota(first, last, init_value)"},{"text":"自定義比較函式","depth":1,"code":"自定義比較函式"},{"text":"簡介","depth":2,"code":"自定義比較函式-簡介"},{"text":"實作","depth":2,"code":"自定義比較函式-實作"},{"text":"延伸","depth":2,"code":"自定義比較函式-延伸"},{"text":"習題","depth":1,"code":"習題"},{"text":"小結","depth":1,"code":"小結"}],"previousArticle":{"code":"BasicAlgorithm/sorting","topicCode":"BasicAlgorithm","articleCode":"sorting","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 排序演算法","articleDisplayTitle":"排序演算法","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/sorting","topic":"BasicAlgorithm","article":"sorting","title":"排序演算法","authors":["baluteshih"],"contributors":[],"description":"簡單介紹基本的排序演算法（O(n^2), counting sort 跟 radix sort）","prerequisites":["BasicAlgorithm/complexity"]}},"nextArticle":{"code":"BasicAlgorithm/enumerate","topicCode":"BasicAlgorithm","articleCode":"enumerate","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 枚舉","articleDisplayTitle":"枚舉","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/enumerate","topic":"BasicAlgorithm","article":"enumerate","title":"枚舉","authors":["WiwiHo"],"contributors":[],"description":"簡單的枚舉技巧，不包含遞迴","prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"]}},"virtualArticle":{"code":"BasicAlgorithm/algorithm_numeric","topicCode":"BasicAlgorithm","articleCode":"algorithm_numeric","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 標準函式庫 ── <algorithm> 與 <numeric>","articleDisplayTitle":"標準函式庫 ── <algorithm> 與 <numeric>","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/algorithm_numeric","topic":"BasicAlgorithm","article":"algorithm_numeric","title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"description":"介紹 STL <algorithm> 和 <numeric> 裡的幾個常用函式","prerequisites":["BasicAlgorithm/sorting"]}},"topicStructure":[{"single":true,"title":"","topics":[{"code":"Guide","displayTitle":"網站簡介","articles":[{"code":"Guide/learning","topicCode":"Guide","articleCode":"learning","chapterCode":"I","fullDisplayTitle":"網站簡介 / 服用方法","articleDisplayTitle":"服用方法","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/learning","topic":"Guide","article":"learning","title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"description":"教大家怎麼看這份講義","prerequisites":[]}},{"code":"Guide/chapters","topicCode":"Guide","articleCode":"chapters","chapterCode":"I","fullDisplayTitle":"網站簡介 / 章節與主題","articleDisplayTitle":"章節與主題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/chapters","topic":"Guide","article":"chapters","title":"章節與主題","authors":["baluteshih"],"contributors":[],"description":"教大家什麼是章節與主題","prerequisites":["Guide/learning"]}},{"code":"Guide/problems","topicCode":"Guide","articleCode":"problems","chapterCode":"I","fullDisplayTitle":"網站簡介 / 習題","articleDisplayTitle":"習題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/problems","topic":"Guide","article":"problems","title":"習題","authors":["baluteshih"],"contributors":[],"description":"教大家這份講義的習題意義","prerequisites":["Guide/learning"]}},{"code":"Guide/math_symbol","topicCode":"Guide","articleCode":"math_symbol","chapterCode":"I","fullDisplayTitle":"網站簡介 / 基本數學符號","articleDisplayTitle":"基本數學符號","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/math_symbol","topic":"Guide","article":"math_symbol","title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"description":"介紹常見的數學符號","prerequisites":[]}},{"code":"Guide/language","topicCode":"Guide","articleCode":"language","chapterCode":"I","fullDisplayTitle":"網站簡介 / 語法學習資源","articleDisplayTitle":"語法學習資源","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/language","topic":"Guide","article":"language","title":"語法學習資源","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Guide/qa","topicCode":"Guide","articleCode":"qa","chapterCode":"I","fullDisplayTitle":"網站簡介 / NTUCPC Guide Q & A","articleDisplayTitle":"NTUCPC Guide Q & A","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/qa","topic":"Guide","article":"qa","title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":[]}}]}]},{"single":true,"title":"","topics":[{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/competitive_programming","topicCode":"Introduction","articleCode":"competitive_programming","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 資訊競賽介紹","articleDisplayTitle":"資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/competitive_programming","topic":"Introduction","article":"competitive_programming","title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Introduction/contests_type","topicCode":"Introduction","articleCode":"contests_type","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 比賽類型","articleDisplayTitle":"比賽類型","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/contests_type","topic":"Introduction","article":"contests_type","title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tw_contests","topicCode":"Introduction","articleCode":"tw_contests","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 台灣資訊競賽介紹","articleDisplayTitle":"台灣資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/tw_contests","topic":"Introduction","article":"tw_contests","title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}},{"code":"Introduction/online_judge","topicCode":"Introduction","articleCode":"online_judge","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 線上評測系統","articleDisplayTitle":"線上評測系統","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/online_judge","topic":"Introduction","article":"online_judge","title":"線上評測系統","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/resources","topicCode":"Introduction","articleCode":"resources","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 網路學習資源介紹","articleDisplayTitle":"網路學習資源介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/resources","topic":"Introduction","article":"resources","title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tactics","topicCode":"Introduction","articleCode":"tactics","chapterCode":"III","fullDisplayTitle":"資訊競賽介紹 / 比賽 + 練習策略","articleDisplayTitle":"比賽 + 練習策略","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"Introduction/tactics","topic":"Introduction","article":"tactics","title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}}]}]},{"single":true,"title":"","topics":[{"code":"Implementation","displayTitle":"實作技巧","articles":[{"code":"Implementation/basic_knowledge","topicCode":"Implementation","articleCode":"basic_knowledge","chapterCode":"II","fullDisplayTitle":"實作技巧 / 基本常識","articleDisplayTitle":"基本常識","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/basic_knowledge","topic":"Implementation","article":"basic_knowledge","title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"description":"講述一些競賽程式需要知道的最基本常識","prerequisites":["Introduction/online_judge"]}},{"code":"Implementation/input","topicCode":"Implementation","articleCode":"input","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見輸入類型","articleDisplayTitle":"常見輸入類型","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/input","topic":"Implementation","article":"input","title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的輸入格式","prerequisites":["Implementation/basic_knowledge"]}},{"code":"Implementation/reference","topicCode":"Implementation","articleCode":"reference","chapterCode":"II","fullDisplayTitle":"實作技巧 / Reference","articleDisplayTitle":"Reference","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/reference","topic":"Implementation","article":"reference","title":"Reference","authors":["baluteshih"],"contributors":[],"description":"Reference","prerequisites":[]}},{"code":"Implementation/compiler","topicCode":"Implementation","articleCode":"compiler","chapterCode":"II","fullDisplayTitle":"實作技巧 / 編譯器","articleDisplayTitle":"編譯器","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/compiler","topic":"Implementation","article":"compiler","title":"編譯器","authors":["WiwiHo"],"contributors":[],"description":"簡單介紹什麼是編譯器","prerequisites":[]}},{"code":"Implementation/error_message","topicCode":"Implementation","articleCode":"error_message","chapterCode":"II","fullDisplayTitle":"實作技巧 / 如何看錯誤訊息","articleDisplayTitle":"如何看錯誤訊息","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/error_message","topic":"Implementation","article":"error_message","title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"description":"介紹一些常見錯誤訊息的看法","prerequisites":["Implementation/compiler"]}},{"code":"Implementation/variable","topicCode":"Implementation","articleCode":"variable","chapterCode":"II","fullDisplayTitle":"實作技巧 / 全域、區域變數","articleDisplayTitle":"全域、區域變數","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/variable","topic":"Implementation","article":"variable","title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"description":"各種全域區域變數相關的事情","prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"]}},{"code":"Implementation/buglist","topicCode":"Implementation","articleCode":"buglist","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見錯誤列表","articleDisplayTitle":"常見錯誤列表","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/buglist","topic":"Implementation","article":"buglist","title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的錯誤","prerequisites":["Implementation/variable"]}},{"code":"Implementation/debug","topicCode":"Implementation","articleCode":"debug","chapterCode":null,"fullDisplayTitle":"實作技巧 / Debug","articleDisplayTitle":"Debug","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter ???","article":{"code":"Implementation/debug","topic":"Implementation","article":"debug","title":"Debug","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Implementation/buglist"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/intro","topicCode":"BasicAlgorithm","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/intro","topic":"BasicAlgorithm","article":"intro","title":"介紹","authors":["double"],"contributors":[],"description":"簡單介紹何謂演算法","prerequisites":["Introduction/competitive_programming"]}},{"code":"BasicAlgorithm/complexity","topicCode":"BasicAlgorithm","articleCode":"complexity","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 複雜度","articleDisplayTitle":"複雜度","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/complexity","topic":"BasicAlgorithm","article":"complexity","title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/sorting","topicCode":"BasicAlgorithm","articleCode":"sorting","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 排序演算法","articleDisplayTitle":"排序演算法","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/sorting","topic":"BasicAlgorithm","article":"sorting","title":"排序演算法","authors":["baluteshih"],"contributors":[],"description":"簡單介紹基本的排序演算法（O(n^2), counting sort 跟 radix sort）","prerequisites":["BasicAlgorithm/complexity"]}},{"code":"BasicAlgorithm/algorithm_numeric","topicCode":"BasicAlgorithm","articleCode":"algorithm_numeric","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 標準函式庫 ── <algorithm> 與 <numeric>","articleDisplayTitle":"標準函式庫 ── <algorithm> 與 <numeric>","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/algorithm_numeric","topic":"BasicAlgorithm","article":"algorithm_numeric","title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"description":"介紹 STL <algorithm> 和 <numeric> 裡的幾個常用函式","prerequisites":["BasicAlgorithm/sorting"]}},{"code":"BasicAlgorithm/enumerate","topicCode":"BasicAlgorithm","articleCode":"enumerate","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 枚舉","articleDisplayTitle":"枚舉","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/enumerate","topic":"BasicAlgorithm","article":"enumerate","title":"枚舉","authors":["WiwiHo"],"contributors":[],"description":"簡單的枚舉技巧，不包含遞迴","prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/searching","topicCode":"BasicAlgorithm","articleCode":"searching","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 搜尋","articleDisplayTitle":"搜尋","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/searching","topic":"BasicAlgorithm","article":"searching","title":"搜尋","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/math_in_school","topicCode":"BasicAlgorithm","articleCode":"math_in_school","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 學校教的數學","articleDisplayTitle":"學校教的數學","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/math_in_school","topic":"BasicAlgorithm","article":"math_in_school","title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"description":"一些和基礎演算法設計技巧有關的課綱內數學問題，引導讀者從基礎數學發現演算法，並且訓練把人腦作法轉換成演算法的能力。","prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/recursion","topicCode":"BasicAlgorithm","articleCode":"recursion","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 遞迴","articleDisplayTitle":"遞迴","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/recursion","topic":"BasicAlgorithm","article":"recursion","title":"遞迴","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/partial_sum","topicCode":"BasicAlgorithm","articleCode":"partial_sum","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 前綴和與差分","articleDisplayTitle":"前綴和與差分","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/partial_sum","topic":"BasicAlgorithm","article":"partial_sum","title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/two_pointers","topicCode":"BasicAlgorithm","articleCode":"two_pointers","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 雙指標","articleDisplayTitle":"雙指標","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/two_pointers","topic":"BasicAlgorithm","article":"two_pointers","title":"雙指標","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/binary_search_answer","topicCode":"BasicAlgorithm","articleCode":"binary_search_answer","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 對答案二分搜","articleDisplayTitle":"對答案二分搜","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/binary_search_answer","topic":"BasicAlgorithm","article":"binary_search_answer","title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"description":"","prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"]}}]}]},{"single":true,"title":"","topics":[{"code":"GreedyAlgorithm","displayTitle":"貪心演算法","articles":[{"code":"GreedyAlgorithm/intuitive_greedy","topicCode":"GreedyAlgorithm","articleCode":"intuitive_greedy","chapterCode":"II","fullDisplayTitle":"貪心演算法 / 貪心法 I","articleDisplayTitle":"貪心法 I","topicDisplayTitle":"貪心演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"GreedyAlgorithm/intuitive_greedy","topic":"GreedyAlgorithm","article":"intuitive_greedy","title":"貪心法 I","authors":["baluteshih"],"contributors":[],"description":"生活中直覺的貪心題目","prerequisites":["BasicAlgorithm/algorithm_numeric"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/intro","topicCode":"BasicDataStructure","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/intro","topic":"BasicDataStructure","article":"intro","title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"description":"簡單介紹資料結構的概念","prerequisites":["Implementation/basic_knowledge"]}},{"code":"BasicDataStructure/vector","topicCode":"BasicDataStructure","articleCode":"vector","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 動態的陣列","articleDisplayTitle":"動態的陣列","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/vector","topic":"BasicDataStructure","article":"vector","title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicDataStructure/stack_queue_deque","topicCode":"BasicDataStructure","articleCode":"stack_queue_deque","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Stack、Queue 與 Deque","articleDisplayTitle":"Stack、Queue 與 Deque","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/stack_queue_deque","topic":"BasicDataStructure","article":"stack_queue_deque","title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/linked_list","topicCode":"BasicDataStructure","articleCode":"linked_list","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Linked List","articleDisplayTitle":"Linked List","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/linked_list","topic":"BasicDataStructure","article":"linked_list","title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/binary_tree","topicCode":"BasicDataStructure","articleCode":"binary_tree","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / 二元樹","articleDisplayTitle":"二元樹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/binary_tree","topic":"BasicDataStructure","article":"binary_tree","title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/linked_list","Implementation/reference"]}},{"code":"BasicDataStructure/heap","topicCode":"BasicDataStructure","articleCode":"heap","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Heap","articleDisplayTitle":"Heap","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/heap","topic":"BasicDataStructure","article":"heap","title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}},{"code":"BasicDataStructure/set_map","topicCode":"BasicDataStructure","articleCode":"set_map","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Set 與 Map","articleDisplayTitle":"Set 與 Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/set_map","topic":"BasicDataStructure","article":"set_map","title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/heap"]}},{"code":"BasicDataStructure/unordered","topicCode":"BasicDataStructure","articleCode":"unordered","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Unordered Set 與 Unordered Map","articleDisplayTitle":"Unordered Set 與 Unordered Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/unordered","topic":"BasicDataStructure","article":"unordered","title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/set_map"]}},{"code":"BasicDataStructure/iterator","topicCode":"BasicDataStructure","articleCode":"iterator","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Iterator","articleDisplayTitle":"Iterator","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/iterator","topic":"BasicDataStructure","article":"iterator","title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/intro"]}},{"code":"BasicDataStructure/binary_tree_and_stack","topicCode":"BasicDataStructure","articleCode":"binary_tree_and_stack","chapterCode":null,"fullDisplayTitle":"基礎資料結構 / 二元樹與 Stack","articleDisplayTitle":"二元樹與 Stack","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter ???","article":{"code":"BasicDataStructure/binary_tree_and_stack","topic":"BasicDataStructure","article":"binary_tree_and_stack","title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicMath","displayTitle":"基礎數學","articles":[{"code":"BasicMath/basicalgo","topicCode":"BasicMath","articleCode":"basicalgo","chapterCode":"III","fullDisplayTitle":"基礎數學 / 常用數學演算法","articleDisplayTitle":"常用數學演算法","topicDisplayTitle":"基礎數學","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicMath/basicalgo","topic":"BasicMath","article":"basicalgo","title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"description":"一些不太難的數學","prerequisites":["BasicAlgorithm/math_in_school"]}}]}]}],"chapterStructure":[{"code":"I","displayTitle":"Chapter I. 初來乍到","topics":[{"code":"Guide","displayTitle":"網站簡介","articles":[{"code":"Guide/learning","topicCode":"Guide","articleCode":"learning","chapterCode":"I","fullDisplayTitle":"網站簡介 / 服用方法","articleDisplayTitle":"服用方法","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/learning","topic":"Guide","article":"learning","title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"description":"教大家怎麼看這份講義","prerequisites":[]}},{"code":"Guide/chapters","topicCode":"Guide","articleCode":"chapters","chapterCode":"I","fullDisplayTitle":"網站簡介 / 章節與主題","articleDisplayTitle":"章節與主題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/chapters","topic":"Guide","article":"chapters","title":"章節與主題","authors":["baluteshih"],"contributors":[],"description":"教大家什麼是章節與主題","prerequisites":["Guide/learning"]}},{"code":"Guide/problems","topicCode":"Guide","articleCode":"problems","chapterCode":"I","fullDisplayTitle":"網站簡介 / 習題","articleDisplayTitle":"習題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/problems","topic":"Guide","article":"problems","title":"習題","authors":["baluteshih"],"contributors":[],"description":"教大家這份講義的習題意義","prerequisites":["Guide/learning"]}},{"code":"Guide/math_symbol","topicCode":"Guide","articleCode":"math_symbol","chapterCode":"I","fullDisplayTitle":"網站簡介 / 基本數學符號","articleDisplayTitle":"基本數學符號","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/math_symbol","topic":"Guide","article":"math_symbol","title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"description":"介紹常見的數學符號","prerequisites":[]}},{"code":"Guide/language","topicCode":"Guide","articleCode":"language","chapterCode":"I","fullDisplayTitle":"網站簡介 / 語法學習資源","articleDisplayTitle":"語法學習資源","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/language","topic":"Guide","article":"language","title":"語法學習資源","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Guide/qa","topicCode":"Guide","articleCode":"qa","chapterCode":"I","fullDisplayTitle":"網站簡介 / NTUCPC Guide Q & A","articleDisplayTitle":"NTUCPC Guide Q & A","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/qa","topic":"Guide","article":"qa","title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":[]}}]},{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/competitive_programming","topicCode":"Introduction","articleCode":"competitive_programming","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 資訊競賽介紹","articleDisplayTitle":"資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/competitive_programming","topic":"Introduction","article":"competitive_programming","title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Introduction/contests_type","topicCode":"Introduction","articleCode":"contests_type","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 比賽類型","articleDisplayTitle":"比賽類型","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/contests_type","topic":"Introduction","article":"contests_type","title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tw_contests","topicCode":"Introduction","articleCode":"tw_contests","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 台灣資訊競賽介紹","articleDisplayTitle":"台灣資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/tw_contests","topic":"Introduction","article":"tw_contests","title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}},{"code":"Introduction/online_judge","topicCode":"Introduction","articleCode":"online_judge","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 線上評測系統","articleDisplayTitle":"線上評測系統","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/online_judge","topic":"Introduction","article":"online_judge","title":"線上評測系統","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/resources","topicCode":"Introduction","articleCode":"resources","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 網路學習資源介紹","articleDisplayTitle":"網路學習資源介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/resources","topic":"Introduction","article":"resources","title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}}]}]},{"code":"II","displayTitle":"Chapter II. 新手上路","topics":[{"code":"Implementation","displayTitle":"實作技巧","articles":[{"code":"Implementation/basic_knowledge","topicCode":"Implementation","articleCode":"basic_knowledge","chapterCode":"II","fullDisplayTitle":"實作技巧 / 基本常識","articleDisplayTitle":"基本常識","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/basic_knowledge","topic":"Implementation","article":"basic_knowledge","title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"description":"講述一些競賽程式需要知道的最基本常識","prerequisites":["Introduction/online_judge"]}},{"code":"Implementation/input","topicCode":"Implementation","articleCode":"input","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見輸入類型","articleDisplayTitle":"常見輸入類型","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/input","topic":"Implementation","article":"input","title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的輸入格式","prerequisites":["Implementation/basic_knowledge"]}},{"code":"Implementation/reference","topicCode":"Implementation","articleCode":"reference","chapterCode":"II","fullDisplayTitle":"實作技巧 / Reference","articleDisplayTitle":"Reference","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/reference","topic":"Implementation","article":"reference","title":"Reference","authors":["baluteshih"],"contributors":[],"description":"Reference","prerequisites":[]}},{"code":"Implementation/compiler","topicCode":"Implementation","articleCode":"compiler","chapterCode":"II","fullDisplayTitle":"實作技巧 / 編譯器","articleDisplayTitle":"編譯器","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/compiler","topic":"Implementation","article":"compiler","title":"編譯器","authors":["WiwiHo"],"contributors":[],"description":"簡單介紹什麼是編譯器","prerequisites":[]}},{"code":"Implementation/error_message","topicCode":"Implementation","articleCode":"error_message","chapterCode":"II","fullDisplayTitle":"實作技巧 / 如何看錯誤訊息","articleDisplayTitle":"如何看錯誤訊息","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/error_message","topic":"Implementation","article":"error_message","title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"description":"介紹一些常見錯誤訊息的看法","prerequisites":["Implementation/compiler"]}},{"code":"Implementation/variable","topicCode":"Implementation","articleCode":"variable","chapterCode":"II","fullDisplayTitle":"實作技巧 / 全域、區域變數","articleDisplayTitle":"全域、區域變數","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/variable","topic":"Implementation","article":"variable","title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"description":"各種全域區域變數相關的事情","prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"]}},{"code":"Implementation/buglist","topicCode":"Implementation","articleCode":"buglist","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見錯誤列表","articleDisplayTitle":"常見錯誤列表","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/buglist","topic":"Implementation","article":"buglist","title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的錯誤","prerequisites":["Implementation/variable"]}}]},{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/intro","topicCode":"BasicAlgorithm","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/intro","topic":"BasicAlgorithm","article":"intro","title":"介紹","authors":["double"],"contributors":[],"description":"簡單介紹何謂演算法","prerequisites":["Introduction/competitive_programming"]}},{"code":"BasicAlgorithm/complexity","topicCode":"BasicAlgorithm","articleCode":"complexity","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 複雜度","articleDisplayTitle":"複雜度","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/complexity","topic":"BasicAlgorithm","article":"complexity","title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/sorting","topicCode":"BasicAlgorithm","articleCode":"sorting","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 排序演算法","articleDisplayTitle":"排序演算法","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/sorting","topic":"BasicAlgorithm","article":"sorting","title":"排序演算法","authors":["baluteshih"],"contributors":[],"description":"簡單介紹基本的排序演算法（O(n^2), counting sort 跟 radix sort）","prerequisites":["BasicAlgorithm/complexity"]}},{"code":"BasicAlgorithm/algorithm_numeric","topicCode":"BasicAlgorithm","articleCode":"algorithm_numeric","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 標準函式庫 ── <algorithm> 與 <numeric>","articleDisplayTitle":"標準函式庫 ── <algorithm> 與 <numeric>","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/algorithm_numeric","topic":"BasicAlgorithm","article":"algorithm_numeric","title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"description":"介紹 STL <algorithm> 和 <numeric> 裡的幾個常用函式","prerequisites":["BasicAlgorithm/sorting"]}},{"code":"BasicAlgorithm/enumerate","topicCode":"BasicAlgorithm","articleCode":"enumerate","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 枚舉","articleDisplayTitle":"枚舉","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/enumerate","topic":"BasicAlgorithm","article":"enumerate","title":"枚舉","authors":["WiwiHo"],"contributors":[],"description":"簡單的枚舉技巧，不包含遞迴","prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/searching","topicCode":"BasicAlgorithm","articleCode":"searching","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 搜尋","articleDisplayTitle":"搜尋","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/searching","topic":"BasicAlgorithm","article":"searching","title":"搜尋","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/math_in_school","topicCode":"BasicAlgorithm","articleCode":"math_in_school","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 學校教的數學","articleDisplayTitle":"學校教的數學","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/math_in_school","topic":"BasicAlgorithm","article":"math_in_school","title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"description":"一些和基礎演算法設計技巧有關的課綱內數學問題，引導讀者從基礎數學發現演算法，並且訓練把人腦作法轉換成演算法的能力。","prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"]}}]},{"code":"GreedyAlgorithm","displayTitle":"貪心演算法","articles":[{"code":"GreedyAlgorithm/intuitive_greedy","topicCode":"GreedyAlgorithm","articleCode":"intuitive_greedy","chapterCode":"II","fullDisplayTitle":"貪心演算法 / 貪心法 I","articleDisplayTitle":"貪心法 I","topicDisplayTitle":"貪心演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"GreedyAlgorithm/intuitive_greedy","topic":"GreedyAlgorithm","article":"intuitive_greedy","title":"貪心法 I","authors":["baluteshih"],"contributors":[],"description":"生活中直覺的貪心題目","prerequisites":["BasicAlgorithm/algorithm_numeric"]}}]},{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/intro","topicCode":"BasicDataStructure","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/intro","topic":"BasicDataStructure","article":"intro","title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"description":"簡單介紹資料結構的概念","prerequisites":["Implementation/basic_knowledge"]}},{"code":"BasicDataStructure/vector","topicCode":"BasicDataStructure","articleCode":"vector","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 動態的陣列","articleDisplayTitle":"動態的陣列","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/vector","topic":"BasicDataStructure","article":"vector","title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicDataStructure/stack_queue_deque","topicCode":"BasicDataStructure","articleCode":"stack_queue_deque","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Stack、Queue 與 Deque","articleDisplayTitle":"Stack、Queue 與 Deque","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/stack_queue_deque","topic":"BasicDataStructure","article":"stack_queue_deque","title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/linked_list","topicCode":"BasicDataStructure","articleCode":"linked_list","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Linked List","articleDisplayTitle":"Linked List","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/linked_list","topic":"BasicDataStructure","article":"linked_list","title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}}]}]},{"code":"III","displayTitle":"Chapter III. 漸入佳境","topics":[{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/tactics","topicCode":"Introduction","articleCode":"tactics","chapterCode":"III","fullDisplayTitle":"資訊競賽介紹 / 比賽 + 練習策略","articleDisplayTitle":"比賽 + 練習策略","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"Introduction/tactics","topic":"Introduction","article":"tactics","title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}}]},{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/recursion","topicCode":"BasicAlgorithm","articleCode":"recursion","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 遞迴","articleDisplayTitle":"遞迴","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/recursion","topic":"BasicAlgorithm","article":"recursion","title":"遞迴","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/partial_sum","topicCode":"BasicAlgorithm","articleCode":"partial_sum","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 前綴和與差分","articleDisplayTitle":"前綴和與差分","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/partial_sum","topic":"BasicAlgorithm","article":"partial_sum","title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/two_pointers","topicCode":"BasicAlgorithm","articleCode":"two_pointers","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 雙指標","articleDisplayTitle":"雙指標","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/two_pointers","topic":"BasicAlgorithm","article":"two_pointers","title":"雙指標","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/binary_search_answer","topicCode":"BasicAlgorithm","articleCode":"binary_search_answer","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 對答案二分搜","articleDisplayTitle":"對答案二分搜","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/binary_search_answer","topic":"BasicAlgorithm","article":"binary_search_answer","title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"description":"","prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"]}}]},{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/binary_tree","topicCode":"BasicDataStructure","articleCode":"binary_tree","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / 二元樹","articleDisplayTitle":"二元樹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/binary_tree","topic":"BasicDataStructure","article":"binary_tree","title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/linked_list","Implementation/reference"]}},{"code":"BasicDataStructure/heap","topicCode":"BasicDataStructure","articleCode":"heap","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Heap","articleDisplayTitle":"Heap","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/heap","topic":"BasicDataStructure","article":"heap","title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}},{"code":"BasicDataStructure/set_map","topicCode":"BasicDataStructure","articleCode":"set_map","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Set 與 Map","articleDisplayTitle":"Set 與 Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/set_map","topic":"BasicDataStructure","article":"set_map","title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/heap"]}},{"code":"BasicDataStructure/unordered","topicCode":"BasicDataStructure","articleCode":"unordered","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Unordered Set 與 Unordered Map","articleDisplayTitle":"Unordered Set 與 Unordered Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/unordered","topic":"BasicDataStructure","article":"unordered","title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/set_map"]}},{"code":"BasicDataStructure/iterator","topicCode":"BasicDataStructure","articleCode":"iterator","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Iterator","articleDisplayTitle":"Iterator","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/iterator","topic":"BasicDataStructure","article":"iterator","title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/intro"]}}]},{"code":"BasicMath","displayTitle":"基礎數學","articles":[{"code":"BasicMath/basicalgo","topicCode":"BasicMath","articleCode":"basicalgo","chapterCode":"III","fullDisplayTitle":"基礎數學 / 常用數學演算法","articleDisplayTitle":"常用數學演算法","topicDisplayTitle":"基礎數學","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicMath/basicalgo","topic":"BasicMath","article":"basicalgo","title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"description":"一些不太難的數學","prerequisites":["BasicAlgorithm/math_in_school"]}}]}]}]}},"__N_SSG":true}