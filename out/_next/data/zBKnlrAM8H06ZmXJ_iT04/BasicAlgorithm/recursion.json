{"pageProps":{"props":{"mdxPath":"guide/content/BasicAlgorithm/recursion/recursion.mdx","code":"BasicAlgorithm/recursion","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"廣度優先搜尋","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"分治法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"深度優先搜尋","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","Implementation/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":true},{"code":"BasicDynamicProgramming/knapsack_and_rolling","article":"knapsack_and_rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":false,"title":"背包問題與滾動 DP","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":true},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":true},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":true},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","Implementation/buglist"],"coming":true},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":false,"title":"二分圖","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":false,"title":"圖論導論","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":false,"title":"單調隊列","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 III","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 II","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/basic_knowledge","article":"basic_knowledge","topic":"Implementation","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"Implementation/buglist","article":"buglist","topic":"Implementation","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/variable"],"coming":false},{"code":"Implementation/compiler","article":"compiler","topic":"Implementation","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/debug","article":"debug","topic":"Implementation","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["Implementation/buglist"],"coming":false},{"code":"Implementation/error_message","article":"error_message","topic":"Implementation","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/compiler"],"coming":false},{"code":"Implementation/float_error","article":"float_error","topic":"Implementation","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/input","article":"input","topic":"Implementation","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"Implementation/pseudo_pointer","article":"pseudo_pointer","topic":"Implementation","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/reference","article":"reference","topic":"Implementation","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/rngbased","article":"rngbased","topic":"Implementation","chapter":"III","valid":false,"title":"Range-Based for loop","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/structure_binding","article":"structure_binding","topic":"Implementation","chapter":"III","valid":false,"title":"Structure Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/variable","article":"variable","topic":"Implementation","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"],"coming":false},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"Implementation","title":"實作技巧","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","Implementation/debug","Implementation/rngbased","Implementation/structure_binding","Implementation/float_error","Implementation/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack_and_rolling"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["Implementation"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","Implementation/rngbased","Implementation/structure_binding","Implementation/float_error","Implementation/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack_and_rolling","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/BasicAlgorithm/recursion/recursion.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Figure, Problem, Refcode, Theorem} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  if (!Theorem) _missingMdxReference(\"Theorem\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"定義\",\n      children: \"定義\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"遞迴從程式的角度來解釋，指的是一個函式在執行過程中會呼叫自己，使得函式中的程式碼會被反覆執行。直到達成某個條件後，這個函式才會停止呼叫自己，並完成執行後回傳，從而結束遞迴的過程。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"簡單舉一個例子，想像一下在走迷宮時，我們會不斷遇到路口，如果我們想要用程式來程式來走迷宮，我們便會寫一個函式來處理遇到路口時該做什麼行動。在這個函式中，我們會分別嘗試左轉、直走、或右轉並遇到下一個路口，然後再做一次遇到路口後的行動。這一系列的行為會一直持續下去，直到我們達成了「走到終點」這個條件才會停止。試著將這段口語敘述轉換成程式碼後，看起來會是這樣：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void intersection() {\\n    if (arrive_exit) {\\n        win();\\n        return;\\n    }\\n    if (left_enable) {\\n        turn_left();\\n        intersection();\\n    }\\n    if (right_enable) {\\n        turn_right();\\n        intersection();\\n    }\\n    if (forward_enable) {\\n        move_forward();\\n        intersection();\\n    }\\n    return;\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"遞迴函式通常會在我們需要解決具有多個層次的問題時被使用。在迷宮這個例子中，每個十字路口都是一層問題，當我們選擇往一個方向走後，便會遇到下一個十字路口，也就是下一層問題。由於我們一開始不知道走完迷宮總共需要解決幾層十字路口的問題，這時候就會使用遞迴這個技巧。我們可以使用一個遞迴函式來解決一層十字路口的問題，而這個遞迴函式遇到下一個十字路口，也就是下一層問題時，就會再呼叫一次自己這個函式，來解決新的一層問題。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外，在這個遞迴函式中我們也可以發現，如果到了一個十字路口時，它的左邊、前方、右邊都沒有路，也就是到了一個死路後，函式便會停止前往新的十字路口，並回到上一個十字路口。這就是遞迴中最重要的概念，「遞迴終止條件」。遞迴終止條件往往是我們在寫遞迴時第一件要考慮的事情，一來它能夠避免遞迴函式不知道要停下來而一直遞迴下去，形成無窮遞迴。二來這個條件也能幫助我們思考遞迴函式解決問題的條件，詳細考慮什麼情況才算是完成遞迴，能夠更好理解題目。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在撰寫遞迴函式時，有一個要點是，只需要考慮在解決這一層問題時需要注意的事就好，不要試圖連下一層的情況也考慮進去，否則你會讓你的腦袋跑進一個無窮遞迴。當我們遇到需要進入下一層問題的情況時，直接把自己這個遞迴函式放上去就行。寫遞迴函式時要\", _jsx(_components.strong, {\n        children: \"一邊假裝這個函式已經寫好，一邊完成這個函式的實作\"\n      }), \"。就像在迷宮的例子中，我們假裝 \", _jsx(_components.code, {\n        children: \"intersection\"\n      }), \" 已經寫好了，這樣左轉、直走、或右轉後遇到新的十字路口，我們就可以直接用已經「寫好」的 \", _jsx(_components.code, {\n        children: \"intersection\"\n      }), \" 解決了。\"]\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"tips\",\n      title: \"思考遞迴的技巧\",\n      number: \"1\",\n      children: [_jsx(_components.p, {\n        children: \"要記住遞迴最重要的兩個重點！\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"遞迴終止條件：記得寫下所有遞迴終止條件，避免出現無窮遞迴，也幫助自己了解題目\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"撰寫遞迴函式：遇到要往下遞迴的地方時，不要去煩惱遞迴下去會發生什麼事，只要先假裝自己的遞迴函式已經寫好就行了\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"應用\",\n      children: \"應用\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然我們提到了遞迴通常是用來處理有多個層次的問題，那麼具體而言會像是怎麼樣的題目呢，就讓我們來看一些例子吧：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://leetcode.com/problems/fibonacci-number/\",\n      src: \"LeetCode 509\",\n      name: \"Fibonacci Number\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/LeetCode/fibonacci-number/description.mdx\",\n      constraintsMdx: \"guide/problems/LeetCode/fibonacci-number/constraints.mdx\",\n      importMdx: \"guide/problems/LeetCode/fibonacci-number/description.mdx\",\n      importMdx: \"guide/problems/LeetCode/fibonacci-number/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"從上述關係式可以知道，要求出費波那契數列的第 $n$ 項 $F(n)$，就必須求出 $F(n-1), F(n-2)$，而要求出 $F(n-1)$，我們就會需要知道 $F(n-2), F(n-3)$，一路求到 $F(0), F(1)$為止。因此，我們可以把費波那契數列的每一項都看成一層問題，再利用遞迴來解決每一層問題。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"來考慮一下前面提到的兩個重點：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"遞迴終止條件：對於 $F(n)$ 的計算，只要計算完 $F(n-1)$，$F(n-2)$ 就可完成遞迴並回傳。除此之外 $n = 0$ 和 $n = 1$ 會有比較特別的終止條件，因為他們的數值是在最初被規定好的，所以直接回傳就好了。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"撰寫遞迴函式：我們假裝遞迴函式已經寫好，就可以簡單把函式計算 $F(n)$ 的步驟直接寫成 $F(n-1) + F(n-2)$ 了！\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int fib(int n) {\\n    if (n == 0) return 0;\\n    if (n == 1) return 1;\\n    return fib(n - 1) + fib(n - 2);\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1355\",\n      src: \"TIOJ 1355\",\n      name: \"河內塔\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/TIOJ/1355/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1355/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1355/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1355/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們先來簡單了解一下河內塔的遊戲策略，首先，遊戲一開始的第一個目標，便是想辦法把最大的盤子從最左邊移動到最右邊。而要能夠完成這個目標，我們必須把最小的盤子到第二大的盤子都搬到中間。同樣的，要達成這個目標，我們要能夠把第二大的盤子放到中間，在那之前，要先把最小的盤子到第三大的盤子移動到右邊。降到這邊，相信大家已經看出來題目所具有的層次性了。我們可以將「把最小的盤子道第 $n$ 個盤子從 $a$ 柱子移動到 $b$ 柱子」看成一層問題，並用遞迴來解決這個問題。在撰寫程式的時候後，我們同樣要注意兩個技巧：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"遞迴終止條件：為了移動大盤子，我們會需要去遞迴移動小盤子。顯而易見地，我們會在移動最小的盤子時結束遞迴。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"撰寫遞迴函式：假裝移動「小」河內塔的函式已經寫好，那我們移動「大」河內塔的步驟便是：移動「小」河內塔到空的臨時柱子 $\\\\rightarrow$ 把「大」盤子移動到目標柱子 $\\\\rightarrow$ 移動「小」河內塔到目標柱子、也是「大」盤子上面。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicAlgorithm/recursion/figure/hanoi.png\",\n      width: \"250\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void move(int a, int b) {\\n    static int steps = 0;\\n    ++steps;\\n    cout << \\\"#\\\" << steps << \\\" : move the dish from #\\\" << a << \\\" to #\\\" << b << \\\"\\\\n\\\";\\n}\\nvoid hanoi(int n, int a, int b, int c) { // 將前 n 個盤子從 a 移動到 b，c 是無關的那跟柱子\\n    if (n == 1) {\\n        move(a, b);\\n        return; \\n    }\\n    hanoi(n - 1, a, c, b);\\n    move(a, b);\\n    hanoi(n - 1, c, b, a);\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"剪枝\",\n      children: \"剪枝\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最後，我們要提到遞迴的一個技巧是剪枝。大家還記得遞迴一定要設定終止條件，以免陷入無窮迴圈。而終止條件通常會被設定成問題被解決時的條件，不過，其實我們也能在確定問題不能以目前的方向解決時就結束遞迴。舉例而言，如果我們在走迷宮被工作人員告知「這個方向是死路」，那麼我們便不會在前方的十字路口做選擇，而是直接回頭，以免浪費時間。在一些遞迴的題目中，我們也會利用類似的技巧來減少執行的時間，這便是所謂的剪枝。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下來，我們再透過一個經典例子來加深理解吧：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=i644\",\n      src: \"ZeroJudge i644\",\n      name: \"列舉八皇后問題所有解\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/ZeroJudge/i644/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/i644/description.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先，我們來找出這個問題的遞迴性質。可以發現到我們可以在每一排都選一格放皇后，等八排都放完後再來檢查這樣是不是一種正確的放法。那麼，決定第 $k$ 排的皇后要放哪就會是一個可以被遞迴解決的問題，寫成程式碼後大概會長這樣：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void queens(int table[8][8], int n) {\\n    for (int i = 0; i < 8; i++) {\\n        table[n - 1][i] = 1;\\n        if (n == 8) check(table);\\n        else queens(table, n + 1);\\n        table[n - 1][i] = 0;\\n    }\\n    return;\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，我們會發現這種方法似乎有點浪費時間，有時候前兩個皇后就已經放在同一直行了，程式卻還是會繼續遞迴。因此，為了避免程式浪費時間遞迴不可能的放法，我們可以使用剪枝這個技巧。我們只需要在放下這一橫列的皇后後，先檢查它跟前面的皇后沒有在同一直行或是同一斜排上，確認沒問題後才繼續遞迴就可以了。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void queens(int table[8][8], int n) {\\n    for (int i = 0; i < 8; i++) {\\n        bool legal = true;\\n        // 檢查有沒有在同一直行\\n        for (int j = 0; j < n - 1; j++)\\n            if (table[j][i]) \\n                legal = false;\\n        // 以棋盤左下角為 (0, 0)\\n        // 檢查左下到右上方向的斜線，table[x][y] 的 (y - x) 數值一致\\n        for (int j = 0; j < n - 1; j++)\\n            if (i - (n - 1 - j) >= 0 && table[j][i - (n - 1 - j)]) \\n                legal = false;\\n        // 檢查左上到右下方向的直線，table[x][y] 的 (x + y) 數值一致\\n        for (int j = 0; j < n - 1; j++)\\n            if (i + (n - 1 - j) < 8 && table[j][i + (n - 1 - j)])\\n                legal = false;\\n        // 合法才會繼續遞迴，不合法的即被「剪枝」 \\n        if (legal) { \\n            table[n - 1][i] = 1;\\n            if (n == 8) found();\\n            else queens(table, n + 1);\\n            table[n - 1][i] = 0;\\n        }\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1356\",\n      src: \"TIOJ 1356\",\n      name: \"河內塔（續）\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/TIOJ/1356/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1356/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1356/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1356/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/62/\",\n      src: \"NEOJ 62\",\n      name: \"數獨\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NEOJ/62/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/62/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/62/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/62/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/LeetCode/fibonacci-number/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"費氏數列由一連串的費氏數組成，滿足每一項的數字都由前兩項相加得到，並由 $0$ 和 $1$ 作為數列的起始值。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"若寫下費氏數列的遞迴關係式，可以得到：\", _jsx(_components.br, {}), \"\\n\", \"$\", _jsx(_components.br, {}), \"\\n\", \"F(0) = 0, F(1) = 1\\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"F(n) = F(n - 1) + F(n - 2),\\\\ \\\\text{for }n > 1\", _jsx(_components.br, {}), \"\\n\", \"$\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"給定 $n$，請求出 $F(n)$\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/LeetCode/fibonacci-number/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq n\\\\leq 30$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1355/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"傳說在古老的印度，有一座神廟，據說它是宇宙的中心。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在廟宇中放置了一塊上面插有三根長木釘的木板，在其中的一根木釘上，從上至下被放置了 $64$ 片直徑由小至大的圓環形金屬片。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"古印度教的天神指示祂的僧侶們將 $64$ 片的金屬片移至三根木釘中的其中一根上。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"規定在每次的移動中，只能搬移一片金屬片，並且在過程中必須保持金屬片由上至下是直徑由小至大的次序，也就是說不論在那一根木釘上，圓環形的金屬片都是直徑較小的被放在上層。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"直到有一天，僧侶們能將 $64$ 片的金屬片依規則從指定的木釘上全部移動至另一根木釘上，那麼，世界末日即隨之來到，世間的一切終將被毀滅，萬物都將至極樂世界。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"僧侶極希望能早點結束這繁重的工作，於是來求助於你，要如何才能有效率的進行這工作呢？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1355/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"金屬片的數量 $\\\\leq 10$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/i644/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"西洋棋的棋盤中你可以放置 $8$ 個皇后而且彼此都不衝突（就是都不能吃到對方）。請你寫一個程式來輸出所有這樣可能的安排。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"為了把棋盤標準化，我們定義棋盤最左上角的位置為$（1,1）$。所以下圖黑色方塊的位置為$（4,6）$，代表第 $4$ 列（ROW），第 $6$ 行（COLUMN）。\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/problems/ZeroJudge/i644/figure/board.png\",\n      width: \"250\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1356/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"繼承先前我們提到的河內塔例題，若 3 號柱子與 1 號柱子的移動過程之間，一定要先經過 2 號柱子，你能給出移動方法嗎？\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1356/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"金屬片的數量 $\\\\leq 10$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/62/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"在數獨遊戲中，遊戲給你一個 $9\\\\times 9$ 的方陣，其中還可以分成 $9$ 個 $3\\\\times 3$ 的子方陣。例如：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/problems/NEOJ/62/figure/ZtaggER.png\",\n      width: \"200\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"數獨的遊戲規則是這樣的，最後完成數獨的時候，每個格子都必須填上 $1\\\\sim 9$ 其中一個數字，並且在每一行、每一列、每一個子方陣中，都不能有重複的數字。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在給你一個 $9\\\\times 9$ 的方陣，上面有一些格子已經寫上數字了，你的任務是完成這個數獨。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/62/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"每筆測試資料未填上數字的格子數保證不超過 $15$ 個\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"單一測資檔不超過十筆測試資料\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"定義","depth":1,"code":"定義"},{"text":"應用","depth":1,"code":"應用"},{"text":"剪枝","depth":1,"code":"剪枝"},{"text":"習題","depth":1,"code":"習題"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}