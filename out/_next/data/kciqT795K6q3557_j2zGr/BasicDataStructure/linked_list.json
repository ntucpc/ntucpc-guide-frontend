{"pageProps":{"props":{"mdxPath":"guide/content/BasicDataStructure/linked_list/linked_list.mdx","code":"BasicDataStructure/linked_list","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"廣度優先搜尋","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"分治法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"深度優先搜尋","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","Implementation/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":true},{"code":"BasicDynamicProgramming/knapsack_and_rolling","article":"knapsack_and_rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":false,"title":"背包問題與滾動 DP","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":true},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":true},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":true},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","Implementation/buglist"],"coming":true},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":false,"title":"二分圖","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":false,"title":"圖論導論","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":false,"title":"單調隊列","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 III","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 II","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/basic_knowledge","article":"basic_knowledge","topic":"Implementation","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"Implementation/buglist","article":"buglist","topic":"Implementation","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/variable"],"coming":false},{"code":"Implementation/compiler","article":"compiler","topic":"Implementation","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/debug","article":"debug","topic":"Implementation","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["Implementation/buglist"],"coming":false},{"code":"Implementation/error_message","article":"error_message","topic":"Implementation","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/compiler"],"coming":false},{"code":"Implementation/float_error","article":"float_error","topic":"Implementation","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/input","article":"input","topic":"Implementation","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"Implementation/pseudo_pointer","article":"pseudo_pointer","topic":"Implementation","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/reference","article":"reference","topic":"Implementation","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/rngbased","article":"rngbased","topic":"Implementation","chapter":"III","valid":false,"title":"Range-Based for loop","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/structure_binding","article":"structure_binding","topic":"Implementation","chapter":"III","valid":false,"title":"Structure Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/variable","article":"variable","topic":"Implementation","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"],"coming":false},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"Implementation","title":"實作技巧","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","Implementation/debug","Implementation/rngbased","Implementation/structure_binding","Implementation/float_error","Implementation/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack_and_rolling"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["Implementation"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","Implementation/rngbased","Implementation/structure_binding","Implementation/float_error","Implementation/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack_and_rolling","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/BasicDataStructure/linked_list/linked_list.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Figure, Info, Problem, Refcode} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"鏈結串列（Linked List）\",\n      children: \"鏈結串列（Linked List）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在一般的陣列裡面，每個東西會放在一個有編號的格子裡。但如果我們想要在陣列中間插入某個東西，或是把一段陣列平移到別的地方的話，可能會需要更有彈性的資料結構。此時，Linked List 就是一個合適的選擇。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在假設我們在玩一個遊戲：每一個人都要指一個人，那要怎麼紀錄這種關係呢？將每一個人想成一個東西，裡面包著自己的值和指向的人！這就是 Linked List 的精神。如下圖：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicDataStructure/linked_list/figure/linked_list-1.png\",\n      width: \"600\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這裡，蕭梓宏指向王政祺，王政祺指向林尚廷……直到劉至軒停止。用資訊的術語來講，每一個東西稱作一個\", _jsx(_components.strong, {\n        children: \"節點（node）\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"鏈結串列（Linked List）-雙向串列（Doubly Linked List）\",\n      children: \"雙向串列（Doubly Linked List）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有時候，會有人想要知道是誰指向自己，就會再維護一個指標指向「指向自己的那個人」，圖形大概長這樣：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicDataStructure/linked_list/figure/linked_list-2.png\",\n      width: \"600\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"作法就是：當 A 連到 B 的時候，將 A 指向的人設為 B，而 B 的被指的人設為 A。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"了解作法之後，就來看看如何實作吧！\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"鏈結串列（Linked List）-實作時間\",\n      children: \"實作時間\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"經典題\",\n      name: \"實作噩夢之 linked list 篇\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/linked_list_practice/description.mdx\",\n      constraintsMdx: \"guide/problems/Misc/linked_list_practice/constraints.mdx\",\n      importMdx: \"guide/problems/Misc/linked_list_practice/description.mdx\",\n      importMdx: \"guide/problems/Misc/linked_list_practice/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們一步步看要怎麼支援每個操作：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先，我們假設每個節點可以直接用他的編號讀取，並把所需要存取的資料宣告成陣列，再寫好一個初始化用的函式：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int prev_node[maxn]; // 上一個節點編號\\nint next_node[maxn]; // 下一個節點編號\\nint is_inserted[maxn]; // 節點是否在 linked list 裡面\\n\\n// 初始化節點 x\\nvoid Init(int x, int prv, int nxt, int inserted) {\\n    prev_node[x] = prv;\\n    next_node[x] = nxt;\\n    is_inserted[x] = inserted;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其中 \", _jsx(_components.code, {\n        children: \"prev_node\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"next_node\"\n      }), \" 就是這個節點指向的前一個/後一個人。但如果前一項或後一項不存在時怎麼辦？這裡我們可以使用一個聰明的小技巧，可以發現題目並不會用到 $0$ 這個編號，所以不如就把 $0$ 當作不存在的象徵。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"同時，我們還可以刻意讓陣列中 $0$ 的位置存上有關於頭尾的資訊，讀者也可以想像成我們把 linked list 變成這種樣子：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicDataStructure/linked_list/figure/linked_list-3.png\",\n      width: \"600\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也就是製造一個假想節點在頭尾！這樣就可以省下不少方便的判斷了，讀者可以透過後面的實作來感受其簡潔性。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"    // 刻意使用一點小聰明，讓節點編號 0 同時當作頭尾\\n    Init(0, 0, 0, 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下來讓我們看看插入操作的細節。當我們要在節點 $a$ 後插入一個點 $n$ 時，原本 $a$ 跟 $a$ 的下一項中間的連結會被斷開，然後我們要把中間的連跟這兩個點各自連接。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"// 在節點 x 之後插入 id 的節點\\nvoid Insert(int x, int id) {\\n    int nxt = next_node[x];\\n    Init(id, x, nxt, 1);\\n    prev_node[nxt] = id;\\n    next_node[x] = id;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"刪除也是類似，就是變成反過來把 $a$ 的前一項和下一項連結回來。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"// 刪除節點 x\\nvoid Delete(int x) {\\n    int prv = prev_node[x];\\n    int nxt = next_node[x];\\n    is_inserted[x] = 0;\\n    next_node[prv] = nxt;\\n    prev_node[nxt] = prv;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"至於要怎麼在節點 $a$ 前面插入節點呢？這裡不用再重新實作一個新的函式，可以直接想成是「在節點 $a$ 的上一個節點」後面插入節點！類似的想法也可以套用到插入頭尾的操作，只要好好思考假想節點 $0$ 的概念就好。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下附上完整的實作，讀者可以多加反思：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <iostream>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\nint prev_node[maxn]; // 上一個節點編號\\nint next_node[maxn]; // 下一個節點編號\\nint is_inserted[maxn]; // 節點是否在 linked list 裡面\\n\\n// 初始化節點 x\\nvoid Init(int x, int prv, int nxt, int inserted) {\\n    prev_node[x] = prv;\\n    next_node[x] = nxt;\\n    is_inserted[x] = inserted;\\n}\\n\\n// 在節點 x 之後插入 id 的節點\\nvoid Insert(int x, int id) {\\n    int nxt = next_node[x];\\n    Init(id, x, nxt, 1);\\n    prev_node[nxt] = id;\\n    next_node[x] = id;\\n}\\n\\n// 刪除節點 x\\nvoid Delete(int x) {\\n    int prv = prev_node[x];\\n    int nxt = next_node[x];\\n    is_inserted[x] = 0;\\n    next_node[prv] = nxt;\\n    prev_node[nxt] = prv;\\n}\\n\\nint main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    // 刻意使用一點小聰明，讓節點編號 0 同時當作頭尾\\n    Init(0, 0, 0, 1);\\n    int m;\\n    cin >> m;\\n    while (m--) {\\n        int op;\\n        cin >> op;\\n        if (op == 1) {\\n            int n;\\n            cin >> n;\\n            Insert(0, n);\\n        }\\n        else if (op == 2) {\\n            int n;\\n            cin >> n;\\n            Insert(prev_node[0], n);\\n        }\\n        else if (op == 3) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (!is_inserted[a])\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                Insert(prev_node[a], n);\\n        }\\n        else if (op == 4) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (!is_inserted[a])\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                Insert(a, n);\\n        }\\n        else if (op == 5) {\\n            int a;\\n            cin >> a;\\n            if (!is_inserted[a]) \\n                cout << \\\"peko\\\\n\\\";\\n            else if (prev_node[a] == 0)\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << prev_node[a] << \\\"\\\\n\\\";\\n        }\\n        else if (op == 6) {\\n            int a;\\n            cin >> a;\\n            if (!is_inserted[a]) \\n                cout << \\\"peko\\\\n\\\";\\n            else if (next_node[a] == 0)\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << next_node[a] << \\\"\\\\n\\\";\\n        }\\n        else if (op == 7) {\\n            int a;\\n            cin >> a;\\n            if (!is_inserted[a])\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                Delete(a);\\n        }\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"Linked list 的使用時機：\", _jsx(_components.br, {}), \"\\n\", \"當題目出現「在某個位置插入/刪除元素」，或者是把一段區間的元素移動/反轉的操作，可能就是 Linked List 出場的時間。\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"STL\",\n      children: \"STL\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"STL 也為 linked list 設計了一個容器適配器，不過由於 linked list 的操作較為複雜，有許多操作需要跟\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicDataStructure/iterator\",\n        mode: \"article\",\n        topicTitle: \"基礎資料結構\",\n        articleTitle: \"Iterator\"\n      }), \"有一定的熟悉度，建議讀者先有基本的認知再閱讀這個小節。以下是 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 的宣告方法。\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"list<int> lst; // // 宣告一個儲存 int 型別的 list\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"list\"\n      }), \" 是放在 \", _jsx(_components.code, {\n        children: \"<list>\"\n      }), \" 標頭檔內，使用前記得引入。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"STL-STL linked list 操作\",\n      children: \"STL linked list 操作\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"push_back()\"\n        }), \" 可以將資料放入 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 尾端；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"pop_back()\"\n        }), \" 將 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 尾端的元素刪除\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"push_front()\"\n        }), \" 可以將資料放入 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 前端；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"pop_front()\"\n        }), \" 將 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 前端的元素刪除\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"front()\"\n        }), \" 查詢 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 前端元素\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"back()\"\n        }), \" 查詢 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 後端元素\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"insert()\"\n        }), \" 可以插入元素在一個 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 內的 \", _jsx(_components.code, {\n          children: \"iterator\"\n        }), \" 的\", _jsx(_components.strong, {\n          children: \"前方\"\n        }), \"；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"size()\"\n        }), \" 查詢目前還位於 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 的資料數；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"empty()\"\n        }), \" 回傳 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 是否為空。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"splice()\"\n        }), \" 可以在 $O(1)$ 時間內將一個 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 串接另一個 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 的任何位置\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"list<int> lsta, lstb;\\nlsta.push_back(3); // a: [3], b: []\\nlsta.push_back(1); // a: [3, 1], b: []\\nlsta.push_front(2); // a: [2, 3, 1], b: []\\nlsta.pop_back(); // a: [2, 3], b: []\\nlsta.pop_front(); // a: [3], b: []\\nlsta.push_front(1); // a: [1, 3], b: []\\nlstb.push_front(4); // a: [1, 3], b: [4]\\nlstb.push_back(5); // a: [1, 3], b: [4, 5]\\nlsta.splice(next(lsta.begin()), lstb); // a: [1, 4, 5, 3], b: []\\ncout << lsta.front() << endl; // 1\\ncout << lsta.back() << endl; // 3\\ncout << lstb.size() << endl; // 0\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過這樣似乎衍伸了一些問題：\"\n    }), \"\\n\", _jsxs(_components.h4, {\n      refId: \"STL-STL linked list 操作-沒有 \",\n      children: [\"沒有 \", _jsx(_components.code, {\n        children: \"prev\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"next\"\n      }), \" 操作嗎？\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 STL \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 的世界中，存取單一節點資訊除了頭尾外，幾乎都是使用該節點的 iterator 來進行存取，在拿到 iteartor 後，就可以呼叫 iterator 的通用函式 \", _jsx(_components.code, {\n        children: \"prev()\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"next()\"\n      }), \" 來獲得資料。而若要獲得一個 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 的頭尾節點本身，使用 \", _jsx(_components.code, {\n        children: \"begin()\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"--end()\"\n      }), \" 即可。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      refId: \"STL-STL linked list 操作-要怎麼像前面例題一樣存取編號 $a$ 的節點呢？\",\n      children: \"要怎麼像前面例題一樣存取編號 $a$ 的節點呢？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這裡就需要使用一些慣用手法，一種常見的做法便是「儲存節點的 iterator」，直接宣告一個陣列來儲存每個節點在 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 內的位置，這樣就可以直接戳出想要的位置了！\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下面這份程式碼使用 STL 實作出了前面的例題，讀者可以比對著研究看看。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <iostream>\\n#include <list>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\n// 用來紀錄每個節點對應在 lst 內的位置\\nlist<int>::iterator node_it[maxn];\\n\\nint main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    list<int> lst;\\n    // 在所有節點都尚未插入的情況下，初始化每個節點的位置為不存在的 lst.end()\\n    for (int i = 0; i < maxn; ++i)\\n        node_it[i] = lst.end();\\n    int m;\\n    cin >> m;\\n    while (m--) {\\n        int op;\\n        cin >> op;\\n        if (op == 1) {\\n            int n;\\n            cin >> n;\\n            lst.push_front(n);\\n            node_it[n] = lst.begin();\\n        }\\n        else if (op == 2) {\\n            int n;\\n            cin >> n;\\n            lst.push_back(n);\\n            node_it[n] = --lst.end();\\n        }\\n        else if (op == 3) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                node_it[n] = lst.insert(node_it[a], n);\\n        }\\n        else if (op == 4) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                node_it[n] = lst.insert(next(node_it[a]), n);\\n        }\\n        else if (op == 5) {\\n            int a;\\n            cin >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else if (prev(node_it[a]) == lst.end())\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << *prev(node_it[a]) << \\\"\\\\n\\\";\\n        }\\n        else if (op == 6) {\\n            int a;\\n            cin >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else if (next(node_it[a]) == lst.end())\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << *next(node_it[a]) << \\\"\\\\n\\\";\\n        }\\n        else if (op == 7) {\\n            int a;\\n            cin >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else {\\n                lst.erase(node_it[a]);\\n                node_it[a] = lst.end();\\n            }\\n        }\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"應用\",\n      children: \"應用\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再讓我們來看看一道應用題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/21/\",\n      src: \"NEOJ 21\",\n      name: \"陸行鳥大賽車\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/NEOJ/21/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/21/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/21/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/21/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"對於初始序列的建構，轉化成按照名次順序插入節點就行了。刪除節點的操作，模板就有直接支援。超越的部分比較麻煩，對於每一筆超越的操作，可以想像成先將前一名的節點刪除，再插入到自己的後面，因為 Linked List 對於 id 的插入、刪除操作都是 $O(1)$ ，所以總複雜度 $O(N+M)$。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"以下這份程式碼繼承了我們最一開始的 linked list 實作，讀者有興趣也可以自行使用 STL 的 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 實作看看：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    Init(0, 0, 0, 1);\\n    int n, m;\\n    cin >> n >> m;\\n\\n    // 初始化\\n    for (int i = 0; i < n; ++i)\\n        Insert(i, i + 1);\\n\\n    while (m--) {\\n        int op, id;\\n        cin >> op >> id;\\n        if (op == 0) {  \\n            // 刪除節點 id\\n            Delete(id);\\n        }\\n        else {\\n            // 超越前一名\\n            int p = prev_node[id];\\n            if (p != 0) {\\n                int pp = prev_node[p];\\n                Delete(p);\\n                Delete(id);\\n                Insert(pp, id);\\n                Insert(id, p);\\n            }\\n        }\\n    }\\n    // 遍歷整個 list\\n    int cur = next_node[0];\\n    while (cur != 0) {\\n        cout << cur << \\\" \\\\n\\\"[next_node[cur] == 0];\\n        cur = next_node[cur];\\n    }\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"應用-查詢和修改和複雜度\",\n      children: \"查詢和修改和複雜度\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果想要查詢「一個東西指到誰？」的話，顯然這個可以在 $O(1)$ 內做完。那如果想要做的是查詢「我這個人一直指，指到第 $k$ 個人會是誰呢？」那就得花 $O(k)$ 的時間，所以 \", _jsx(_components.strong, {\n        children: \"Linked List 不適合隨機存取\"\n      }), \"，也就是在只給串列頭的狀況下，查詢第 $n$ 項的值，會變得很慢。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"注意到，這樣代表 Linked List 跟陣列有點像是相反的資料結構。Linked List 可以在 $O(1)$ 時間插入/刪除元素，但是需要 $O(n)$ 時間從頭開始找某一項。陣列則是要花 $O(n)$ 時間插入跟刪除元素，不過在 $O(1)$ 時間就能找到某一項。\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=b938\",\n      src: \"ZeroJudge b938\",\n      name: \"kevin 愛殺殺\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/ZeroJudge/b938/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/b938/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b938/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b938/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/21/\",\n      src: \"NEOJ 21\",\n      name: \"陸行鳥大賽車\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NEOJ/25/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/25/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/25/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/25/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/linked_list_practice/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"請你實做一個 linked-list ，並實現以下指令：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"1 n\"\n        }), \"：將整數 $n$ 放進 linked-list 的頭\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"2 n\"\n        }), \"：將整數 $n$ 放進 linked-list 的尾\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"3 n a\"\n        }), \"：將整數 $n$ 放到整數 $a$ 的前面，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        }), \" 並略過這個操作\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"4 n a\"\n        }), \"：將整數 $n$ 放到整數 $a$ 的後面，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        }), \" 並略過這個操作\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"5 a\"\n        }), \"：印出整數 $a$ 前面的整數，若此整數不存在則印出 \", _jsx(_components.code, {\n          children: \"NULL\"\n        }), \"，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"6 a\"\n        }), \"：印出整數 $a$ 後面的整數，若此整數不存在則印出 \", _jsx(_components.code, {\n          children: \"NULL\"\n        }), \"，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"7 a\"\n        }), \"：刪除整數 $a$，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        }), \" 並略過這個操作\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/linked_list_practice/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsxs(_components.li, {\n      children: [\"保證所有操作 \", _jsx(_components.code, {\n        children: \"1\"\n      }), \", \", _jsx(_components.code, {\n        children: \"2\"\n      }), \", \", _jsx(_components.code, {\n        children: \"3\"\n      }), \", \", _jsx(_components.code, {\n        children: \"4\"\n      }), \" 中的整數 $n$ 不會重複\"]\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$指令數 \\\\leq 20000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 < $ 所有整數 $\\\\leq 100000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/21/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"輸入說明\"\n      }), _jsx(_components.br, {}), \"\\n\", \"第一行包含一個整數 $N$，代表現在有 $N$ 個玩家，編號 $1\\\\sim N$ 的玩家目前分別為第 $1\\\\sim N$ 名（編號 $1$ 第 $1$ 名、編號 $2$ 第 $2$ 名……）。\", _jsx(_components.br, {}), \"\\n\", \"第二行包含一個整數 $M$，代表接下來會依序發生 $M$ 個事件。\", _jsx(_components.br, {}), \"\\n\", \"接下來的 $M$ 行，每行包含兩個整數 $T_i,X_i$，$T_i$ 為 $0$ 的時候，代表編號 $X_i$ 的玩家遭受攻擊，然後離開遊戲；$T_i$ 為 $1$ 的時候，代表編號 $X_i$ 的玩家使用衝刺，無條件超越當前名次比他高一名的玩家。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"輸出說明\"\n      }), _jsx(_components.br, {}), \"\\n\", \"輸出一行，包含 $Y$ 個整數（$Y$ 是剩餘玩家的數量），由名次小到大依序輸出，整數兩兩間以空白隔開。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/21/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N\\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$M\\\\leq 50000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq T_i\\\\leq 1$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq X_i\\\\leq N$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"測試資料保證玩家被淘汰之後不會再出現任何紀錄。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b938/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"$n$ 個人站成一列，請執行 $m$ 次操作，每次都會把編號 $k$ 後面的人殺掉，並輸出這個被殺掉的人的編號。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b938/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq n, m\\\\leq 10^6$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/25/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 個店家在販賣物品，顧客們想在任何店家買東西都需要排隊，請支援 $M$ 筆操作：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"ADD\"\n        }), \"$\\\\;i\\\\;id$：代表編號為 $id$ 的顧客前往店家 $i$，排在隊伍的最後端\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"LEAVE\"\n        }), \"$\\\\;i$：代表店家 $i$ 賣出了一個物品給排在隊伍最前端的顧客，該顧客會離開隊伍\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"JOIN\"\n        }), \"$\\\\;i\\\\;j$：店家 $i$ 的物品賣完了，所以排在店家 $i$ 的隊伍會按照順序重新排在店家 \", _jsx(_components.code, {\n          children: \"j\"\n        }), \" 的後面\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/25/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N\\\\leq 100$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$M\\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"顧客編號介在 $1\\\\sim 10^6$ 之間\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"保證同一個顧客不會同時出現在不同隊伍中。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"鏈結串列（Linked List）","depth":1,"code":"鏈結串列（Linked List）"},{"text":"雙向串列（Doubly Linked List）","depth":2,"code":"鏈結串列（Linked List）-雙向串列（Doubly Linked List）"},{"text":"實作時間","depth":2,"code":"鏈結串列（Linked List）-實作時間"},{"text":"STL","depth":1,"code":"STL"},{"text":"STL linked list 操作","depth":2,"code":"STL-STL linked list 操作"},{"text":"沒有 ","depth":3,"code":"STL-STL linked list 操作-沒有 "},{"text":"要怎麼像前面例題一樣存取編號 $a$ 的節點呢？","depth":3,"code":"STL-STL linked list 操作-要怎麼像前面例題一樣存取編號 $a$ 的節點呢？"},{"text":"應用","depth":1,"code":"應用"},{"text":"查詢和修改和複雜度","depth":2,"code":"應用-查詢和修改和複雜度"},{"text":"習題","depth":1,"code":"習題"}]}},"__N_SSG":true}