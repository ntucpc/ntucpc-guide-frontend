{"pageProps":{"props":{"mdxPath":"guide/content/BasicMath/basicalgo/basicalgo.mdx","content":[["guide/content/BasicMath/basicalgo/basicalgo.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Info, Problem, Proof, Refcode, Theorem, TheoremReference} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Proof) _missingMdxReference(\"Proof\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  if (!Theorem) _missingMdxReference(\"Theorem\", true);\n  if (!TheoremReference) _missingMdxReference(\"TheoremReference\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"section-0.1\",\n      children: \"模運算\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"「取餘數」，也就是 C++ 中的 \", _jsx(_components.code, {\n        children: \"%\"\n      }), \" 運算子，是一個在程式競賽中很常使用到的運算，除了餘數本身的性質有許多派上用場的時機之外，也有許多題目是因為答案非常大，而要求要先把答案取個餘數後再輸出。「取餘數」這個運算有個名字叫作\", _jsx(_components.strong, {\n        children: \"模運算\"\n      }), \"（modulo），也叫作模或模除，在寫數學式子的時候通常會寫成 $\\\\bmod$，例如 $5 \\\\bmod 2$ 就是取 $5$ 除以 $2$ 的餘數，也就是 $1$，讀作「五模除二」（更多時候會簡稱成「五模二」）或是「$5$ modulo $2$」。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.1.1\",\n      children: \"C++ 中的除法與模運算\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"在這個小節中，寫成等寬字體的 \", _jsx(_components.code, {\n          children: \"a / b\"\n        }), \" 是指 C++ 程式碼之中的整數除法，數學字體 $a / b$ 或 $\\\\frac{a}{b}$ 是指數學上除法的結果，也就是沒有經過取整的有理數。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 就是 \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" 除以 \", _jsx(_components.code, {\n        children: \"b\"\n      }), \" 取餘數這件事情聽起來非常簡單，畢竟我們國小就學過怎麼取餘數了，不過這件事情其實沒有表面上這麼單純──如果哪天我們需要對負數進行模運算怎麼辦？$-5 \\\\div 3$ 應該是 $-5 \\\\div 3 = -1 \\\\ldots -2$ 還是 $-5 \\\\div 3 = -2 \\\\ldots 1$？在 C++ 中，\", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 就等同於 \", _jsx(_components.code, {\n        children: \"a - a / b * b\"\n      }), \"，而在 C++ 裡面的整數除法是「向零取整」，也就是除完的結果不是整數的時候，會取比較靠近 0 的那個整數，所以 \", _jsx(_components.code, {\n        children: \"-5 / 3\"\n      }), \" 的結果會是 \", _jsx(_components.code, {\n        children: \"-1\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"-5 % 3\"\n      }), \" 的結果會是 \", _jsx(_components.code, {\n        children: \"-5 - (-5) / 3 * 3 == -2\"\n      }), \"，\", _jsx(_components.code, {\n        children: \"5 / -3\"\n      }), \" 的結果也是 \", _jsx(_components.code, {\n        children: \"-1\"\n      }), \"，不過 \", _jsx(_components.code, {\n        children: \"5 % -3\"\n      }), \" 的結果是 \", _jsx(_components.code, {\n        children: \"5 - 5 / (-3) * (-3) == 2\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，在實際的使用上，大多時候我們的模數 $b$ 都是正整數，而且我們其實會比較希望 $a \\\\bmod b$ 是一個非負整數，也就是 $a \\\\bmod b$ 的定義是\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"definition\",\n      title: \"模運算\",\n      number: \"1\",\n      children: _jsx(_components.p, {\n        children: \"$a \\\\bmod b$ 是將 $a$ 表示成 $kb+r$、$k$ 是整數時，最小的可能的非負整數 $r$。在這個時候，$k$ 會是 $\\\\lfloor \\\\frac ab \\\\rfloor$，而 $r$ 肯定是 $[0, \\\\lvert b \\\\rvert)$ 之間的整數。\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果在對一個負數取模的時候，希望獲得非負的餘數，也就是 $a - \\\\lfloor \\\\frac ab \\\\rfloor$ 的話，可以寫成 \", _jsx(_components.code, {\n        children: \"(a % b + b) % b\"\n      }), \"，這樣就一定會得到 $[0,b)$ 之內的結果了。這麼做的原因是因為 \", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 肯定是一個在 $(-b,b)$ 之內的整數，加上 $b$ 之後肯定會變成 $\\\\geq 0$，最後需要再模 $b$ 一次是因為有可能本來 \", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 的結果就是 $\\\\geq 0$ 了，這樣 $+b$ 之後會 $\\\\geq b$，所以要再模一次。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"注意 \", _jsx(_components.code, {\n          children: \"(a % b + b) % b\"\n        }), \" 這個寫法需要 $b > 0$。\"]\n      })\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"tips\",\n      title: \"整數除法\",\n      number: \"1\",\n      children: [_jsxs(_components.p, {\n        children: [\"剛剛提到 \", _jsx(_components.code, {\n          children: \"a / b\"\n        }), \" 會「向零取整」，也就是在 $\\\\frac ab$ 的結果是正時會向下取整（$\\\\lfloor \\\\frac ab \\\\rfloor$）、是負時會向上取整（$\\\\lceil \\\\frac ab \\\\rceil$），那麼要怎麼實作向下取整或向上取整的運算呢？不要使用 \", _jsx(_components.code, {\n          children: \"<cmath>\"\n        }), \" 提供的 \", _jsx(_components.code, {\n          children: \"floor\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"ceil\"\n        }), \" 函數，因為它們都是浮點數運算，會有浮點數誤差的問題，正確的作法是：\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"如果 $a,b$ 同號，那 $\\\\frac ab$ 本來就是正的，可以放心算 \", _jsx(_components.code, {\n            children: \"a / b\"\n          }), \"。\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"如果 $a,b$ 異號，那 $\\\\frac ab$ 就是負的，\", _jsx(_components.code, {\n            children: \"a / b\"\n          }), \" 就是 $\\\\lceil \\\\frac ab \\\\rceil$，如果 $\\\\frac ab$ 不整除的話，$\\\\lfloor \\\\frac ab \\\\rfloor=\\\\lceil \\\\frac ab \\\\rceil - 1$，所以答案是 \", _jsx(_components.code, {\n            children: \"a / b - 1\"\n          }), \"。\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.1.2\",\n      children: \"同餘與模下的運算\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"剛剛我們其實做了一些不太容易理解的事情：把 $a$ 先模 $b$、再加上 $b$、再模 $b$，這樣答案真的跟 $a \\\\bmod b$ 一樣嗎？要暸解為什麼可以這樣，我們先來暸解同餘的概念：\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"definition\",\n      title: \"同餘\",\n      number: \"2\",\n      children: _jsx(_components.p, {\n        children: \"$a \\\\equiv b \\\\pmod m$ 的條件是 $m \\\\mid (a - b)$，也就是 $\\\\frac{a-b}{m}$ 整除。這個式子完整讀作「$a$ 跟 $b$ 在模 $m$ 下同餘」。\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再寫一次模運算的定義：$k = \\\\lfloor \\\\frac ab \\\\rfloor$、$r = a \\\\bmod b$ 時，$a = kb+r$，移項一下就變成 $\\\\frac{a - r}{b} = k$，而 $k$ 是一個整數，因此 $a \\\\equiv r \\\\pmod{b}$。很明顯地\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\[ a \\\\equiv b \\\\pmod m \\\\iff a \\\\bmod m = b \\\\bmod m \\\\]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也就是模 $m$ 後一樣的數字就同餘。$\\\\equiv$ 這符號跟 $=$ 長得很像，從某種角度來說，可以視為同餘就是「在模運算之下的等於」，它跟等於有多像呢？\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"lemma\",\n      title: \"同餘的遞移律\",\n      number: \"1\",\n      children: _jsx(_components.p, {\n        children: \"對於任意整數 $a,b,c$、正整數 $m$，如果 $a \\\\equiv b \\\\equiv c \\\\pmod m$，就代表 $a \\\\equiv c$。\"\n      })\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"lemma\",\n      title: \"同餘的運算\",\n      number: \"2\",\n      children: [_jsx(_components.p, {\n        children: \"對於任意整數 $a,b,c$、正整數 $m$，如果 $a \\\\equiv b \\\\pmod m$，那麼：\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"$a + c \\\\equiv b + c \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a - c \\\\equiv b - c \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a \\\\times c \\\\equiv b \\\\times c \\\\pmod m$\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這些的證明都很簡單，只要代入同餘的定義即可，讀者可以練習看看。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以說，$\\\\equiv$ 兩邊的兩個數字一起加減乘一個數字，都不會改變它們同餘的關係，而且還有遞移律，就跟我們平常認識的 $=$ 很像！不過也有一些不一樣的地方，注意到我們只提到「加減乘」，但四則運算中的除法並沒有跟它們一起出現，這是因為把兩邊除上一個數後，不見得會保持同餘關係，先不談不整除的時候不知該怎麼辦，光是整除的狀況就可能會出問題，像是 $6 \\\\equiv 12 \\\\pmod 6$，但是如果把兩邊各自除以 $3$，$2 \\\\equiv 4 \\\\pmod 6$ 顯然是錯的。\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"有一個真實存在的性質是當 $c$ 是 $a,b,m$ 的公因數時，$\\\\frac{a}{c} \\\\equiv \\\\frac{b}{c} \\\\pmod{\\\\frac{m}{c}}$，但通常改變模數並不是我們想要的，之後的篇章會再處理除法的問題，這裡我們先不討論。\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然同餘類似於某種「等於的關係」，那其實可以更進一步地說：\"\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"lemma\",\n      title: \"同餘的運算 2\",\n      refId: \"mod2\",\n      number: \"3\",\n      children: [_jsx(_components.p, {\n        children: \"對於任意整數 $a,b,c,d$、正整數 $m$，如果 $a \\\\equiv b \\\\pmod m$ 且 $c \\\\equiv d \\\\pmod m$，那麼：\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"$a + c \\\\equiv b + d \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a - c \\\\equiv b - d \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a \\\\times c \\\\equiv b \\\\times d \\\\pmod m$\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"回來看看我們剛剛寫過的式子：\", _jsx(_components.code, {\n        children: \"(a % b + b) % b\"\n      }), \"，雖然 \", _jsx(_components.code, {\n        children: \"% b\"\n      }), \" 出來的結果可能是負的，但它總是個取餘數的運算，\", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 的結果永遠都會跟 $a$ 在模 $b$ 下同餘。所以：\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"\\\\begin{align*}\", _jsx(_components.br, {}), \"\\n\", \"& ((a\\\\ \\\\texttt{%}\\\\ b) + b)\\\\ \\\\texttt{%}\\\\ b \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\equiv\\\\ & (a\\\\ \\\\texttt{%}\\\\ b) + b & (\\\\texttt{%}\\\\text{ 會保持同餘}) \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\equiv\\\\ & a\\\\ \\\\texttt{%}\\\\ b & (\\\\texttt{\\\\(b\\\\) 跟 \\\\(0\\\\) 同餘}) \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\equiv\\\\ & a & (\\\\texttt{%}\\\\text{ 會保持同餘}) \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"& (\\\\text{mod}\\\\ \\\\ b)\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{align*}\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"得到結果真的會跟 $a$ 模 $b$ 下同餘，我們又知道運算結果是一個 $[0, b)$ 以內的數，所以這個答案就只能是 $a \\\\bmod b$ 了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.1.3\",\n      children: \"運算過程取模\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在那種「因為答案很大所以要取模再輸出」的題目中，很有可能光是在運算過程中，數字就會大到 \", _jsx(_components.code, {\n        children: \"long long int\"\n      }), \" 也存不下，所以算完最後再取模肯定是不行的！舉例來說，我們想要算 $2^{100} \\\\bmod 10^9+7$，雖然答案是個連 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 都存的下的數，但要是我們先算完 $2^{100}$ 再模，那一般的整數型態肯定存不下。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(TheoremReference, {\n        type: \"lemma\",\n        refId: \"mod2\",\n        number: \"3\",\n        title: \"同餘的運算 2\",\n        mode: \"title\"\n      }), \" 其實也告訴了我們，在加減乘運算之前先把數字模一次，也不會改變運算結果，所以其實可以寫成\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"const long long MOD = 1'000'000'007;\\nlong long ans = 1;\\nfor (int i = 0; i < 100; i++) {\\n    ans = ans * 2 % MOD;\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以得到正確的 $2^{100} \\\\bmod 10^9 + 7$。在做這種題目的時候，可以每做一次運算就模一次，這樣就不會溢位了。\"\n    }), \"\\n\", _jsxs(Info, {\n      type: \"info\",\n      children: [_jsx(_components.p, {\n        children: \"世人其實對於 $\\\\bmod$ 和其他運算符號的優先順序沒有什麼共識，所以在有各種運算交錯出現時，最好還是加個括號才比較不容易搞混。一般來說，$a \\\\bmod 10^9+7$ 就是 $a \\\\bmod (10^9+7)$ 的意思，因為這個式子單獨出現時不太會搞混所以經常省略括號。\"\n      }), _jsxs(_components.p, {\n        children: [\"注意在 C++ 中 \", _jsx(_components.code, {\n          children: \"%\"\n        }), \" 的優先度比 \", _jsx(_components.code, {\n          children: \"+\"\n        }), \" 高、和 \", _jsx(_components.code, {\n          children: \"*\"\n        }), \" 跟 \", _jsx(_components.code, {\n          children: \"/\"\n        }), \" 同級，在寫程式的時候要特別注意加減乘模的優先順序，例如 \", _jsx(_components.code, {\n          children: \"a + b % MOD\"\n        }), \" 的意思其實是 \", _jsx(_components.code, {\n          children: \"a + (b % MOD)\"\n        }), \" 而非 \", _jsx(_components.code, {\n          children: \"(a + b) % MOD\"\n        }), \"。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.1.4\",\n      children: \"除法很慢\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"/\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"%\"\n      }), \" 這兩個運算比 \", _jsx(_components.code, {\n        children: \"+-*\"\n      }), \" 慢很多！在運算量很大（如超過 $10^8$）的時候，要是每次加減乘完都模一次，時限又設比較緊的話，就有可能會 TLE。有一些減少模運算次數又不會溢位的小技巧：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"兩個 $[0,m)$ 之內的數相加肯定 $<2m$，所以可以把直接模 $m$ 改成 \", _jsx(_components.code, {\n          children: \"if (ans >= m) ans -= m;\"\n        }), \"。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"減法也是同理，可以改成 \", _jsx(_components.code, {\n          children: \"if (ans < 0) ans += m;\"\n        }), \"。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"一大堆已經取模過的數相加，不會溢位就可以全部加起來再取模，例如模 $10^9+7$ 時，$10^6$ 個 $10^9+6$ 相加都不會超過 \", _jsx(_components.code, {\n          children: \"long long int\"\n        }), \" 範圍，可以放心地最後再模。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過乘法完通常就非模不可了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"section-0.2\",\n      children: \"快速冪\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"剛才我們學會怎麼在不溢位的前提下算出 $2^{100} \\\\bmod 10^9+7$，進階一點，如果我們要算的是 $a^b \\\\bmod m$ 呢？\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1095\",\n      src: \"CSES 1095\",\n      name: \"Exponentiation\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/CSES/1095/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1095/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1095/description.mdx\",\n      importMdx: \"guide/problems/CSES/1095/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"慢慢地把 $a$ 乘 $b$ 次是不行的，那得花上 $O(b)$ 的時間，所以我們得想辦法把指數運算算得更快。在國中的時候，我們有學過指數律：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\[ a^b \\\\times a^c = a^{b+c} \\\\]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"前面我們計算 $a^b$ 的方法，就是直接算 $a^{b-1} \\\\times a = a^b$，所以我們會依序算出 $a^1,a^2,\\\\dots,a^b$，不過我們需要知道的只有最後那個 $a^n$ 而已，可不可以少知道一點？一種想法是我們乾脆把 $b$「分一半」，如果 $b$ 是個偶數 $b=2k$，那我們知道 $a^b=(a^k)^2$，只需要知道 $a^k=a^{b/2}$ 就能算出 $a^b$ 了。照著這個邏輯，要是 $b$ 是個二的冪次 $b=2^k$ 那就很快樂，因為我們只需要一直把 $a$ 平方，就會依序得出\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\[ a=a^{2^0}, \\\\quad (a^{2^0})^2=a^{2^1}, \\\\quad (a^{2^1})^2 = a^{2^2}, \\\\quad \\\\dots, \\\\quad a^{2^k}=a^b \\\\]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"只要花 $O(k)=O(\\\\log b)$ 的時間就能得到 $a^b$ 了！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果 $b$ 不是二的冪次，就代表我們一直除以 2 的話，總有一天會變成一個奇數，這時我們就不能直接分一半了。解決辦法很簡單，把它變成偶數就好了嘛，在 $b$ 是奇數 $b = 2k+1$ 的時候，就有 $a^b=(a^k)^2 \\\\times a$，其實也只要算 $a^k=a^{(b-1)/2}$ 就好了。這樣一來，我們可以先得到一個遞迴的算法：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"a^b = \\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"(a^{b/2})^2, &\\\\qquad \\\\text{if \\\\(b\\\\) 是偶數} \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"(a^{(b-1)/2})^2 \\\\times a, &\\\\qquad \\\\text{if \\\\(b\\\\) 是奇數}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"每次遞迴時 $b$ 就會少一半，所以時間複雜度就是 $O(\\\\log b)$。仔細想想，其實這個過程就等同於去看 $b$ 的\", _jsx(_components.strong, {\n        children: \"二進位分解\"\n      }), \"：\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[ b = \\\\underbrace{b_{\\\\lfloor \\\\log_2 b \\\\rfloor} \\\\dots b_1b_0}_{\\\\text{寫成二進位}}\", _jsx(_components.br, {}), \"\\n\", \"= b_{\\\\lfloor \\\\log_2 b \\\\rfloor} \\\\times 2^{\\\\lfloor \\\\log_2 b \\\\rfloor} + \\\\dots + b_1 \\\\times 2^1 + b_0 \\\\times 2^0 \\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"舉例來說，\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"182_{(10)} = 10110110_{(2)} = 2^7 + 2^5 + 2^4 + 2^2 + 2^1\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"a^{182} = a^{2^7} \\\\times a^{2^5} \\\\times a^{2^4} \\\\times a^{2^2} \\\\times a^{2^1}\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"右邊的東西就是一堆「$a$ 的二的冪次次方」相乘，剛剛我們就已經知道這要怎麼算了，所以可以輕鬆寫成迴圈版本：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"using ll = long long;\\nconst ll MOD = 1'000'000'007;\\nll fastpow(ll a, ll b) {\\n    ll ans = 1;\\n    while (b > 0) {\\n        if (b & 1) ans = ans * a % MOD;\\n        a = a * a % MOD;\\n        b >>= 1;\\n    }\\n    return ans;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在那個 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈第 $i$ 次執行（從 $0$ 開始數）時，當下的 \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" 會是 $a^{2^i}$，\", _jsx(_components.code, {\n        children: \"b\"\n      }), \" 會是 $b$ 少掉最右邊的 $i$ 個 bit，所以 \", _jsx(_components.code, {\n        children: \"b & 1\"\n      }), \" 是在檢查「$b$ 的第 $i$ 個 bit 是不是 1」，是的話就把答案乘上 $a^{2^i}$。用個簡單的小例子，$b=13=1101_{(2)}$，在每次迴圈開始的時候：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"$i=0$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^0,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^1,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 13 = 1101_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 1，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 被更新成 $a^1$。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"$i=1$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^1,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^2,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 6 = 110_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 0，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 不變。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"$i=2$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^1,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^4,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 3 = 11_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 1，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 被更新成 $a^5$。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"$i=3$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^5,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^8,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 1 = 1_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 1，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 被更新成 $a^{13}$。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"b\"\n        }), \" 變成 0 了，迴圈結束。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"時間複雜度和遞迴版本同樣是 $O(\\\\log b)$。\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"不要直接用 \", _jsx(_components.code, {\n          children: \"<cmath>\"\n        }), \" 裡面的 \", _jsx(_components.code, {\n          children: \"pow()\"\n        }), \"！那是一個浮點數函數。\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"section-0.3\",\n      children: \"輾轉相除法\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"國小的時候，老師教我們用短除法計算兩個數 $a,b$ 的最大公因數，作法是先神祕地通靈出一個它們的共同因數 $d$ 之後，把它們都除以 $d$，然後反覆這個動作，直到它們互質為止，過程中所有 $d$ 相乘就是最大公因數了。不過寫程式的時候，我們無法看著數字就猜一個公因數出來，要是像我們在\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicAlgorithm/math_in_school\",\n        mode: \"default\",\n        topicTitle: \"基礎演算法\",\n        articleTitle: \"學校教的數學\"\n      }), \"枚舉因數那樣做的話也得要花 $O(\\\\max(\\\\sqrt{a},\\\\sqrt{b}))$ 的時間。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"要更快算出最大公因數的話，就要用到輾轉相除法了，輾轉相除法也叫作歐幾里得演算法（Euclidean algorithm），它用到一個最大公因數的性質：\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"lemma\",\n      title: \"輾轉相除法\",\n      number: \"4\",\n      children: _jsx(_components.p, {\n        children: \"$\\\\gcd(a,b) = \\\\gcd(a,b-a)$，其中 $\\\\gcd(a,b)$ 是 $a,b$ 的最大公因數，$\\\\gcd(a,0)=\\\\gcd(0,a)=a$。\"\n      })\n    }), \"\\n\", _jsxs(Proof, {\n      type: \"proof\",\n      children: [_jsx(_components.p, {\n        children: \"對於任意一個 $a,b$ 的公因數 $d$，令 $a=a'd,b=b'd$，我們有 $b-a=(b'-a')d$，仍是一個 $d$ 的倍數，所以 $d$ 是 $a,b-a$ 的公因數。\"\n      }), _jsx(_components.p, {\n        children: \"對於任意一個 $a,b-a$ 的公因數 $d$，令 $a=a'd, b-a=td$，我們有 $b=(t+a')d$，仍是一個 $d$ 的倍數，所以 $d$ 是 $a,b$ 的公因數。\"\n      }), _jsx(_components.p, {\n        children: \"總的來說，$d$ 是 $a,b$ 的公因數若且唯若 $d$ 是 $a,b-a$ 的公因數。\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"輾轉相除法的作法很簡單，就是不斷把 $a,b$ 之中大的減去小的，有一個變成 $0$ 之後就直接回傳另一個數字。不過一直慢慢減不見得很快，要是 $a$ 很大、$b=1$，那就要減到天荒地老了，比較聰明的作法是直接令 $a \\\\gets a \\\\bmod b$，畢竟 $a$ 一直扣掉 $b$ 直到變成比 $b$ 還小，那不就是 $a$ 模 $b$ 嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣真的很快嗎？分析一下時間複雜度，假設 $a > b$，那事實上 $a \\\\bmod b \\\\leq a/2$，因為要是 $b \\\\leq a/2$ 那自然是對的，如果 $b > a/2$ 的話，那麼 $a \\\\bmod b = a - b < a/2$，所以每一次都有其中一個數會少一半，時間複雜度就是 $O(\\\\log a + \\\\log b)$。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其實在只是要用最大公因數的時候，不需要自己寫輾轉相除法，從 C++17 開始 \", _jsx(_components.code, {\n        children: \"<numeric>\"\n      }), \" 提供 \", _jsx(_components.code, {\n        children: \"gcd()\"\n      }), \" function，內部的實作就是用輾轉相除法，開心地用下去就好了。在更低的版本的話，在 \", _jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \" 裡面有一個叫作 \", _jsx(_components.code, {\n        children: \"__gcd()\"\n      }), \" 的 function，不過要注意這個 function 不在標準之中，能用 \", _jsx(_components.code, {\n        children: \"gcd\"\n      }), \" 還是用 \", _jsx(_components.code, {\n        children: \"gcd\"\n      }), \" 比較好。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那為什麼要學輾轉相除法呢？不久後就知道了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"section-0.4\",\n      children: \"質數篩法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"檢查一個數 $n$ 是不是質數可以 $O(\\\\sqrt{n})$ 時間內做到，但是如果我們想要找 $1$ 到 $n$ 內的所有質數，花上 $O(n\\\\sqrt{n})$ 的時間一一檢查好像太慢了，這時就要用更聰明的辦法找質數了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一個直覺的想法是，我們枚舉 $2$ 到 $n$ 的每一個數 $i$，但我們不是要檢查 $i$ 是不是質數，而是去把 $i$ 的兩倍以上倍數都標記成「不是質數」，而沒被標記的那些數就是質數了。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"vector<bool> sieve1(int n) { // prime[i] = i 是不是質數\\n    vector<bool> prime(n + 1, true);\\n    prime[0] = prime[1] = false;\\n    for (int i = 2; i <= n; i++)\\n        for (int j = 2 * i; j <= n; j += i)\\n            prime[j] = false;\\n    return prime;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"聽起來好暴力，但這其實很快，被枚舉到的倍數數量會是\", _jsx(_components.br, {}), \"\\n\", \"\\\\[ \\\\frac{n}{1} + \\\\frac{n}{2} + \\\\dots + \\\\frac{n}{n} = O(n \\\\log n) \\\\]\", _jsx(_components.br, {}), \"\\n\", \"正整數的倒數和 $\\\\frac{1}{1}+\\\\frac{1}{2}+\\\\dots+\\\\frac{1}{n}$ 叫作\", _jsx(_components.a, {\n        href: \"https://zh.wikipedia.org/zh-tw/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0\",\n        children: \"調和級數\"\n      }), \"，它的成長率就是 $O(\\\\log n)$，調和級數很常見，在需要枚舉「$1$ 到 $n$ 所有數字在 $n$ 以內的倍數」或是「$1$ 到 $n$ 所有數字的因數」時，要記得總數就只有 $O(n \\\\log n)$ 那麼多。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過篩質數還可以更快！其實我們剛剛做了一些多餘的事情：要是我們已經知道 $i$ 不是質數了，那代表我們曾經用一個它的因數 $x$ 來把它標記成不是質數，而這個 $x$ 當然也已經去砍掉所有 $i$ 的倍數了，因此不是質數的 $i$ 我們就可以跳過：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"vector<bool> sieve2(int n) {\\n    vector<bool> prime(n + 1, true);\\n    prime[0] = prime[1] = false;\\n    for (int i = 2; i <= n; i++)\\n        if (prime[i])\\n            for (int j = 2 * i; j <= n; j += i)\\n                prime[j] = false;\\n    return prime;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這有比較快嗎？有，\", _jsx(_components.a, {\n        href: \"https://zh.wikipedia.org/zh-tw/%E7%B4%A0%E6%95%B0%E7%9A%84%E5%80%92%E6%95%B0%E4%B9%8B%E5%92%8C\",\n        children: \"質數的倒數和\"\n      }), \"成長率是 $O(\\\\log \\\\log n)$，所以這麼做的時間複雜度只要 $O(n \\\\log \\\\log n)$，幾乎跟線性一樣快了，還可以順便知道每個數的質因數。\"]\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"tips\",\n      title: \"因數與質因數的數量\",\n      number: \"2\",\n      children: [_jsx(_components.p, {\n        children: \"一個數 $x$ 會有幾個因數和幾個質因數呢？因為每個質因數都 $\\\\geq 2$，所以 $x$ 的質因數數量是 $O(\\\\log n)$。至於因數數量，如果先找好質因數分解\"\n      }), _jsx(_components.p, {\n        children: \"\\\\[ x = p_1^{e_1} \\\\times p_2^{e_2} \\\\times \\\\dots \\\\times p_k^{e_k} \\\\]\"\n      }), _jsx(_components.p, {\n        children: \"的話，就可以枚舉每個質因數要取幾個，用 $O(\\\\text{因數數量})$ 的時間找到所有因數。在競賽中常見的 $x \\\\leq 10^{9}$ 與 $x \\\\leq 10^{18}$ 範圍中，因數數量最多分別是 $1344$ 與 $103680$，打競賽時通常會直接用 $O(x^{\\\\frac{1}{3}})$ 去算。不過實際上，一個數的因數數量是 $o(x^\\\\epsilon)\\\\ \\\\forall \\\\epsilon > 0$，也就是說，在 $x$ 很大的時候其實是遠少於 $x^{\\\\frac{1}{3}}$ 的。\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"section-0.5\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=a024\",\n      src: \"ZeroJudge a024\",\n      name: \"最大公因數（GCD）\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/ZeroJudge/a024/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/a024/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a024/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a024/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/100\",\n      src: \"NCOJ 100\",\n      name: \"[Tutorial] 找質數\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/NCOJ/100/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/100/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/100/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/100/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以試試看用 $O(C \\\\log C)$（$C=$ $x$ 的值域大小）的時間做出這題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1713\",\n      src: \"CSES 1713\",\n      name: \"Counting Divisors\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/CSES/1713/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1713/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1713/description.mdx\",\n      importMdx: \"guide/problems/CSES/1713/constraints.mdx\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"請試試用類似於快速冪的作法做出這題，請不要寫大數運算，也不要用如 \", _jsx(_components.code, {\n        children: \"__int128\"\n      }), \" 等範圍較大的整數型態：\"]\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=b430\",\n      src: \"ZeroJudge b430\",\n      name: \"簡單乘法\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/ZeroJudge/b430/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/b430/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b430/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b430/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1095/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給你非負整數 $a,b$，求 $a^b \\\\bmod 10^9+7$。特別地，定義 $0^0=1$。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1095/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"有 $1 \\\\leq n \\\\leq 2 \\\\times 10^5$ 個詢問\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 \\\\leq a,b \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a024/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給兩個整數 $a,b$，求它們的最大公因數。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a024/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq a,b < 2^{31}$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/100/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給你一個 $\\\\geq 2$ 的正整數 $N$，請輸出所有 $[1,N]$ 之間的質數。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/100/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$2 \\\\leq N \\\\leq 10^ 6$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1713/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給 $n$ 個數 $x$，求每個 $x$ 的因數數量。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1713/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq x \\\\leq 10^6$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b430/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給 $a,b,n$，求 $ab \\\\bmod n$。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b430/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"有多筆測資\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 \\\\leq a,b \\\\leq 10^{18}$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 10^{18}$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"prereqs":[{"code":"BasicAlgorithm/math_in_school","text":"基礎演算法 / 學校教的數學"}],"sections":[{"text":"模運算","depth":1,"code":"0.1"},{"text":"C++ 中的除法與模運算","depth":2,"code":"0.1.1"},{"text":"同餘與模下的運算","depth":2,"code":"0.1.2"},{"text":"運算過程取模","depth":2,"code":"0.1.3"},{"text":"除法很慢","depth":2,"code":"0.1.4"},{"text":"快速冪","depth":1,"code":"0.2"},{"text":"輾轉相除法","depth":1,"code":"0.3"},{"text":"質數篩法","depth":1,"code":"0.4"},{"text":"習題","depth":1,"code":"0.5"}],"previousArticle":{"code":"BasicDataStructure/iterator","topicCode":"BasicDataStructure","articleCode":"iterator","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Iterator","articleDisplayTitle":"Iterator","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/iterator","topic":"BasicDataStructure","article":"iterator","title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/intro"]}},"nextArticle":null,"virtualArticle":{"code":"BasicMath/basicalgo","topicCode":"BasicMath","articleCode":"basicalgo","chapterCode":"III","fullDisplayTitle":"基礎數學 / 常用數學演算法","articleDisplayTitle":"常用數學演算法","topicDisplayTitle":"基礎數學","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicMath/basicalgo","topic":"BasicMath","article":"basicalgo","title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"description":"一些不太難的數學","prerequisites":["BasicAlgorithm/math_in_school"]}},"topicStructure":[{"single":true,"title":"","topics":[{"code":"Guide","displayTitle":"網站簡介","articles":[{"code":"Guide/learning","topicCode":"Guide","articleCode":"learning","chapterCode":"I","fullDisplayTitle":"網站簡介 / 服用方法","articleDisplayTitle":"服用方法","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/learning","topic":"Guide","article":"learning","title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"description":"教大家怎麼看這份講義","prerequisites":[]}},{"code":"Guide/chapters","topicCode":"Guide","articleCode":"chapters","chapterCode":"I","fullDisplayTitle":"網站簡介 / 章節與主題","articleDisplayTitle":"章節與主題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/chapters","topic":"Guide","article":"chapters","title":"章節與主題","authors":["baluteshih"],"contributors":[],"description":"教大家什麼是章節與主題","prerequisites":["Guide/learning"]}},{"code":"Guide/problems","topicCode":"Guide","articleCode":"problems","chapterCode":"I","fullDisplayTitle":"網站簡介 / 習題","articleDisplayTitle":"習題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/problems","topic":"Guide","article":"problems","title":"習題","authors":["baluteshih"],"contributors":[],"description":"教大家這份講義的習題意義","prerequisites":["Guide/learning"]}},{"code":"Guide/math_symbol","topicCode":"Guide","articleCode":"math_symbol","chapterCode":"I","fullDisplayTitle":"網站簡介 / 基本數學符號","articleDisplayTitle":"基本數學符號","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/math_symbol","topic":"Guide","article":"math_symbol","title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"description":"介紹常見的數學符號","prerequisites":[]}},{"code":"Guide/language","topicCode":"Guide","articleCode":"language","chapterCode":"I","fullDisplayTitle":"網站簡介 / 語法學習資源","articleDisplayTitle":"語法學習資源","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/language","topic":"Guide","article":"language","title":"語法學習資源","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Guide/qa","topicCode":"Guide","articleCode":"qa","chapterCode":"I","fullDisplayTitle":"網站簡介 / NTUCPC Guide Q & A","articleDisplayTitle":"NTUCPC Guide Q & A","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/qa","topic":"Guide","article":"qa","title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":[]}}]}]},{"single":true,"title":"","topics":[{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/competitive_programming","topicCode":"Introduction","articleCode":"competitive_programming","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 資訊競賽介紹","articleDisplayTitle":"資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/competitive_programming","topic":"Introduction","article":"competitive_programming","title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Introduction/contests_type","topicCode":"Introduction","articleCode":"contests_type","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 比賽類型","articleDisplayTitle":"比賽類型","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/contests_type","topic":"Introduction","article":"contests_type","title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tw_contests","topicCode":"Introduction","articleCode":"tw_contests","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 台灣資訊競賽介紹","articleDisplayTitle":"台灣資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/tw_contests","topic":"Introduction","article":"tw_contests","title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}},{"code":"Introduction/online_judge","topicCode":"Introduction","articleCode":"online_judge","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 線上評測系統","articleDisplayTitle":"線上評測系統","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/online_judge","topic":"Introduction","article":"online_judge","title":"線上評測系統","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/resources","topicCode":"Introduction","articleCode":"resources","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 網路學習資源介紹","articleDisplayTitle":"網路學習資源介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/resources","topic":"Introduction","article":"resources","title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tactics","topicCode":"Introduction","articleCode":"tactics","chapterCode":"III","fullDisplayTitle":"資訊競賽介紹 / 比賽 + 練習策略","articleDisplayTitle":"比賽 + 練習策略","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"Introduction/tactics","topic":"Introduction","article":"tactics","title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}}]}]},{"single":true,"title":"","topics":[{"code":"Implementation","displayTitle":"實作技巧","articles":[{"code":"Implementation/basic_knowledge","topicCode":"Implementation","articleCode":"basic_knowledge","chapterCode":"II","fullDisplayTitle":"實作技巧 / 基本常識","articleDisplayTitle":"基本常識","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/basic_knowledge","topic":"Implementation","article":"basic_knowledge","title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"description":"講述一些競賽程式需要知道的最基本常識","prerequisites":["Introduction/online_judge"]}},{"code":"Implementation/input","topicCode":"Implementation","articleCode":"input","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見輸入類型","articleDisplayTitle":"常見輸入類型","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/input","topic":"Implementation","article":"input","title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的輸入格式","prerequisites":["Implementation/basic_knowledge"]}},{"code":"Implementation/reference","topicCode":"Implementation","articleCode":"reference","chapterCode":"II","fullDisplayTitle":"實作技巧 / Reference","articleDisplayTitle":"Reference","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/reference","topic":"Implementation","article":"reference","title":"Reference","authors":["baluteshih"],"contributors":[],"description":"Reference","prerequisites":[]}},{"code":"Implementation/compiler","topicCode":"Implementation","articleCode":"compiler","chapterCode":"II","fullDisplayTitle":"實作技巧 / 編譯器","articleDisplayTitle":"編譯器","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/compiler","topic":"Implementation","article":"compiler","title":"編譯器","authors":["WiwiHo"],"contributors":[],"description":"簡單介紹什麼是編譯器","prerequisites":[]}},{"code":"Implementation/error_message","topicCode":"Implementation","articleCode":"error_message","chapterCode":"II","fullDisplayTitle":"實作技巧 / 如何看錯誤訊息","articleDisplayTitle":"如何看錯誤訊息","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/error_message","topic":"Implementation","article":"error_message","title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"description":"介紹一些常見錯誤訊息的看法","prerequisites":["Implementation/compiler"]}},{"code":"Implementation/variable","topicCode":"Implementation","articleCode":"variable","chapterCode":"II","fullDisplayTitle":"實作技巧 / 全域、區域變數","articleDisplayTitle":"全域、區域變數","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/variable","topic":"Implementation","article":"variable","title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"description":"各種全域區域變數相關的事情","prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"]}},{"code":"Implementation/buglist","topicCode":"Implementation","articleCode":"buglist","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見錯誤列表","articleDisplayTitle":"常見錯誤列表","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/buglist","topic":"Implementation","article":"buglist","title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的錯誤","prerequisites":["Implementation/variable"]}},{"code":"Implementation/debug","topicCode":"Implementation","articleCode":"debug","chapterCode":null,"fullDisplayTitle":"實作技巧 / Debug","articleDisplayTitle":"Debug","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter ???","article":{"code":"Implementation/debug","topic":"Implementation","article":"debug","title":"Debug","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Implementation/buglist"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/intro","topicCode":"BasicAlgorithm","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/intro","topic":"BasicAlgorithm","article":"intro","title":"介紹","authors":["double"],"contributors":[],"description":"簡單介紹何謂演算法","prerequisites":["Introduction/competitive_programming"]}},{"code":"BasicAlgorithm/complexity","topicCode":"BasicAlgorithm","articleCode":"complexity","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 複雜度","articleDisplayTitle":"複雜度","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/complexity","topic":"BasicAlgorithm","article":"complexity","title":"複雜度","authors":["chengbilly92"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/sorting","topicCode":"BasicAlgorithm","articleCode":"sorting","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 排序演算法","articleDisplayTitle":"排序演算法","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/sorting","topic":"BasicAlgorithm","article":"sorting","title":"排序演算法","authors":["baluteshih"],"contributors":[],"description":"簡單介紹基本的排序演算法（O(n^2), counting sort 跟 radix sort）","prerequisites":["BasicAlgorithm/complexity"]}},{"code":"BasicAlgorithm/algorithm_numeric","topicCode":"BasicAlgorithm","articleCode":"algorithm_numeric","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 標準函式庫 ── <algorithm> 與 <numeric>","articleDisplayTitle":"標準函式庫 ── <algorithm> 與 <numeric>","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/algorithm_numeric","topic":"BasicAlgorithm","article":"algorithm_numeric","title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"description":"介紹 STL <algorithm> 和 <numeric> 裡的幾個常用函式","prerequisites":["BasicAlgorithm/sorting"]}},{"code":"BasicAlgorithm/enumerate","topicCode":"BasicAlgorithm","articleCode":"enumerate","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 枚舉","articleDisplayTitle":"枚舉","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/enumerate","topic":"BasicAlgorithm","article":"enumerate","title":"枚舉","authors":["WiwiHo"],"contributors":[],"description":"簡單的枚舉技巧，不包含遞迴","prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/searching","topicCode":"BasicAlgorithm","articleCode":"searching","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 搜尋","articleDisplayTitle":"搜尋","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/searching","topic":"BasicAlgorithm","article":"searching","title":"搜尋","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/math_in_school","topicCode":"BasicAlgorithm","articleCode":"math_in_school","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 學校教的數學","articleDisplayTitle":"學校教的數學","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/math_in_school","topic":"BasicAlgorithm","article":"math_in_school","title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"description":"一些和基礎演算法設計技巧有關的課綱內數學問題，引導讀者從基礎數學發現演算法，並且訓練把人腦作法轉換成演算法的能力。","prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/recursion","topicCode":"BasicAlgorithm","articleCode":"recursion","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 遞迴","articleDisplayTitle":"遞迴","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/recursion","topic":"BasicAlgorithm","article":"recursion","title":"遞迴","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/partial_sum","topicCode":"BasicAlgorithm","articleCode":"partial_sum","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 前綴和與差分","articleDisplayTitle":"前綴和與差分","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/partial_sum","topic":"BasicAlgorithm","article":"partial_sum","title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/two_pointers","topicCode":"BasicAlgorithm","articleCode":"two_pointers","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 雙指標","articleDisplayTitle":"雙指標","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/two_pointers","topic":"BasicAlgorithm","article":"two_pointers","title":"雙指標","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/binary_search_answer","topicCode":"BasicAlgorithm","articleCode":"binary_search_answer","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 對答案二分搜","articleDisplayTitle":"對答案二分搜","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/binary_search_answer","topic":"BasicAlgorithm","article":"binary_search_answer","title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"description":"","prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"]}}]}]},{"single":true,"title":"","topics":[{"code":"GreedyAlgorithm","displayTitle":"貪心演算法","articles":[{"code":"GreedyAlgorithm/intuitive_greedy","topicCode":"GreedyAlgorithm","articleCode":"intuitive_greedy","chapterCode":"II","fullDisplayTitle":"貪心演算法 / 貪心法 I","articleDisplayTitle":"貪心法 I","topicDisplayTitle":"貪心演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"GreedyAlgorithm/intuitive_greedy","topic":"GreedyAlgorithm","article":"intuitive_greedy","title":"貪心法 I","authors":["baluteshih"],"contributors":[],"description":"生活中直覺的貪心題目","prerequisites":["BasicAlgorithm/algorithm_numeric"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/intro","topicCode":"BasicDataStructure","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/intro","topic":"BasicDataStructure","article":"intro","title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"description":"簡單介紹資料結構的概念","prerequisites":["Implementation/basic_knowledge"]}},{"code":"BasicDataStructure/vector","topicCode":"BasicDataStructure","articleCode":"vector","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 動態的陣列","articleDisplayTitle":"動態的陣列","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/vector","topic":"BasicDataStructure","article":"vector","title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicDataStructure/stack_queue_deque","topicCode":"BasicDataStructure","articleCode":"stack_queue_deque","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Stack、Queue 與 Deque","articleDisplayTitle":"Stack、Queue 與 Deque","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/stack_queue_deque","topic":"BasicDataStructure","article":"stack_queue_deque","title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/linked_list","topicCode":"BasicDataStructure","articleCode":"linked_list","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Linked List","articleDisplayTitle":"Linked List","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/linked_list","topic":"BasicDataStructure","article":"linked_list","title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/binary_tree","topicCode":"BasicDataStructure","articleCode":"binary_tree","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / 二元樹","articleDisplayTitle":"二元樹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/binary_tree","topic":"BasicDataStructure","article":"binary_tree","title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/linked_list","Implementation/reference"]}},{"code":"BasicDataStructure/heap","topicCode":"BasicDataStructure","articleCode":"heap","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Heap","articleDisplayTitle":"Heap","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/heap","topic":"BasicDataStructure","article":"heap","title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}},{"code":"BasicDataStructure/set_map","topicCode":"BasicDataStructure","articleCode":"set_map","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Set 與 Map","articleDisplayTitle":"Set 與 Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/set_map","topic":"BasicDataStructure","article":"set_map","title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/heap"]}},{"code":"BasicDataStructure/unordered","topicCode":"BasicDataStructure","articleCode":"unordered","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Unordered Set 與 Unordered Map","articleDisplayTitle":"Unordered Set 與 Unordered Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/unordered","topic":"BasicDataStructure","article":"unordered","title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/set_map"]}},{"code":"BasicDataStructure/iterator","topicCode":"BasicDataStructure","articleCode":"iterator","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Iterator","articleDisplayTitle":"Iterator","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/iterator","topic":"BasicDataStructure","article":"iterator","title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/intro"]}},{"code":"BasicDataStructure/binary_tree_and_stack","topicCode":"BasicDataStructure","articleCode":"binary_tree_and_stack","chapterCode":null,"fullDisplayTitle":"基礎資料結構 / 二元樹與 Stack","articleDisplayTitle":"二元樹與 Stack","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter ???","article":{"code":"BasicDataStructure/binary_tree_and_stack","topic":"BasicDataStructure","article":"binary_tree_and_stack","title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicMath","displayTitle":"基礎數學","articles":[{"code":"BasicMath/basicalgo","topicCode":"BasicMath","articleCode":"basicalgo","chapterCode":"III","fullDisplayTitle":"基礎數學 / 常用數學演算法","articleDisplayTitle":"常用數學演算法","topicDisplayTitle":"基礎數學","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicMath/basicalgo","topic":"BasicMath","article":"basicalgo","title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"description":"一些不太難的數學","prerequisites":["BasicAlgorithm/math_in_school"]}}]}]}],"chapterStructure":[{"code":"I","displayTitle":"Chapter I. 初來乍到","topics":[{"code":"Guide","displayTitle":"網站簡介","articles":[{"code":"Guide/learning","topicCode":"Guide","articleCode":"learning","chapterCode":"I","fullDisplayTitle":"網站簡介 / 服用方法","articleDisplayTitle":"服用方法","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/learning","topic":"Guide","article":"learning","title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"description":"教大家怎麼看這份講義","prerequisites":[]}},{"code":"Guide/chapters","topicCode":"Guide","articleCode":"chapters","chapterCode":"I","fullDisplayTitle":"網站簡介 / 章節與主題","articleDisplayTitle":"章節與主題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/chapters","topic":"Guide","article":"chapters","title":"章節與主題","authors":["baluteshih"],"contributors":[],"description":"教大家什麼是章節與主題","prerequisites":["Guide/learning"]}},{"code":"Guide/problems","topicCode":"Guide","articleCode":"problems","chapterCode":"I","fullDisplayTitle":"網站簡介 / 習題","articleDisplayTitle":"習題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/problems","topic":"Guide","article":"problems","title":"習題","authors":["baluteshih"],"contributors":[],"description":"教大家這份講義的習題意義","prerequisites":["Guide/learning"]}},{"code":"Guide/math_symbol","topicCode":"Guide","articleCode":"math_symbol","chapterCode":"I","fullDisplayTitle":"網站簡介 / 基本數學符號","articleDisplayTitle":"基本數學符號","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/math_symbol","topic":"Guide","article":"math_symbol","title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"description":"介紹常見的數學符號","prerequisites":[]}},{"code":"Guide/language","topicCode":"Guide","articleCode":"language","chapterCode":"I","fullDisplayTitle":"網站簡介 / 語法學習資源","articleDisplayTitle":"語法學習資源","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/language","topic":"Guide","article":"language","title":"語法學習資源","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Guide/qa","topicCode":"Guide","articleCode":"qa","chapterCode":"I","fullDisplayTitle":"網站簡介 / NTUCPC Guide Q & A","articleDisplayTitle":"NTUCPC Guide Q & A","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/qa","topic":"Guide","article":"qa","title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":[]}}]},{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/competitive_programming","topicCode":"Introduction","articleCode":"competitive_programming","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 資訊競賽介紹","articleDisplayTitle":"資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/competitive_programming","topic":"Introduction","article":"competitive_programming","title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Introduction/contests_type","topicCode":"Introduction","articleCode":"contests_type","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 比賽類型","articleDisplayTitle":"比賽類型","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/contests_type","topic":"Introduction","article":"contests_type","title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tw_contests","topicCode":"Introduction","articleCode":"tw_contests","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 台灣資訊競賽介紹","articleDisplayTitle":"台灣資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/tw_contests","topic":"Introduction","article":"tw_contests","title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}},{"code":"Introduction/online_judge","topicCode":"Introduction","articleCode":"online_judge","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 線上評測系統","articleDisplayTitle":"線上評測系統","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/online_judge","topic":"Introduction","article":"online_judge","title":"線上評測系統","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/resources","topicCode":"Introduction","articleCode":"resources","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 網路學習資源介紹","articleDisplayTitle":"網路學習資源介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/resources","topic":"Introduction","article":"resources","title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}}]}]},{"code":"II","displayTitle":"Chapter II. 新手上路","topics":[{"code":"Implementation","displayTitle":"實作技巧","articles":[{"code":"Implementation/basic_knowledge","topicCode":"Implementation","articleCode":"basic_knowledge","chapterCode":"II","fullDisplayTitle":"實作技巧 / 基本常識","articleDisplayTitle":"基本常識","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/basic_knowledge","topic":"Implementation","article":"basic_knowledge","title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"description":"講述一些競賽程式需要知道的最基本常識","prerequisites":["Introduction/online_judge"]}},{"code":"Implementation/input","topicCode":"Implementation","articleCode":"input","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見輸入類型","articleDisplayTitle":"常見輸入類型","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/input","topic":"Implementation","article":"input","title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的輸入格式","prerequisites":["Implementation/basic_knowledge"]}},{"code":"Implementation/reference","topicCode":"Implementation","articleCode":"reference","chapterCode":"II","fullDisplayTitle":"實作技巧 / Reference","articleDisplayTitle":"Reference","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/reference","topic":"Implementation","article":"reference","title":"Reference","authors":["baluteshih"],"contributors":[],"description":"Reference","prerequisites":[]}},{"code":"Implementation/compiler","topicCode":"Implementation","articleCode":"compiler","chapterCode":"II","fullDisplayTitle":"實作技巧 / 編譯器","articleDisplayTitle":"編譯器","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/compiler","topic":"Implementation","article":"compiler","title":"編譯器","authors":["WiwiHo"],"contributors":[],"description":"簡單介紹什麼是編譯器","prerequisites":[]}},{"code":"Implementation/error_message","topicCode":"Implementation","articleCode":"error_message","chapterCode":"II","fullDisplayTitle":"實作技巧 / 如何看錯誤訊息","articleDisplayTitle":"如何看錯誤訊息","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/error_message","topic":"Implementation","article":"error_message","title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"description":"介紹一些常見錯誤訊息的看法","prerequisites":["Implementation/compiler"]}},{"code":"Implementation/variable","topicCode":"Implementation","articleCode":"variable","chapterCode":"II","fullDisplayTitle":"實作技巧 / 全域、區域變數","articleDisplayTitle":"全域、區域變數","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/variable","topic":"Implementation","article":"variable","title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"description":"各種全域區域變數相關的事情","prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"]}},{"code":"Implementation/buglist","topicCode":"Implementation","articleCode":"buglist","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見錯誤列表","articleDisplayTitle":"常見錯誤列表","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/buglist","topic":"Implementation","article":"buglist","title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的錯誤","prerequisites":["Implementation/variable"]}}]},{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/intro","topicCode":"BasicAlgorithm","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/intro","topic":"BasicAlgorithm","article":"intro","title":"介紹","authors":["double"],"contributors":[],"description":"簡單介紹何謂演算法","prerequisites":["Introduction/competitive_programming"]}},{"code":"BasicAlgorithm/complexity","topicCode":"BasicAlgorithm","articleCode":"complexity","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 複雜度","articleDisplayTitle":"複雜度","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/complexity","topic":"BasicAlgorithm","article":"complexity","title":"複雜度","authors":["chengbilly92"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/sorting","topicCode":"BasicAlgorithm","articleCode":"sorting","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 排序演算法","articleDisplayTitle":"排序演算法","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/sorting","topic":"BasicAlgorithm","article":"sorting","title":"排序演算法","authors":["baluteshih"],"contributors":[],"description":"簡單介紹基本的排序演算法（O(n^2), counting sort 跟 radix sort）","prerequisites":["BasicAlgorithm/complexity"]}},{"code":"BasicAlgorithm/algorithm_numeric","topicCode":"BasicAlgorithm","articleCode":"algorithm_numeric","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 標準函式庫 ── <algorithm> 與 <numeric>","articleDisplayTitle":"標準函式庫 ── <algorithm> 與 <numeric>","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/algorithm_numeric","topic":"BasicAlgorithm","article":"algorithm_numeric","title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"description":"介紹 STL <algorithm> 和 <numeric> 裡的幾個常用函式","prerequisites":["BasicAlgorithm/sorting"]}},{"code":"BasicAlgorithm/enumerate","topicCode":"BasicAlgorithm","articleCode":"enumerate","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 枚舉","articleDisplayTitle":"枚舉","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/enumerate","topic":"BasicAlgorithm","article":"enumerate","title":"枚舉","authors":["WiwiHo"],"contributors":[],"description":"簡單的枚舉技巧，不包含遞迴","prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/searching","topicCode":"BasicAlgorithm","articleCode":"searching","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 搜尋","articleDisplayTitle":"搜尋","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/searching","topic":"BasicAlgorithm","article":"searching","title":"搜尋","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/math_in_school","topicCode":"BasicAlgorithm","articleCode":"math_in_school","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 學校教的數學","articleDisplayTitle":"學校教的數學","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/math_in_school","topic":"BasicAlgorithm","article":"math_in_school","title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"description":"一些和基礎演算法設計技巧有關的課綱內數學問題，引導讀者從基礎數學發現演算法，並且訓練把人腦作法轉換成演算法的能力。","prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"]}}]},{"code":"GreedyAlgorithm","displayTitle":"貪心演算法","articles":[{"code":"GreedyAlgorithm/intuitive_greedy","topicCode":"GreedyAlgorithm","articleCode":"intuitive_greedy","chapterCode":"II","fullDisplayTitle":"貪心演算法 / 貪心法 I","articleDisplayTitle":"貪心法 I","topicDisplayTitle":"貪心演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"GreedyAlgorithm/intuitive_greedy","topic":"GreedyAlgorithm","article":"intuitive_greedy","title":"貪心法 I","authors":["baluteshih"],"contributors":[],"description":"生活中直覺的貪心題目","prerequisites":["BasicAlgorithm/algorithm_numeric"]}}]},{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/intro","topicCode":"BasicDataStructure","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/intro","topic":"BasicDataStructure","article":"intro","title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"description":"簡單介紹資料結構的概念","prerequisites":["Implementation/basic_knowledge"]}},{"code":"BasicDataStructure/vector","topicCode":"BasicDataStructure","articleCode":"vector","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 動態的陣列","articleDisplayTitle":"動態的陣列","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/vector","topic":"BasicDataStructure","article":"vector","title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicDataStructure/stack_queue_deque","topicCode":"BasicDataStructure","articleCode":"stack_queue_deque","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Stack、Queue 與 Deque","articleDisplayTitle":"Stack、Queue 與 Deque","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/stack_queue_deque","topic":"BasicDataStructure","article":"stack_queue_deque","title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/linked_list","topicCode":"BasicDataStructure","articleCode":"linked_list","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Linked List","articleDisplayTitle":"Linked List","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/linked_list","topic":"BasicDataStructure","article":"linked_list","title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}}]}]},{"code":"III","displayTitle":"Chapter III. 漸入佳境","topics":[{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/tactics","topicCode":"Introduction","articleCode":"tactics","chapterCode":"III","fullDisplayTitle":"資訊競賽介紹 / 比賽 + 練習策略","articleDisplayTitle":"比賽 + 練習策略","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"Introduction/tactics","topic":"Introduction","article":"tactics","title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}}]},{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/recursion","topicCode":"BasicAlgorithm","articleCode":"recursion","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 遞迴","articleDisplayTitle":"遞迴","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/recursion","topic":"BasicAlgorithm","article":"recursion","title":"遞迴","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/partial_sum","topicCode":"BasicAlgorithm","articleCode":"partial_sum","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 前綴和與差分","articleDisplayTitle":"前綴和與差分","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/partial_sum","topic":"BasicAlgorithm","article":"partial_sum","title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/two_pointers","topicCode":"BasicAlgorithm","articleCode":"two_pointers","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 雙指標","articleDisplayTitle":"雙指標","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/two_pointers","topic":"BasicAlgorithm","article":"two_pointers","title":"雙指標","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/binary_search_answer","topicCode":"BasicAlgorithm","articleCode":"binary_search_answer","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 對答案二分搜","articleDisplayTitle":"對答案二分搜","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/binary_search_answer","topic":"BasicAlgorithm","article":"binary_search_answer","title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"description":"","prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"]}}]},{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/binary_tree","topicCode":"BasicDataStructure","articleCode":"binary_tree","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / 二元樹","articleDisplayTitle":"二元樹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/binary_tree","topic":"BasicDataStructure","article":"binary_tree","title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/linked_list","Implementation/reference"]}},{"code":"BasicDataStructure/heap","topicCode":"BasicDataStructure","articleCode":"heap","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Heap","articleDisplayTitle":"Heap","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/heap","topic":"BasicDataStructure","article":"heap","title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}},{"code":"BasicDataStructure/set_map","topicCode":"BasicDataStructure","articleCode":"set_map","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Set 與 Map","articleDisplayTitle":"Set 與 Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/set_map","topic":"BasicDataStructure","article":"set_map","title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/heap"]}},{"code":"BasicDataStructure/unordered","topicCode":"BasicDataStructure","articleCode":"unordered","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Unordered Set 與 Unordered Map","articleDisplayTitle":"Unordered Set 與 Unordered Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/unordered","topic":"BasicDataStructure","article":"unordered","title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/set_map"]}},{"code":"BasicDataStructure/iterator","topicCode":"BasicDataStructure","articleCode":"iterator","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Iterator","articleDisplayTitle":"Iterator","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/iterator","topic":"BasicDataStructure","article":"iterator","title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/intro"]}}]},{"code":"BasicMath","displayTitle":"基礎數學","articles":[{"code":"BasicMath/basicalgo","topicCode":"BasicMath","articleCode":"basicalgo","chapterCode":"III","fullDisplayTitle":"基礎數學 / 常用數學演算法","articleDisplayTitle":"常用數學演算法","topicDisplayTitle":"基礎數學","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicMath/basicalgo","topic":"BasicMath","article":"basicalgo","title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"description":"一些不太難的數學","prerequisites":["BasicAlgorithm/math_in_school"]}}]}]}]}},"__N_SSG":true}