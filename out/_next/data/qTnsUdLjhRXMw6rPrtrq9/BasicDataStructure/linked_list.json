{"pageProps":{"props":{"mdxPath":"guide/content/BasicDataStructure/linked_list/linked_list.mdx","content":[["guide/content/BasicDataStructure/linked_list/linked_list.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    h4: \"h4\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Figure, Info, Problem, Refcode} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      id: \"section-0.1\",\n      children: \"鏈結串列（Linked List）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在一般的陣列裡面，每個東西會放在一個有編號的格子裡。但如果我們想要在陣列中間插入某個東西，或是把一段陣列平移到別的地方的話，可能會需要更有彈性的資料結構。此時，Linked List 就是一個合適的選擇。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在假設我們在玩一個遊戲：每一個人都要指一個人，那要怎麼紀錄這種關係呢？將每一個人想成一個東西，裡面包著自己的值和指向的人！這就是 Linked List 的精神。如下圖：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicDataStructure/linked_list/figure/linked_list-1.png\",\n      width: \"600\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這裡，蕭梓宏指向王政祺，王政祺指向林尚廷……直到劉至軒停止。用資訊的術語來講，每一個東西稱作一個\", _jsx(_components.strong, {\n        children: \"節點（node）\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.1.1\",\n      children: \"雙向串列（Doubly Linked List）\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有時候，會有人想要知道是誰指向自己，就會再維護一個指標指向「指向自己的那個人」，圖形大概長這樣：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicDataStructure/linked_list/figure/linked_list-2.png\",\n      width: \"600\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"作法就是：當 A 連到 B 的時候，將 A 指向的人設為 B，而 B 的被指的人設為 A。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"了解作法之後，就來看看如何實作吧！\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.1.2\",\n      children: \"實作時間\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"經典題\",\n      name: \"實作噩夢之 linked list 篇\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/linked_list_practice/description.mdx\",\n      constraintsMdx: \"guide/problems/Misc/linked_list_practice/constraints.mdx\",\n      importMdx: \"guide/problems/Misc/linked_list_practice/description.mdx\",\n      importMdx: \"guide/problems/Misc/linked_list_practice/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們一步步看要怎麼支援每個操作：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先，我們假設每個節點可以直接用他的編號讀取，並把所需要存取的資料宣告成陣列，再寫好一個初始化用的函式：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int prev_node[maxn]; // 上一個節點編號\\nint next_node[maxn]; // 下一個節點編號\\nint is_inserted[maxn]; // 節點是否在 linked list 裡面\\n\\n// 初始化節點 x\\nvoid Init(int x, int prv, int nxt, int inserted) {\\n    prev_node[x] = prv;\\n    next_node[x] = nxt;\\n    is_inserted[x] = inserted;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其中 \", _jsx(_components.code, {\n        children: \"prev_node\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"next_node\"\n      }), \" 就是這個節點指向的前一個/後一個人。但如果前一項或後一項不存在時怎麼辦？這裡我們可以使用一個聰明的小技巧，可以發現題目並不會用到 $0$ 這個編號，所以不如就把 $0$ 當作不存在的象徵。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"同時，我們還可以刻意讓陣列中 $0$ 的位置存上有關於頭尾的資訊，讀者也可以想像成我們把 linked list 變成這種樣子：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicDataStructure/linked_list/figure/linked_list-3.png\",\n      width: \"600\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也就是製造一個假想節點在頭尾！這樣就可以省下不少方便的判斷了，讀者可以透過後面的實作來感受其簡潔性。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"    // 刻意使用一點小聰明，讓節點編號 0 同時當作頭尾\\n    Init(0, 0, 0, 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下來讓我們看看插入操作的細節。當我們要在節點 $a$ 後插入一個點 $n$ 時，原本 $a$ 跟 $a$ 的下一項中間的連結會被斷開，然後我們要把中間的連跟這兩個點各自連接。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"// 在節點 x 之後插入 id 的節點\\nvoid Insert(int x, int id) {\\n    int nxt = next_node[x];\\n    Init(id, x, nxt, 1);\\n    prev_node[nxt] = id;\\n    next_node[x] = id;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"刪除也是類似，就是變成反過來把 $a$ 的前一項和下一項連結回來。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"// 刪除節點 x\\nvoid Delete(int x) {\\n    int prv = prev_node[x];\\n    int nxt = next_node[x];\\n    is_inserted[x] = 0;\\n    next_node[prv] = nxt;\\n    prev_node[nxt] = prv;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"至於要怎麼在節點 $a$ 前面插入節點呢？這裡不用再重新實作一個新的函式，可以直接想成是「在節點 $a$ 的上一個節點」後面插入節點！類似的想法也可以套用到插入頭尾的操作，只要好好思考假想節點 $0$ 的概念就好。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下附上完整的實作，讀者可以多加反思：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <iostream>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\nint prev_node[maxn]; // 上一個節點編號\\nint next_node[maxn]; // 下一個節點編號\\nint is_inserted[maxn]; // 節點是否在 linked list 裡面\\n\\n// 初始化節點 x\\nvoid Init(int x, int prv, int nxt, int inserted) {\\n    prev_node[x] = prv;\\n    next_node[x] = nxt;\\n    is_inserted[x] = inserted;\\n}\\n\\n// 在節點 x 之後插入 id 的節點\\nvoid Insert(int x, int id) {\\n    int nxt = next_node[x];\\n    Init(id, x, nxt, 1);\\n    prev_node[nxt] = id;\\n    next_node[x] = id;\\n}\\n\\n// 刪除節點 x\\nvoid Delete(int x) {\\n    int prv = prev_node[x];\\n    int nxt = next_node[x];\\n    is_inserted[x] = 0;\\n    next_node[prv] = nxt;\\n    prev_node[nxt] = prv;\\n}\\n\\nint main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    // 刻意使用一點小聰明，讓節點編號 0 同時當作頭尾\\n    Init(0, 0, 0, 1);\\n    int m;\\n    cin >> m;\\n    while (m--) {\\n        int op;\\n        cin >> op;\\n        if (op == 1) {\\n            int n;\\n            cin >> n;\\n            Insert(0, n);\\n        }\\n        else if (op == 2) {\\n            int n;\\n            cin >> n;\\n            Insert(prev_node[0], n);\\n        }\\n        else if (op == 3) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (!is_inserted[a])\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                Insert(prev_node[a], n);\\n        }\\n        else if (op == 4) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (!is_inserted[a])\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                Insert(a, n);\\n        }\\n        else if (op == 5) {\\n            int a;\\n            cin >> a;\\n            if (!is_inserted[a]) \\n                cout << \\\"peko\\\\n\\\";\\n            else if (prev_node[a] == 0)\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << prev_node[a] << \\\"\\\\n\\\";\\n        }\\n        else if (op == 6) {\\n            int a;\\n            cin >> a;\\n            if (!is_inserted[a]) \\n                cout << \\\"peko\\\\n\\\";\\n            else if (next_node[a] == 0)\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << next_node[a] << \\\"\\\\n\\\";\\n        }\\n        else if (op == 7) {\\n            int a;\\n            cin >> a;\\n            if (!is_inserted[a])\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                Delete(a);\\n        }\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"Linked list 的使用時機：\", _jsx(_components.br, {}), \"\\n\", \"當題目出現「在某個位置插入/刪除元素」，或者是把一段區間的元素移動/反轉的操作，可能就是 Linked List 出場的時間。\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"section-0.2\",\n      children: \"STL\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"STL 也為 linked list 設計了一個容器適配器，不過由於 linked list 的操作較為複雜，有許多操作需要跟\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicDataStructure/iterator\",\n        mode: \"article\",\n        topicTitle: \"基礎資料結構\",\n        articleTitle: \"Iterator\"\n      }), \"有一定的熟悉度，建議讀者先有基本的認知再閱讀這個小節。以下是 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 的宣告方法。\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"list<int> lst; // // 宣告一個儲存 int 型別的 list\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"list\"\n      }), \" 是放在 \", _jsx(_components.code, {\n        children: \"<list>\"\n      }), \" 標頭檔內，使用前記得引入。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.2.1\",\n      children: \"STL linked list 操作\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"push_back()\"\n        }), \" 可以將資料放入 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 尾端；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"pop_back()\"\n        }), \" 將 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 尾端的元素刪除\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"push_front()\"\n        }), \" 可以將資料放入 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 前端；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"pop_front()\"\n        }), \" 將 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 前端的元素刪除\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"front()\"\n        }), \" 查詢 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 前端元素\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"back()\"\n        }), \" 查詢 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 後端元素\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"insert()\"\n        }), \" 可以插入元素在一個 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 內的 \", _jsx(_components.code, {\n          children: \"iterator\"\n        }), \" 的\", _jsx(_components.strong, {\n          children: \"前方\"\n        }), \"；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"size()\"\n        }), \" 查詢目前還位於 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 的資料數；\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"empty()\"\n        }), \" 回傳 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 是否為空。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"splice()\"\n        }), \" 可以在 $O(1)$ 時間內將一個 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 串接另一個 \", _jsx(_components.code, {\n          children: \"list\"\n        }), \" 的任何位置\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"list<int> lsta, lstb;\\nlsta.push_back(3); // a: [3], b: []\\nlsta.push_back(1); // a: [3, 1], b: []\\nlsta.push_front(2); // a: [2, 3, 1], b: []\\nlsta.pop_back(); // a: [2, 3], b: []\\nlsta.pop_front(); // a: [3], b: []\\nlsta.push_front(1); // a: [1, 3], b: []\\nlstb.push_front(4); // a: [1, 3], b: [4]\\nlstb.push_back(5); // a: [1, 3], b: [4, 5]\\nlsta.splice(next(lsta.begin()), lstb); // a: [1, 4, 5, 3], b: []\\ncout << lsta.front() << endl; // 1\\ncout << lsta.back() << endl; // 3\\ncout << lstb.size() << endl; // 0\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過這樣似乎衍伸了一些問題：\"\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"section-0.2.1.1\",\n      children: [\"沒有 \", _jsx(_components.code, {\n        children: \"prev\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"next\"\n      }), \" 操作嗎？\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 STL \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 的世界中，存取單一節點資訊除了頭尾外，幾乎都是使用該節點的 iterator 來進行存取，在拿到 iteartor 後，就可以呼叫 iterator 的通用函式 \", _jsx(_components.code, {\n        children: \"prev()\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"next()\"\n      }), \" 來獲得資料。而若要獲得一個 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 的頭尾節點本身，使用 \", _jsx(_components.code, {\n        children: \"begin()\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"--end()\"\n      }), \" 即可。\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      id: \"section-0.2.1.2\",\n      children: \"要怎麼像前面例題一樣存取編號 $a$ 的節點呢？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這裡就需要使用一些慣用手法，一種常見的做法便是「儲存節點的 iterator」，直接宣告一個陣列來儲存每個節點在 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 內的位置，這樣就可以直接戳出想要的位置了！\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"下面這份程式碼使用 STL 實作出了前面的例題，讀者可以比對著研究看看。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <iostream>\\n#include <list>\\nusing namespace std;\\n\\nconst int maxn = 100005;\\n\\n// 用來紀錄每個節點對應在 lst 內的位置\\nlist<int>::iterator node_it[maxn];\\n\\nint main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    list<int> lst;\\n    // 在所有節點都尚未插入的情況下，初始化每個節點的位置為不存在的 lst.end()\\n    for (int i = 0; i < maxn; ++i)\\n        node_it[i] = lst.end();\\n    int m;\\n    cin >> m;\\n    while (m--) {\\n        int op;\\n        cin >> op;\\n        if (op == 1) {\\n            int n;\\n            cin >> n;\\n            lst.push_front(n);\\n            node_it[n] = lst.begin();\\n        }\\n        else if (op == 2) {\\n            int n;\\n            cin >> n;\\n            lst.push_back(n);\\n            node_it[n] = --lst.end();\\n        }\\n        else if (op == 3) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                node_it[n] = lst.insert(node_it[a], n);\\n        }\\n        else if (op == 4) {\\n            int n, a;\\n            cin >> n >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else\\n                node_it[n] = lst.insert(next(node_it[a]), n);\\n        }\\n        else if (op == 5) {\\n            int a;\\n            cin >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else if (prev(node_it[a]) == lst.end())\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << *prev(node_it[a]) << \\\"\\\\n\\\";\\n        }\\n        else if (op == 6) {\\n            int a;\\n            cin >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else if (next(node_it[a]) == lst.end())\\n                cout << \\\"NULL\\\\n\\\";\\n            else\\n                cout << *next(node_it[a]) << \\\"\\\\n\\\";\\n        }\\n        else if (op == 7) {\\n            int a;\\n            cin >> a;\\n            if (node_it[a] == lst.end())\\n                cout << \\\"peko\\\\n\\\";\\n            else {\\n                lst.erase(node_it[a]);\\n                node_it[a] = lst.end();\\n            }\\n        }\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"section-0.3\",\n      children: \"應用\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再讓我們來看看一道應用題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/21/\",\n      src: \"NEOJ 21\",\n      name: \"陸行鳥大賽車\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/NEOJ/21/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/21/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/21/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/21/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"對於初始序列的建構，轉化成按照名次順序插入節點就行了。刪除節點的操作，模板就有直接支援。超越的部分比較麻煩，對於每一筆超越的操作，可以想像成先將前一名的節點刪除，再插入到自己的後面，因為 Linked List 對於 id 的插入、刪除操作都是 $O(1)$ ，所以總複雜度 $O(N+M)$。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"以下這份程式碼繼承了我們最一開始的 linked list 實作，讀者有興趣也可以自行使用 STL 的 \", _jsx(_components.code, {\n        children: \"list\"\n      }), \" 實作看看：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int main() {\\n    ios::sync_with_stdio(0), cin.tie(0);\\n    Init(0, 0, 0, 1);\\n    int n, m;\\n    cin >> n >> m;\\n\\n    // 初始化\\n    for (int i = 0; i < n; ++i)\\n        Insert(i, i + 1);\\n\\n    while (m--) {\\n        int op, id;\\n        cin >> op >> id;\\n        if (op == 0) {  \\n            // 刪除節點 id\\n            Delete(id);\\n        }\\n        else {\\n            // 超越前一名\\n            int p = prev_node[id];\\n            if (p != 0) {\\n                int pp = prev_node[p];\\n                Delete(p);\\n                Delete(id);\\n                Insert(pp, id);\\n                Insert(id, p);\\n            }\\n        }\\n    }\\n    // 遍歷整個 list\\n    int cur = next_node[0];\\n    while (cur != 0) {\\n        cout << cur << \\\" \\\\n\\\"[next_node[cur] == 0];\\n        cur = next_node[cur];\\n    }\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h3, {\n      id: \"section-0.3.1\",\n      children: \"查詢和修改和複雜度\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果想要查詢「一個東西指到誰？」的話，顯然這個可以在 $O(1)$ 內做完。那如果想要做的是查詢「我這個人一直指，指到第 $k$ 個人會是誰呢？」那就得花 $O(k)$ 的時間，所以 \", _jsx(_components.strong, {\n        children: \"Linked List 不適合隨機存取\"\n      }), \"，也就是在只給串列頭的狀況下，查詢第 $n$ 項的值，會變得很慢。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"注意到，這樣代表 Linked List 跟陣列有點像是相反的資料結構。Linked List 可以在 $O(1)$ 時間插入/刪除元素，但是需要 $O(n)$ 時間從頭開始找某一項。陣列則是要花 $O(n)$ 時間插入跟刪除元素，不過在 $O(1)$ 時間就能找到某一項。\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      id: \"section-0.4\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=b938\",\n      src: \"ZeroJudge b938\",\n      name: \"kevin 愛殺殺\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/ZeroJudge/b938/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/b938/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b938/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b938/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/21/\",\n      src: \"NEOJ 21\",\n      name: \"陸行鳥大賽車\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NEOJ/25/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/25/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/25/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/25/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/linked_list_practice/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"請你實做一個 linked-list ，並實現以下指令：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"1 n\"\n        }), \"：將整數 $n$ 放進 linked-list 的頭\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"2 n\"\n        }), \"：將整數 $n$ 放進 linked-list 的尾\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"3 n a\"\n        }), \"：將整數 $n$ 放到整數 $a$ 的前面，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        }), \" 並略過這個操作\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"4 n a\"\n        }), \"：將整數 $n$ 放到整數 $a$ 的後面，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        }), \" 並略過這個操作\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"5 a\"\n        }), \"：印出整數 $a$ 前面的整數，若此整數不存在則印出 \", _jsx(_components.code, {\n          children: \"NULL\"\n        }), \"，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"6 a\"\n        }), \"：印出整數 $a$ 後面的整數，若此整數不存在則印出 \", _jsx(_components.code, {\n          children: \"NULL\"\n        }), \"，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"7 a\"\n        }), \"：刪除整數 $a$，若 $a$ 不存在則印出 \", _jsx(_components.code, {\n          children: \"peko\"\n        }), \" 並略過這個操作\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/linked_list_practice/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsxs(_components.li, {\n      children: [\"保證所有操作 \", _jsx(_components.code, {\n        children: \"1\"\n      }), \", \", _jsx(_components.code, {\n        children: \"2\"\n      }), \", \", _jsx(_components.code, {\n        children: \"3\"\n      }), \", \", _jsx(_components.code, {\n        children: \"4\"\n      }), \" 中的整數 $n$ 不會重複\"]\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$指令數 \\\\leq 20000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 < $ 所有整數 $\\\\leq 100000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/21/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"輸入說明\"\n      }), _jsx(_components.br, {}), \"\\n\", \"第一行包含一個整數 $N$，代表現在有 $N$ 個玩家，編號 $1\\\\sim N$ 的玩家目前分別為第 $1\\\\sim N$ 名（編號 $1$ 第 $1$ 名、編號 $2$ 第 $2$ 名……）。\", _jsx(_components.br, {}), \"\\n\", \"第二行包含一個整數 $M$，代表接下來會依序發生 $M$ 個事件。\", _jsx(_components.br, {}), \"\\n\", \"接下來的 $M$ 行，每行包含兩個整數 $T_i,X_i$，$T_i$ 為 $0$ 的時候，代表編號 $X_i$ 的玩家遭受攻擊，然後離開遊戲；$T_i$ 為 $1$ 的時候，代表編號 $X_i$ 的玩家使用衝刺，無條件超越當前名次比他高一名的玩家。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"輸出說明\"\n      }), _jsx(_components.br, {}), \"\\n\", \"輸出一行，包含 $Y$ 個整數（$Y$ 是剩餘玩家的數量），由名次小到大依序輸出，整數兩兩間以空白隔開。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/21/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N\\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$M\\\\leq 50000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq T_i\\\\leq 1$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq X_i\\\\leq N$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"測試資料保證玩家被淘汰之後不會再出現任何紀錄。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b938/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"$n$ 個人站成一列，請執行 $m$ 次操作，每次都會把編號 $k$ 後面的人殺掉，並輸出這個被殺掉的人的編號。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b938/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq n, m\\\\leq 10^6$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/25/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 個店家在販賣物品，顧客們想在任何店家買東西都需要排隊，請支援 $M$ 筆操作：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"ADD\"\n        }), \"$\\\\;i\\\\;id$：代表編號為 $id$ 的顧客前往店家 $i$，排在隊伍的最後端\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"LEAVE\"\n        }), \"$\\\\;i$：代表店家 $i$ 賣出了一個物品給排在隊伍最前端的顧客，該顧客會離開隊伍\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"JOIN\"\n        }), \"$\\\\;i\\\\;j$：店家 $i$ 的物品賣完了，所以排在店家 $i$ 的隊伍會按照順序重新排在店家 \", _jsx(_components.code, {\n          children: \"j\"\n        }), \" 的後面\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/25/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N\\\\leq 100$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$M\\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"顧客編號介在 $1\\\\sim 10^6$ 之間\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"保證同一個顧客不會同時出現在不同隊伍中。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"prereqs":[{"code":"BasicDataStructure/vector","text":"基礎資料結構 / 動態的陣列"}],"sections":[{"text":"鏈結串列（Linked List）","depth":1,"code":"0.1"},{"text":"雙向串列（Doubly Linked List）","depth":2,"code":"0.1.1"},{"text":"實作時間","depth":2,"code":"0.1.2"},{"text":"STL","depth":1,"code":"0.2"},{"text":"STL linked list 操作","depth":2,"code":"0.2.1"},{"text":"沒有 ","depth":3,"code":"0.2.1.1"},{"text":"要怎麼像前面例題一樣存取編號 $a$ 的節點呢？","depth":3,"code":"0.2.1.2"},{"text":"應用","depth":1,"code":"0.3"},{"text":"查詢和修改和複雜度","depth":2,"code":"0.3.1"},{"text":"習題","depth":1,"code":"0.4"}],"previousArticle":{"code":"BasicDataStructure/stack_queue_deque","topicCode":"BasicDataStructure","articleCode":"stack_queue_deque","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Stack、Queue 與 Deque","articleDisplayTitle":"Stack、Queue 與 Deque","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/stack_queue_deque","topic":"BasicDataStructure","article":"stack_queue_deque","title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},"nextArticle":null,"virtualArticle":{"code":"BasicDataStructure/linked_list","topicCode":"BasicDataStructure","articleCode":"linked_list","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Linked List","articleDisplayTitle":"Linked List","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/linked_list","topic":"BasicDataStructure","article":"linked_list","title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},"topicStructure":[{"single":true,"title":"","topics":[{"code":"Guide","displayTitle":"網站簡介","articles":[{"code":"Guide/learning","topicCode":"Guide","articleCode":"learning","chapterCode":"I","fullDisplayTitle":"網站簡介 / 服用方法","articleDisplayTitle":"服用方法","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/learning","topic":"Guide","article":"learning","title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"description":"教大家怎麼看這份講義","prerequisites":[]}},{"code":"Guide/chapters","topicCode":"Guide","articleCode":"chapters","chapterCode":"I","fullDisplayTitle":"網站簡介 / 章節與主題","articleDisplayTitle":"章節與主題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/chapters","topic":"Guide","article":"chapters","title":"章節與主題","authors":["baluteshih"],"contributors":[],"description":"教大家什麼是章節與主題","prerequisites":["Guide/learning"]}},{"code":"Guide/problems","topicCode":"Guide","articleCode":"problems","chapterCode":"I","fullDisplayTitle":"網站簡介 / 習題","articleDisplayTitle":"習題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/problems","topic":"Guide","article":"problems","title":"習題","authors":["baluteshih"],"contributors":[],"description":"教大家這份講義的習題意義","prerequisites":["Guide/learning"]}},{"code":"Guide/math_symbol","topicCode":"Guide","articleCode":"math_symbol","chapterCode":"I","fullDisplayTitle":"網站簡介 / 基本數學符號","articleDisplayTitle":"基本數學符號","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/math_symbol","topic":"Guide","article":"math_symbol","title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"description":"介紹常見的數學符號","prerequisites":[]}},{"code":"Guide/language","topicCode":"Guide","articleCode":"language","chapterCode":"I","fullDisplayTitle":"網站簡介 / 語法學習資源","articleDisplayTitle":"語法學習資源","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/language","topic":"Guide","article":"language","title":"語法學習資源","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Guide/qa","topicCode":"Guide","articleCode":"qa","chapterCode":"I","fullDisplayTitle":"網站簡介 / NTUCPC Guide Q & A","articleDisplayTitle":"NTUCPC Guide Q & A","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/qa","topic":"Guide","article":"qa","title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":[]}}]}]},{"single":true,"title":"","topics":[{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/competitive_programming","topicCode":"Introduction","articleCode":"competitive_programming","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 資訊競賽介紹","articleDisplayTitle":"資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/competitive_programming","topic":"Introduction","article":"competitive_programming","title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Introduction/contests_type","topicCode":"Introduction","articleCode":"contests_type","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 比賽類型","articleDisplayTitle":"比賽類型","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/contests_type","topic":"Introduction","article":"contests_type","title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tw_contests","topicCode":"Introduction","articleCode":"tw_contests","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 台灣資訊競賽介紹","articleDisplayTitle":"台灣資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/tw_contests","topic":"Introduction","article":"tw_contests","title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}},{"code":"Introduction/online_judge","topicCode":"Introduction","articleCode":"online_judge","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 線上評測系統","articleDisplayTitle":"線上評測系統","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/online_judge","topic":"Introduction","article":"online_judge","title":"線上評測系統","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/resources","topicCode":"Introduction","articleCode":"resources","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 網路學習資源介紹","articleDisplayTitle":"網路學習資源介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/resources","topic":"Introduction","article":"resources","title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tactics","topicCode":"Introduction","articleCode":"tactics","chapterCode":"III","fullDisplayTitle":"資訊競賽介紹 / 比賽 + 練習策略","articleDisplayTitle":"比賽 + 練習策略","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"Introduction/tactics","topic":"Introduction","article":"tactics","title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}}]}]},{"single":true,"title":"","topics":[{"code":"Implementation","displayTitle":"實作技巧","articles":[{"code":"Implementation/basic_knowledge","topicCode":"Implementation","articleCode":"basic_knowledge","chapterCode":"II","fullDisplayTitle":"實作技巧 / 基本常識","articleDisplayTitle":"基本常識","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/basic_knowledge","topic":"Implementation","article":"basic_knowledge","title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"description":"講述一些競賽程式需要知道的最基本常識","prerequisites":["Introduction/online_judge"]}},{"code":"Implementation/input","topicCode":"Implementation","articleCode":"input","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見輸入類型","articleDisplayTitle":"常見輸入類型","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/input","topic":"Implementation","article":"input","title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的輸入格式","prerequisites":["Implementation/basic_knowledge"]}},{"code":"Implementation/reference","topicCode":"Implementation","articleCode":"reference","chapterCode":"II","fullDisplayTitle":"實作技巧 / Reference","articleDisplayTitle":"Reference","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/reference","topic":"Implementation","article":"reference","title":"Reference","authors":["baluteshih"],"contributors":[],"description":"Reference","prerequisites":[]}},{"code":"Implementation/compiler","topicCode":"Implementation","articleCode":"compiler","chapterCode":"II","fullDisplayTitle":"實作技巧 / 編譯器","articleDisplayTitle":"編譯器","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/compiler","topic":"Implementation","article":"compiler","title":"編譯器","authors":["WiwiHo"],"contributors":[],"description":"簡單介紹什麼是編譯器","prerequisites":[]}},{"code":"Implementation/error_message","topicCode":"Implementation","articleCode":"error_message","chapterCode":"II","fullDisplayTitle":"實作技巧 / 如何看錯誤訊息","articleDisplayTitle":"如何看錯誤訊息","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/error_message","topic":"Implementation","article":"error_message","title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"description":"介紹一些常見錯誤訊息的看法","prerequisites":["Implementation/compiler"]}},{"code":"Implementation/variable","topicCode":"Implementation","articleCode":"variable","chapterCode":"II","fullDisplayTitle":"實作技巧 / 全域、區域變數","articleDisplayTitle":"全域、區域變數","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/variable","topic":"Implementation","article":"variable","title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"description":"各種全域區域變數相關的事情","prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"]}},{"code":"Implementation/buglist","topicCode":"Implementation","articleCode":"buglist","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見錯誤列表","articleDisplayTitle":"常見錯誤列表","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/buglist","topic":"Implementation","article":"buglist","title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的錯誤","prerequisites":["Implementation/variable"]}},{"code":"Implementation/debug","topicCode":"Implementation","articleCode":"debug","chapterCode":null,"fullDisplayTitle":"實作技巧 / Debug","articleDisplayTitle":"Debug","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter ???","article":{"code":"Implementation/debug","topic":"Implementation","article":"debug","title":"Debug","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Implementation/buglist"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/intro","topicCode":"BasicAlgorithm","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/intro","topic":"BasicAlgorithm","article":"intro","title":"介紹","authors":["double"],"contributors":[],"description":"簡單介紹何謂演算法","prerequisites":["Introduction/competitive_programming"]}},{"code":"BasicAlgorithm/complexity","topicCode":"BasicAlgorithm","articleCode":"complexity","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 複雜度","articleDisplayTitle":"複雜度","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/complexity","topic":"BasicAlgorithm","article":"complexity","title":"複雜度","authors":["chengbilly92"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/sorting","topicCode":"BasicAlgorithm","articleCode":"sorting","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 排序演算法","articleDisplayTitle":"排序演算法","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/sorting","topic":"BasicAlgorithm","article":"sorting","title":"排序演算法","authors":["baluteshih"],"contributors":[],"description":"簡單介紹基本的排序演算法（O(n^2), counting sort 跟 radix sort）","prerequisites":["BasicAlgorithm/complexity"]}},{"code":"BasicAlgorithm/algorithm_numeric","topicCode":"BasicAlgorithm","articleCode":"algorithm_numeric","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 標準函式庫 ── <algorithm> 與 <numeric>","articleDisplayTitle":"標準函式庫 ── <algorithm> 與 <numeric>","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/algorithm_numeric","topic":"BasicAlgorithm","article":"algorithm_numeric","title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"description":"介紹 STL <algorithm> 和 <numeric> 裡的幾個常用函式","prerequisites":["BasicAlgorithm/sorting"]}},{"code":"BasicAlgorithm/enumerate","topicCode":"BasicAlgorithm","articleCode":"enumerate","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 枚舉","articleDisplayTitle":"枚舉","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/enumerate","topic":"BasicAlgorithm","article":"enumerate","title":"枚舉","authors":["WiwiHo"],"contributors":[],"description":"簡單的枚舉技巧，不包含遞迴","prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/searching","topicCode":"BasicAlgorithm","articleCode":"searching","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 搜尋","articleDisplayTitle":"搜尋","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/searching","topic":"BasicAlgorithm","article":"searching","title":"搜尋","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/math_in_school","topicCode":"BasicAlgorithm","articleCode":"math_in_school","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 學校教的數學","articleDisplayTitle":"學校教的數學","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/math_in_school","topic":"BasicAlgorithm","article":"math_in_school","title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"description":"一些和基礎演算法設計技巧有關的課綱內數學問題，引導讀者從基礎數學發現演算法，並且訓練把人腦作法轉換成演算法的能力。","prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/recursion","topicCode":"BasicAlgorithm","articleCode":"recursion","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 遞迴","articleDisplayTitle":"遞迴","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/recursion","topic":"BasicAlgorithm","article":"recursion","title":"遞迴","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/partial_sum","topicCode":"BasicAlgorithm","articleCode":"partial_sum","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 前綴和與差分","articleDisplayTitle":"前綴和與差分","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/partial_sum","topic":"BasicAlgorithm","article":"partial_sum","title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/two_pointers","topicCode":"BasicAlgorithm","articleCode":"two_pointers","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 雙指標","articleDisplayTitle":"雙指標","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/two_pointers","topic":"BasicAlgorithm","article":"two_pointers","title":"雙指標","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/binary_search_answer","topicCode":"BasicAlgorithm","articleCode":"binary_search_answer","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 對答案二分搜","articleDisplayTitle":"對答案二分搜","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/binary_search_answer","topic":"BasicAlgorithm","article":"binary_search_answer","title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"description":"","prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"]}}]}]},{"single":true,"title":"","topics":[{"code":"GreedyAlgorithm","displayTitle":"貪心演算法","articles":[{"code":"GreedyAlgorithm/intuitive_greedy","topicCode":"GreedyAlgorithm","articleCode":"intuitive_greedy","chapterCode":"II","fullDisplayTitle":"貪心演算法 / 貪心法 I","articleDisplayTitle":"貪心法 I","topicDisplayTitle":"貪心演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"GreedyAlgorithm/intuitive_greedy","topic":"GreedyAlgorithm","article":"intuitive_greedy","title":"貪心法 I","authors":["baluteshih"],"contributors":[],"description":"生活中直覺的貪心題目","prerequisites":["BasicAlgorithm/algorithm_numeric"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/intro","topicCode":"BasicDataStructure","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/intro","topic":"BasicDataStructure","article":"intro","title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"description":"簡單介紹資料結構的概念","prerequisites":["Implementation/basic_knowledge"]}},{"code":"BasicDataStructure/vector","topicCode":"BasicDataStructure","articleCode":"vector","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 動態的陣列","articleDisplayTitle":"動態的陣列","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/vector","topic":"BasicDataStructure","article":"vector","title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicDataStructure/stack_queue_deque","topicCode":"BasicDataStructure","articleCode":"stack_queue_deque","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Stack、Queue 與 Deque","articleDisplayTitle":"Stack、Queue 與 Deque","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/stack_queue_deque","topic":"BasicDataStructure","article":"stack_queue_deque","title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/linked_list","topicCode":"BasicDataStructure","articleCode":"linked_list","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Linked List","articleDisplayTitle":"Linked List","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/linked_list","topic":"BasicDataStructure","article":"linked_list","title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/binary_tree","topicCode":"BasicDataStructure","articleCode":"binary_tree","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / 二元樹","articleDisplayTitle":"二元樹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/binary_tree","topic":"BasicDataStructure","article":"binary_tree","title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/linked_list","Implementation/reference"]}},{"code":"BasicDataStructure/heap","topicCode":"BasicDataStructure","articleCode":"heap","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Heap","articleDisplayTitle":"Heap","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/heap","topic":"BasicDataStructure","article":"heap","title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}},{"code":"BasicDataStructure/set_map","topicCode":"BasicDataStructure","articleCode":"set_map","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Set 與 Map","articleDisplayTitle":"Set 與 Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/set_map","topic":"BasicDataStructure","article":"set_map","title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/heap"]}},{"code":"BasicDataStructure/unordered","topicCode":"BasicDataStructure","articleCode":"unordered","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Unordered Set 與 Unordered Map","articleDisplayTitle":"Unordered Set 與 Unordered Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/unordered","topic":"BasicDataStructure","article":"unordered","title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/set_map"]}},{"code":"BasicDataStructure/iterator","topicCode":"BasicDataStructure","articleCode":"iterator","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Iterator","articleDisplayTitle":"Iterator","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/iterator","topic":"BasicDataStructure","article":"iterator","title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/intro"]}},{"code":"BasicDataStructure/binary_tree_and_stack","topicCode":"BasicDataStructure","articleCode":"binary_tree_and_stack","chapterCode":null,"fullDisplayTitle":"基礎資料結構 / 二元樹與 Stack","articleDisplayTitle":"二元樹與 Stack","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter ???","article":{"code":"BasicDataStructure/binary_tree_and_stack","topic":"BasicDataStructure","article":"binary_tree_and_stack","title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}}]}]},{"single":true,"title":"","topics":[{"code":"BasicMath","displayTitle":"基礎數學","articles":[{"code":"BasicMath/basicalgo","topicCode":"BasicMath","articleCode":"basicalgo","chapterCode":"III","fullDisplayTitle":"基礎數學 / 常用數學演算法","articleDisplayTitle":"常用數學演算法","topicDisplayTitle":"基礎數學","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicMath/basicalgo","topic":"BasicMath","article":"basicalgo","title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"description":"一些不太難的數學","prerequisites":["BasicAlgorithm/math_in_school"]}}]}]}],"chapterStructure":[{"code":"I","displayTitle":"Chapter I. 初來乍到","topics":[{"code":"Guide","displayTitle":"網站簡介","articles":[{"code":"Guide/learning","topicCode":"Guide","articleCode":"learning","chapterCode":"I","fullDisplayTitle":"網站簡介 / 服用方法","articleDisplayTitle":"服用方法","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/learning","topic":"Guide","article":"learning","title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"description":"教大家怎麼看這份講義","prerequisites":[]}},{"code":"Guide/chapters","topicCode":"Guide","articleCode":"chapters","chapterCode":"I","fullDisplayTitle":"網站簡介 / 章節與主題","articleDisplayTitle":"章節與主題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/chapters","topic":"Guide","article":"chapters","title":"章節與主題","authors":["baluteshih"],"contributors":[],"description":"教大家什麼是章節與主題","prerequisites":["Guide/learning"]}},{"code":"Guide/problems","topicCode":"Guide","articleCode":"problems","chapterCode":"I","fullDisplayTitle":"網站簡介 / 習題","articleDisplayTitle":"習題","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/problems","topic":"Guide","article":"problems","title":"習題","authors":["baluteshih"],"contributors":[],"description":"教大家這份講義的習題意義","prerequisites":["Guide/learning"]}},{"code":"Guide/math_symbol","topicCode":"Guide","articleCode":"math_symbol","chapterCode":"I","fullDisplayTitle":"網站簡介 / 基本數學符號","articleDisplayTitle":"基本數學符號","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/math_symbol","topic":"Guide","article":"math_symbol","title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"description":"介紹常見的數學符號","prerequisites":[]}},{"code":"Guide/language","topicCode":"Guide","articleCode":"language","chapterCode":"I","fullDisplayTitle":"網站簡介 / 語法學習資源","articleDisplayTitle":"語法學習資源","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/language","topic":"Guide","article":"language","title":"語法學習資源","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Guide/qa","topicCode":"Guide","articleCode":"qa","chapterCode":"I","fullDisplayTitle":"網站簡介 / NTUCPC Guide Q & A","articleDisplayTitle":"NTUCPC Guide Q & A","topicDisplayTitle":"網站簡介","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Guide/qa","topic":"Guide","article":"qa","title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":[]}}]},{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/competitive_programming","topicCode":"Introduction","articleCode":"competitive_programming","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 資訊競賽介紹","articleDisplayTitle":"資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/competitive_programming","topic":"Introduction","article":"competitive_programming","title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"description":"","prerequisites":["Guide/learning"]}},{"code":"Introduction/contests_type","topicCode":"Introduction","articleCode":"contests_type","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 比賽類型","articleDisplayTitle":"比賽類型","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/contests_type","topic":"Introduction","article":"contests_type","title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/tw_contests","topicCode":"Introduction","articleCode":"tw_contests","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 台灣資訊競賽介紹","articleDisplayTitle":"台灣資訊競賽介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/tw_contests","topic":"Introduction","article":"tw_contests","title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}},{"code":"Introduction/online_judge","topicCode":"Introduction","articleCode":"online_judge","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 線上評測系統","articleDisplayTitle":"線上評測系統","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/online_judge","topic":"Introduction","article":"online_judge","title":"線上評測系統","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}},{"code":"Introduction/resources","topicCode":"Introduction","articleCode":"resources","chapterCode":"I","fullDisplayTitle":"資訊競賽介紹 / 網路學習資源介紹","articleDisplayTitle":"網路學習資源介紹","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter I. 初來乍到","article":{"code":"Introduction/resources","topic":"Introduction","article":"resources","title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"description":"","prerequisites":["Introduction/competitive_programming"]}}]}]},{"code":"II","displayTitle":"Chapter II. 新手上路","topics":[{"code":"Implementation","displayTitle":"實作技巧","articles":[{"code":"Implementation/basic_knowledge","topicCode":"Implementation","articleCode":"basic_knowledge","chapterCode":"II","fullDisplayTitle":"實作技巧 / 基本常識","articleDisplayTitle":"基本常識","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/basic_knowledge","topic":"Implementation","article":"basic_knowledge","title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"description":"講述一些競賽程式需要知道的最基本常識","prerequisites":["Introduction/online_judge"]}},{"code":"Implementation/input","topicCode":"Implementation","articleCode":"input","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見輸入類型","articleDisplayTitle":"常見輸入類型","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/input","topic":"Implementation","article":"input","title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的輸入格式","prerequisites":["Implementation/basic_knowledge"]}},{"code":"Implementation/reference","topicCode":"Implementation","articleCode":"reference","chapterCode":"II","fullDisplayTitle":"實作技巧 / Reference","articleDisplayTitle":"Reference","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/reference","topic":"Implementation","article":"reference","title":"Reference","authors":["baluteshih"],"contributors":[],"description":"Reference","prerequisites":[]}},{"code":"Implementation/compiler","topicCode":"Implementation","articleCode":"compiler","chapterCode":"II","fullDisplayTitle":"實作技巧 / 編譯器","articleDisplayTitle":"編譯器","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/compiler","topic":"Implementation","article":"compiler","title":"編譯器","authors":["WiwiHo"],"contributors":[],"description":"簡單介紹什麼是編譯器","prerequisites":[]}},{"code":"Implementation/error_message","topicCode":"Implementation","articleCode":"error_message","chapterCode":"II","fullDisplayTitle":"實作技巧 / 如何看錯誤訊息","articleDisplayTitle":"如何看錯誤訊息","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/error_message","topic":"Implementation","article":"error_message","title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"description":"介紹一些常見錯誤訊息的看法","prerequisites":["Implementation/compiler"]}},{"code":"Implementation/variable","topicCode":"Implementation","articleCode":"variable","chapterCode":"II","fullDisplayTitle":"實作技巧 / 全域、區域變數","articleDisplayTitle":"全域、區域變數","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/variable","topic":"Implementation","article":"variable","title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"description":"各種全域區域變數相關的事情","prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"]}},{"code":"Implementation/buglist","topicCode":"Implementation","articleCode":"buglist","chapterCode":"II","fullDisplayTitle":"實作技巧 / 常見錯誤列表","articleDisplayTitle":"常見錯誤列表","topicDisplayTitle":"實作技巧","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"Implementation/buglist","topic":"Implementation","article":"buglist","title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"description":"講述一些競賽程式常見的錯誤","prerequisites":["Implementation/variable"]}}]},{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/intro","topicCode":"BasicAlgorithm","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/intro","topic":"BasicAlgorithm","article":"intro","title":"介紹","authors":["double"],"contributors":[],"description":"簡單介紹何謂演算法","prerequisites":["Introduction/competitive_programming"]}},{"code":"BasicAlgorithm/complexity","topicCode":"BasicAlgorithm","articleCode":"complexity","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 複雜度","articleDisplayTitle":"複雜度","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/complexity","topic":"BasicAlgorithm","article":"complexity","title":"複雜度","authors":["chengbilly92"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/sorting","topicCode":"BasicAlgorithm","articleCode":"sorting","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 排序演算法","articleDisplayTitle":"排序演算法","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/sorting","topic":"BasicAlgorithm","article":"sorting","title":"排序演算法","authors":["baluteshih"],"contributors":[],"description":"簡單介紹基本的排序演算法（O(n^2), counting sort 跟 radix sort）","prerequisites":["BasicAlgorithm/complexity"]}},{"code":"BasicAlgorithm/algorithm_numeric","topicCode":"BasicAlgorithm","articleCode":"algorithm_numeric","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 標準函式庫 ── <algorithm> 與 <numeric>","articleDisplayTitle":"標準函式庫 ── <algorithm> 與 <numeric>","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/algorithm_numeric","topic":"BasicAlgorithm","article":"algorithm_numeric","title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"description":"介紹 STL <algorithm> 和 <numeric> 裡的幾個常用函式","prerequisites":["BasicAlgorithm/sorting"]}},{"code":"BasicAlgorithm/enumerate","topicCode":"BasicAlgorithm","articleCode":"enumerate","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 枚舉","articleDisplayTitle":"枚舉","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/enumerate","topic":"BasicAlgorithm","article":"enumerate","title":"枚舉","authors":["WiwiHo"],"contributors":[],"description":"簡單的枚舉技巧，不包含遞迴","prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/searching","topicCode":"BasicAlgorithm","articleCode":"searching","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 搜尋","articleDisplayTitle":"搜尋","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/searching","topic":"BasicAlgorithm","article":"searching","title":"搜尋","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicAlgorithm/math_in_school","topicCode":"BasicAlgorithm","articleCode":"math_in_school","chapterCode":"II","fullDisplayTitle":"基礎演算法 / 學校教的數學","articleDisplayTitle":"學校教的數學","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicAlgorithm/math_in_school","topic":"BasicAlgorithm","article":"math_in_school","title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"description":"一些和基礎演算法設計技巧有關的課綱內數學問題，引導讀者從基礎數學發現演算法，並且訓練把人腦作法轉換成演算法的能力。","prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"]}}]},{"code":"GreedyAlgorithm","displayTitle":"貪心演算法","articles":[{"code":"GreedyAlgorithm/intuitive_greedy","topicCode":"GreedyAlgorithm","articleCode":"intuitive_greedy","chapterCode":"II","fullDisplayTitle":"貪心演算法 / 貪心法 I","articleDisplayTitle":"貪心法 I","topicDisplayTitle":"貪心演算法","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"GreedyAlgorithm/intuitive_greedy","topic":"GreedyAlgorithm","article":"intuitive_greedy","title":"貪心法 I","authors":["baluteshih"],"contributors":[],"description":"生活中直覺的貪心題目","prerequisites":["BasicAlgorithm/algorithm_numeric"]}}]},{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/intro","topicCode":"BasicDataStructure","articleCode":"intro","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 介紹","articleDisplayTitle":"介紹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/intro","topic":"BasicDataStructure","article":"intro","title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"description":"簡單介紹資料結構的概念","prerequisites":["Implementation/basic_knowledge"]}},{"code":"BasicDataStructure/vector","topicCode":"BasicDataStructure","articleCode":"vector","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / 動態的陣列","articleDisplayTitle":"動態的陣列","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/vector","topic":"BasicDataStructure","article":"vector","title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"]}},{"code":"BasicDataStructure/stack_queue_deque","topicCode":"BasicDataStructure","articleCode":"stack_queue_deque","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Stack、Queue 與 Deque","articleDisplayTitle":"Stack、Queue 與 Deque","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/stack_queue_deque","topic":"BasicDataStructure","article":"stack_queue_deque","title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}},{"code":"BasicDataStructure/linked_list","topicCode":"BasicDataStructure","articleCode":"linked_list","chapterCode":"II","fullDisplayTitle":"基礎資料結構 / Linked List","articleDisplayTitle":"Linked List","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter II. 新手上路","article":{"code":"BasicDataStructure/linked_list","topic":"BasicDataStructure","article":"linked_list","title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/vector"]}}]}]},{"code":"III","displayTitle":"Chapter III. 漸入佳境","topics":[{"code":"Introduction","displayTitle":"資訊競賽介紹","articles":[{"code":"Introduction/tactics","topicCode":"Introduction","articleCode":"tactics","chapterCode":"III","fullDisplayTitle":"資訊競賽介紹 / 比賽 + 練習策略","articleDisplayTitle":"比賽 + 練習策略","topicDisplayTitle":"資訊競賽介紹","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"Introduction/tactics","topic":"Introduction","article":"tactics","title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["Introduction/contests_type"]}}]},{"code":"BasicAlgorithm","displayTitle":"基礎演算法","articles":[{"code":"BasicAlgorithm/recursion","topicCode":"BasicAlgorithm","articleCode":"recursion","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 遞迴","articleDisplayTitle":"遞迴","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/recursion","topic":"BasicAlgorithm","article":"recursion","title":"遞迴","authors":["nathanlee726"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/intro"]}},{"code":"BasicAlgorithm/partial_sum","topicCode":"BasicAlgorithm","articleCode":"partial_sum","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 前綴和與差分","articleDisplayTitle":"前綴和與差分","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/partial_sum","topic":"BasicAlgorithm","article":"partial_sum","title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/two_pointers","topicCode":"BasicAlgorithm","articleCode":"two_pointers","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 雙指標","articleDisplayTitle":"雙指標","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/two_pointers","topic":"BasicAlgorithm","article":"two_pointers","title":"雙指標","authors":["rabhunter"],"contributors":[],"description":"","prerequisites":["BasicAlgorithm/enumerate"]}},{"code":"BasicAlgorithm/binary_search_answer","topicCode":"BasicAlgorithm","articleCode":"binary_search_answer","chapterCode":"III","fullDisplayTitle":"基礎演算法 / 對答案二分搜","articleDisplayTitle":"對答案二分搜","topicDisplayTitle":"基礎演算法","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicAlgorithm/binary_search_answer","topic":"BasicAlgorithm","article":"binary_search_answer","title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"description":"","prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"]}}]},{"code":"BasicDataStructure","displayTitle":"基礎資料結構","articles":[{"code":"BasicDataStructure/binary_tree","topicCode":"BasicDataStructure","articleCode":"binary_tree","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / 二元樹","articleDisplayTitle":"二元樹","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/binary_tree","topic":"BasicDataStructure","article":"binary_tree","title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"description":"example description","prerequisites":["BasicDataStructure/linked_list","Implementation/reference"]}},{"code":"BasicDataStructure/heap","topicCode":"BasicDataStructure","articleCode":"heap","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Heap","articleDisplayTitle":"Heap","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/heap","topic":"BasicDataStructure","article":"heap","title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/binary_tree"]}},{"code":"BasicDataStructure/set_map","topicCode":"BasicDataStructure","articleCode":"set_map","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Set 與 Map","articleDisplayTitle":"Set 與 Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/set_map","topic":"BasicDataStructure","article":"set_map","title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/heap"]}},{"code":"BasicDataStructure/unordered","topicCode":"BasicDataStructure","articleCode":"unordered","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Unordered Set 與 Unordered Map","articleDisplayTitle":"Unordered Set 與 Unordered Map","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/unordered","topic":"BasicDataStructure","article":"unordered","title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"description":"example description","prerequisites":["BasicDataStructure/set_map"]}},{"code":"BasicDataStructure/iterator","topicCode":"BasicDataStructure","articleCode":"iterator","chapterCode":"III","fullDisplayTitle":"基礎資料結構 / Iterator","articleDisplayTitle":"Iterator","topicDisplayTitle":"基礎資料結構","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicDataStructure/iterator","topic":"BasicDataStructure","article":"iterator","title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"description":"example description","prerequisites":["BasicDataStructure/intro"]}}]},{"code":"BasicMath","displayTitle":"基礎數學","articles":[{"code":"BasicMath/basicalgo","topicCode":"BasicMath","articleCode":"basicalgo","chapterCode":"III","fullDisplayTitle":"基礎數學 / 常用數學演算法","articleDisplayTitle":"常用數學演算法","topicDisplayTitle":"基礎數學","chapterDisplayTitle":"Chapter III. 漸入佳境","article":{"code":"BasicMath/basicalgo","topic":"BasicMath","article":"basicalgo","title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"description":"一些不太難的數學","prerequisites":["BasicAlgorithm/math_in_school"]}}]}]}]}},"__N_SSG":true}