{"pageProps":{"props":{"mdxPath":"guide/content/GreedyAlgorithm/unintuitive_greedy/unintuitive_greedy.mdx","code":"GreedyAlgorithm/unintuitive_greedy","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"廣度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["AlgorithmTechnique/dfs"],"coming":false},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"分治法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting","BasicAlgorithm/recursion","BasicAlgorithm/two_pointers"],"coming":false},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"深度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/structured_binding","BasicAlgorithm/recursion","BasicAlgorithm/enumerate","BasicDataStructure/binary_tree"],"coming":false},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter","WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","ImplementationKnowledge/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/backtracking","article":"backtracking","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 回溯","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/basic_optimization","article":"basic_optimization","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 的基本優化","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/structure"],"coming":true},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":false},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":false},{"code":"BasicDynamicProgramming/range_dp","article":"range_dp","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"區間 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/structure","article":"structure","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"動態規劃的必要元素","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","ImplementationSkill/buglist"],"coming":false},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":true,"title":"樹","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":true,"title":"二分圖","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":true,"title":"圖論基礎","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicAlgorithm/searching","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","AlgorithmTechnique/bfs","AlgorithmTechnique/dfs"],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":true,"title":"拓撲排序","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":true,"title":"單調隊列","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicDataStructure/stack_queue_deque","BasicAlgorithm/sweep"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 III","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/unintuitive_greedy","BasicDataStructure/set_map","BasicAlgorithm/partial_sum","BasicAlgorithm/binary_search_answer"],"coming":false},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 II","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/basic_knowledge","article":"basic_knowledge","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"ImplementationKnowledge/compiler","article":"compiler","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/float_error","article":"float_error","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/input","article":"input","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"ImplementationKnowledge/reference","article":"reference","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/rngbased","article":"rngbased","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Range-based for loop","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/reference","BasicDataStructure/vector"],"coming":false},{"code":"ImplementationKnowledge/structured_binding","article":"structured_binding","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Structured binding","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased"],"coming":false},{"code":"ImplementationKnowledge/variable","article":"variable","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/reference","ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationKnowledge/variable_declare","article":"variable_declare","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常用變數宣告方法","authors":["WiwiHo","baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/buglist","article":"buglist","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/debug","article":"debug","topic":"ImplementationSkill","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["ImplementationSkill/buglist"],"coming":false},{"code":"ImplementationSkill/error_message","article":"error_message","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationSkill/pseudo_pointer","article":"pseudo_pointer","topic":"ImplementationSkill","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"ImplementationKnowledge","title":"實作知識","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error"]},{"code":"ImplementationSkill","title":"實作技巧","contents":["ImplementationSkill/error_message","ImplementationSkill/buglist","ImplementationSkill/debug","ImplementationSkill/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","BasicDynamicProgramming/basic_optimization","BasicDynamicProgramming/range_dp","BasicDynamicProgramming/backtracking"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["ImplementationKnowledge"]},{"single":true,"title":"","topics":["ImplementationSkill"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationSkill/error_message","ImplementationSkill/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error","ImplementationSkill/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/GreedyAlgorithm/unintuitive_greedy/unintuitive_greedy.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Info, Problem} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"自己找出「選擇」\",\n      children: \"自己找出「選擇」\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"針對\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"GreedyAlgorithm/intuitive_greedy\",\n        mode: \"article\",\n        topicTitle: \"貪心演算法\",\n        articleTitle: \"貪心法 I\"\n      }), \" 提到三個例題裡，我們總是被題目要求要執行一連串的「任務」：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"吃下 $K$ 塊蛋糕\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"寫完 $N$ 份作業\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"烹煮 $N$ 份料理\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這讓我們能為所有的決策排出一個順序，使得我們能每次挑選最好的那項執行。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但有的時候這個所謂的「任務」可能不會寫在題目裡面，我們不妨來看看下面這道例題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=d418\",\n      src: \"ZeroJudge d418\",\n      name: \"Product of digits\",\n      expanded: \"true\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/ZeroJudge/d418/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/d418/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/d418/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/d418/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不曉得讀者對於上面這題是否有感受到問題了，那就是我們可能不知道從何開始「選擇」，畢竟我們沒有被指派所謂的「任務」。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"遇到這種題目，我們必須要先一些簡單的觀察，首先搞清楚我們目標為何——找到最小、滿足條件的非負整數。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"數字是如何比大小的呢？要注意到這裡不是簡單的用一個 \", _jsx(_components.code, {\n        children: \"<\"\n      }), \" 運算子就好，因為題目關注的是數字的「位數」，所以我們可以想成當我們有兩個數字字串時，該如何去比較他們的大小：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"首先，\", _jsx(_components.strong, {\n          children: \"長度\"\n        }), \"比較短的數字一定比較小。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"若他們的長度一樣，則\", _jsx(_components.strong, {\n          children: \"字典序\"\n        }), \"比較小的數字會比較小。\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"有關於字典序的定義，可以去\", _jsx(ContentReference, {\n              type: \"content\",\n              code: \"BasicAlgorithm/enumerate\",\n              mode: \"full\",\n              topicTitle: \"基礎演算法\",\n              articleTitle: \"枚舉\"\n            }), \"複習。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，要找到最小的非負整數，我們的目標會是：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"先讓長度盡量短。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"再讓字典序盡量小。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而這樣的觀察會引導出我們真正的任務為何：試圖不斷選擇最好的位數來乘出 $N$。此時便有個很單純的結論：不斷找到 $N$ 的因數中，$2\\\\sim 9$ 內最大的那個，並將其放到數字的目前最高位。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"會採取這樣的策略主要有以下幾個優勢：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"不斷除以盡量大的因數，可以\", _jsx(_components.strong, {\n          children: \"加速 $N$ 變小的速度\"\n        }), \"，讓長度最小化。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"因為\", _jsx(_components.strong, {\n          children: \"越早使用的因數，會在數字的越末位\"\n        }), \"，這讓我們得到的結果即使跟其他策略得到的數字長度一樣，我們也可以讓高位盡量小，使得字典序最小。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如此一來我們就完成這題了。不過我們還是總結一下剛剛發生了什麼：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"因為找不到「任務」，所以我們先\", _jsx(_components.strong, {\n          children: \"觀察目標性質\"\n        }), \"來找出任務在哪：我們要依序選擇盡量好的位數們。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"找到性質後，我們找到一個貪心策略：每次選擇最大的位數因數放在當前最高位。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"感性理解我們的貪心策略是最佳的。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"透過這道題目，希望能讓讀者感受到選擇並不總是題目給的，同時也期盼能給讀者一點「觀察性質」的啟發。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"「證明」你的策略\",\n      children: \"「證明」你的策略\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在貪心法的章節中，到目前為止我們似乎都只是很感性的去理解我們策略的正確性而已，不過如果比賽中我們「猜錯策略」導致浪費了時間撰寫這些錯誤解答的話，往往會造成不小的損失。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，在要寫解答之前，我們可以簡單的幫自己的演算法給出一點「證明」，來增加我們對策略的自信心、或是提早預防自己寫出錯誤的解答。我們不妨就拿先前解過的幾道例題來解釋。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"「證明」你的策略-目標本質法\",\n      children: \"目標本質法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們來證明這題的策略正確性：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/97\",\n      src: \"NCOJ 97\",\n      name: \"[Tutorial] 好吃的蛋糕\",\n      expanded: \"true\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/NCOJ/97/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/97/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/97/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/97/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"僅這題的策略看似很直接，但如果要稍微證明的話，還是可以講個一句話：因為我們獲得的好吃度是 $K$ 個數字的總和，既然我們都選了最大的 $K$ 個數字，那就不可能更好了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"像這樣直接找到「我們要最佳化的目標，有個顯然的上界」，往往能迅速的讓人接受策略的正確性。因為只要我們的策略能夠達到這個所謂的上界，那就沒有任何理由反駁他了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"「證明」你的策略-反證法\",\n      children: \"反證法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們來證明這題的策略正確性：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/98\",\n      src: \"NCOJ 98\",\n      name: \"[Tutorial] 趕不完的作業\",\n      expanded: \"true\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/NCOJ/98/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/98/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/98/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/98/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這題的策略是「每次選擇死線最早的作業做」，要如何證明這個策略的正確性呢？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"不妨我們就假設「最佳策略\", _jsx(_components.strong, {\n        children: \"不能\"\n      }), \"先選擇死線最早的作業做」，這樣會如何呢？\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"對於這個「真正的最佳策略」，假設死線最早的作業是作業 $m$，若\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"他沒有做作業 $m$，直接把第一份完成的作業強制換成 $m$，答案不會變差。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"他在稍晚的時間做了作業 $m$，這時候我們直接把 $m$ 搬到最前面來做，因為在這之間的作業死線都比較晚，既然 $m$ 都能準時完成了，那這之間的作業晚一小時做當然也不會超過死線，因此答案也不會變差。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"既然我們改成先選擇死線最早的作業做都不會讓答案變差，這就造成了\", _jsx(_components.strong, {\n        children: \"矛盾\"\n      }), \"，因此，我們的假設是錯誤的，也就得到了我們策略的正確性。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"像這樣透過「矛盾假設」的手法就稱為「反證法」，也是在證明貪心演算法時常見的一個手法。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"「證明」你的策略-逆序數對證明法\",\n      children: \"逆序數對證明法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們來證明這題的策略正確性：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1072\",\n      src: \"NPSC 2005 高中組決賽 pA\",\n      name: \"誰先晚餐\",\n      expanded: \"true\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/NPSC/2005_senior_fin_A/description.mdx\",\n      constraintsMdx: \"guide/problems/NPSC/2005_senior_fin_A/constraints.mdx\",\n      importMdx: \"guide/problems/NPSC/2005_senior_fin_A/description.mdx\",\n      importMdx: \"guide/problems/NPSC/2005_senior_fin_A/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這題的策略是「選擇吃最久的人點的餐點開始製作」，因此直接對用餐時間大到小排序就可以得到最佳順序，要如何證明這個策略的正確性呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這裡我們要使用的證明手法同樣是由反證法出發，但因為手法本身還多用到了一個巧思，因此才特別拿出來講。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"首先，我們同樣假設「最佳順序\", _jsx(_components.strong, {\n        children: \"不能\"\n      }), \"經由用餐時間大到小排序」得出，因此，最佳順序肯定存在「相鄰的\", _jsx(_components.strong, {\n        children: \"逆序\"\n      }), \"數對」。\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"也就是說，會有一組相鄰的數對 $(i, j)$，他們的用餐時間順序是反的（小在前、大在後）。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這時候，如果我們把 $i$ 和 $j$ 交換，會得到什麼呢？\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"首先，$i$ 之前和 $j$ 之後的餐點的完成時間都不會受到影響，所以我們專注在比較 $i$ 跟 $j$ 的「用餐結束時間」。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"一開始，$i$ 的製作時間會是 $t$：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"則 $i$ 的用餐結束時間是 $t+C_i+E_i$，\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"而 $j$ 的用餐結束時間也就接著是 $t+C_i+C_j+E_j$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"若我們改成先製作 $j$ 再製作 $i$：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"則 $i$ 的用餐結束時間是 $t+C_j+E_j$，\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"而 $j$ 的用餐結束時間也就接著是 $t+C_j+C_i+E_i$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們不妨比較兩者造成的「用餐結束時間最大值」：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"一個是 $\\\\max(t + C_i + E_i, t+C_i+C_j+E_j)$、一個是 $\\\\max(t+C_j+E_j, t+C_j+C_i+E_i)$。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"注意前提：$E_i<E_j$，因為他們是逆序數對。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"因此我們可以做出一些簡化：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"$\\\\max(t + C_i + E_i, t+C_i+C_j+E_j) = t+C_i+\\\\max(E_i, C_j+E_j) = t+C_i+C_j+E_j$，\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"$\\\\max(t+C_j+E_j, t+C_j+C_i+E_i)=t+C_j+\\\\max(E_j, C_i+E_i)$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"將兩邊的共同部分都移除之後，得到我們只需要比較 $C_i+E_j$ 和 $\\\\max(E_j, C_i+E_i)$ 的大小關係，而：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"$E_j\\\\leq C_i+E_j$；\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"因為 $E_i<E_j$，所以 $C_i+E_i\\\\leq C_i+E_j$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"所以不論右邊的 $\\\\max$ 選了哪項，都不會讓答案變差，甚至更好！\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因次，透過上面的比較，我們就能發現交換相鄰逆序數對也不會讓答案變差，造成矛盾。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這類證明手法儘管比較不直覺，但卻能提供非常直接的正確性證據。\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"實際上，前一道例題也可以用類似的方法證明，交給讀者自行練習。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"反過來利用證明方法解題\",\n      children: \"反過來利用證明方法解題\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"反過來利用證明方法解題-目標本質法\",\n      children: \"目標本質法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們試著解決這題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://codeforces.com/problemset/problem/1433/B\",\n      src: \"Codeforces 1433B\",\n      name: \"Yet Another Bookshelf\",\n      expanded: \"true\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Codeforces/1433B/description.mdx\",\n      constraintsMdx: \"guide/problems/Codeforces/1433B/constraints.mdx\",\n      importMdx: \"guide/problems/Codeforces/1433B/description.mdx\",\n      importMdx: \"guide/problems/Codeforces/1433B/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這題有一個很直接的貪心做法：每次選擇最左邊的連續一段書，將其全部往右一格。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但這樣直接移動可能會花費 $O(n^2)$ 的時間，雖然足以通過這題、要優化其實也不難，但有沒有更單純的做法呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以觀察到，我們這樣的策略存在著一個直接的本質：每次移動，一定是在讓最左邊和最右邊兩本書中間的 $0$ 少一個。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"反過來想，任何移動不也只能讓這個「中間的 $0$」的個數少一嗎？既然我們的策略能貼合這個「答案下限」，那我們的策略就是最佳的了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，我們直接的證明了我們策略的最佳性──與此同時，我們還順便找到了一個超級好寫的作法：直接找到最左邊和最右邊的書，數中間有幾個 $0$ 就好！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣的做法不僅是 $O(n)$，還非常好寫。從這題我們也可以了解到，貪心策略有時候不一定要真的去實作，他可以僅僅是作為真的存在理想答案的「證據」，來讓我們直接計算答案後輸出。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"反過來利用證明方法解題-逆序數對法\",\n      children: \"逆序數對法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們來實際解決上次失敗的這題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=c471\",\n      src: \"APCS 2017/10 P4\",\n      name: \"物品堆疊\",\n      expanded: \"true\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/APCS/201710P4/description.mdx\",\n      constraintsMdx: \"guide/problems/APCS/201710P4/constraints.mdx\",\n      importMdx: \"guide/problems/APCS/201710P4/description.mdx\",\n      importMdx: \"guide/problems/APCS/201710P4/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然我們要幫所有物品排一個順序，不如大膽猜測：如果我們想要用逆序數對證明法證明我們的順序，會發生什麼事呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"對於相鄰的兩個物品 $(i, j)$，交換他們與否同樣不會影響外側物品造成的花費，所以我們不妨專心比較交換這兩個物品的所造成的花費：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"若 $i$ 在 $j$ 上方，並假設 $i$ 的上方總重為 $s$，則：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"$i$ 的能量花費是 $s\\\\cdot f_i$。\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"$j$ 的能量花費是 $(s+w_i)\\\\cdot f_j$。\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"總花費為 $s\\\\cdot f_i + s\\\\cdot f_j + w_i \\\\cdot f_j$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"若交換 $i$ 和 $j$，則：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"$j$ 的能量花費是 $s\\\\cdot f_j$。\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"$i$ 的能量花費是 $(s+w_j)\\\\cdot f_i$。\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"總花費為 $s\\\\cdot f_j + s\\\\cdot f_i + w_j \\\\cdot f_i$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"若要比較兩者的大小關係，可以發現：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"先把共同項移除，得到我們要比較的對象是 $w_i\\\\cdot f_j$ 和 $w_j\\\\cdot f_i$。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"不管中間的大小關係是大於或小於，我們都能做出移項──實際上，我們就是在比 $\\\\frac{w_i}{f_i}$ 和 $\\\\frac{w_j}{f_j}$ 的大小關係！\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然我們確定了，每個物品都有唯一的數值可以拿來做比較，那事情就簡單了：直接對這個數字排序，照著模擬就行啦！所以我們便得到了一個 $O(N\\\\log N)$ 的作法。\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"雖然我們在對分數做比較，但實際比大小的時候還是建議大家反著移項回去、使用交叉相乘的方式比大小，來避免浮點數可能產生的問題。\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這類題目往往直覺上不好解決，但若透過倒推的方式，從證明手法開始思考的話，往往有時候可以神奇的把題目解決掉。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過如果比賽要求快，真的需要這麼麻煩的去做假設、消項和移項嗎？這裡有幾個小技巧：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"首先，「假設 $i$ 上方的能量為 $s$」其實是不必要的操作，這是因為我們可以提前預想到上方的能量本來就會同時被 $i$ 和 $j$ 消耗到，本來就會對消，不如一開始就將其剔除。\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"類似的議題也發生在我們更前面的「誰先晚餐」證明，不需要假設製作時間 $t$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"實作時也不用真的移項，只要在排序的時候，試著把兩個物品交換擺放，照著算一遍花費，看哪邊比較大、回傳比較好的那邊就行了。\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"這是因為比較的效果都是等價的，唯有證明時才需要好好移項來證明真的存在一個唯一的「數值」做比較。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/715\",\n      src: \"NCOJ 715\",\n      name: \"換錢錢\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NCOJ/715/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/715/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/715/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/715/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/716\",\n      src: \"NCOJ 716\",\n      name: \"換錢錢，但我窮\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NCOJ/716/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/716/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/716/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/716/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://atcoder.jp/contests/arc134/tasks/arc134_b\",\n      src: \"AtCoder Regular Contest 134 Problem B\",\n      name: \"Reserve or Reverse\",\n      expanded: \"false\",\n      difficulty: \"3\",\n      descriptionMdx: \"guide/problems/AtCoder/arc134_b/description.mdx\",\n      constraintsMdx: \"guide/problems/AtCoder/arc134_b/constraints.mdx\",\n      importMdx: \"guide/problems/AtCoder/arc134_b/description.mdx\",\n      importMdx: \"guide/problems/AtCoder/arc134_b/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1629\",\n      src: \"CSES 1629\",\n      name: \"Movie Festival\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/CSES/1629/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1629/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1629/description.mdx\",\n      importMdx: \"guide/problems/CSES/1629/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/721\",\n      src: \"NCOJ 721\",\n      name: \"原料廠商\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NCOJ/721/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/721/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/721/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/721/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/74/\",\n      src: \"NEOJ 74\",\n      name: \"円円攻略黃河\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NEOJ/74/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/74/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/74/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/74/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1279\",\n      src: \"TIOJ 1279\",\n      name: \"填方格遊戲－續\",\n      expanded: \"false\",\n      difficulty: \"3\",\n      descriptionMdx: \"guide/problems/TIOJ/1279/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1279/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1279/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1279/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/733\",\n      src: \"NCOJ 733\",\n      name: \"七彩繽紛銀河麵\",\n      expanded: \"false\",\n      difficulty: \"4\",\n      descriptionMdx: \"guide/problems/NCOJ/733/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/733/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/733/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/733/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/727\",\n      src: \"NCOJ 727\",\n      name: \"這是圖靈機嗎？\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NCOJ/727/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/727/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/727/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/727/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/d418/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"給你一個大於等於 $0$ 的整數 $N$，請你你找到最小的非負整數 $Q$ ，使得在 $Q$ 中所有位數（digit）的乘積等於 $N$。若找不到任何非負整數的位數乘積為 $N$，請輸出 $-1$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"例如：$N=10$，可以找到 $Q=25$，因為 $2\\\\times 5=10$。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/d418/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$T \\\\leq 100$ 筆測資\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq N\\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/97/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 塊蛋糕，經過你審慎評估後，你了解到對於第 $i$ 塊蛋糕他的好吃度為 $y_i$。但無奈的是由於你食量有限，你只能吃下 $K$ 塊蛋糕。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"試問在最佳策略下，若要最大化吃下的蛋糕好吃度總和，這個總和最大可以是多少？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/97/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq K \\\\leq N \\\\leq 2\\\\times 10^ 5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq y_i \\\\leq 10^ 9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/98/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 份作業，你知道每一份作業你都只需要花一小時就能寫完，但可怕的是，第 $i$ 份作業再過 $d_i$ 小時就要截止了！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"想要讓所有作業在截止前完成可能還有些困難，因此，你希望能完成越多份作業越好。試問在最佳策略下，你能有幾份作業在截止時間前寫完？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"*註：若一份作業一小時後截止，你有辦法馬上開始寫這份作業來趕上死線\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/98/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq N \\\\leq 2\\\\times 10^ 5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq d_i \\\\leq 10^ 9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NPSC/2005_senior_fin_A/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 位客人來吃飯，其中第一個人的餐點需要煮 $C_i$ 分鐘，且他需要花 $E_i$ 分鐘才能吃完他的餐點。你身為餐廳老闆，你知道你的廚房同一時間只能煮一道料理，但每位客人都可以互相不干涉的享用自己的餐點，而一道料理煮完後便能馬上讓對應的客人開始吃，也就是說，當你在第 $t$ 分鐘開始煮第 $i$ 位客人的餐點，那麼這道餐點會在第 $t+C_i$ 分鐘後煮好，且這位客人一定會在第 $t+C_i+E_i$ 分鐘後享用完畢。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"試求在最佳的烹飪順序下，最後一個人享用完他的餐點時間最早可以多早？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NPSC/2005_senior_fin_A/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N\\\\leq 10000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq C_i, E_i \\\\leq 1000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Codeforces/1433B/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有一個長度為 $n$ 的書架，我們以序列 $a_1, a_2, \\\\ldots, a_n$ 表示這個書架的狀態，$a_i=1$ 代表書架上有書，$a_i=0$ 則代表沒有。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在你可以執行以下操作若干次：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"選擇一個區間，並將區間內的書全部往左或往右移動一格，條件是書不可以重疊、也不可以超出書架的範圍。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"請問你至少要執行幾次操作才能讓所有的書全部相鄰，也就是形成一個連續區間？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Codeforces/1433B/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$t\\\\leq 200$ 筆測資。\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 50$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq a_i\\\\leq 1$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/APCS/201710P4/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 個物品需要被堆在一個垂直的貨架上，已知第 $i$ 個物品的重量是 $w_i$，需要取用 $f_i$ 次，每次取用一個物品就需要將該物品上方的物品貨架升高才能做取用，因此取用一個物品消耗的能量為其上方的物品重量總和，而取用 $f_i$ 次就要花上 $f_i$ 倍的能量。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"請問在最佳的物品擺放順序下，最小的能量消耗總和為何？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/APCS/201710P4/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N\\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq w_i, f_i\\\\leq 1000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/715/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"在卡加布列島上發行的硬幣有 $N$ 種，分別價值 $A_1, A_2, \\\\cdots, A_N$ 塊，已知 $1 = A_1 < A_2 < \\\\cdots < A_N$，而且對於所有可能的 $i$，$A_i$ 是 $A_{i+1}$ 的因數。學姐帶了價值 $K$ 塊錢的小說去卡加布列島想要換成現金，但她希望拿到的硬幣越少越好，作為收銀員的你能滿足學姐的需求嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"（注意到最小硬幣是 $1$ 塊錢，所以一定有辦法換錢）\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/715/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\le N \\\\le 10$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\le K \\\\le 10^ {12}$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\le A_i \\\\le 10^ {12}$,  $\\\\forall$ $i$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$A_1 < A_2 < \\\\cdots < A_N$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$A_i | A_{i+1}$,  $\\\\forall$ $i < N$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/716/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"卡加布列島上發行的硬幣有 $N$ 種，分別價值 $A_1, A_2, \\\\cdots, A_N$ 塊，已知 $1 = A_1 < A_2 < \\\\cdots < A_N$，而且對於所有可能的 $i$，$A_i$ 是 $A_{i+1}$ 的因數。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"學姐這次帶了價值 $K$ 塊錢的遊戲王卡去卡加布列島想要換成現金，她一樣希望拿到的硬幣越少越好。作為收銀員的你，這次每個硬幣的數量都只有 $C_i$ 個可以給學姐換錢，不然你會被老闆罵。這次你能滿足學姐的需求嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因為這裡的最小硬幣是 $1$ 塊錢而且你可以給學姐的 $1$ 塊錢有 $K$ 個，所以一定有辦法換錢，不用考慮無解的狀況。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/716/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\le N \\\\le 10$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\le K \\\\le 10^ {12}$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\le A_i \\\\le 10^ {12}$,  $\\\\forall$ $i$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 = A_1 < A_2 < \\\\cdots < A_N$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$A_i | A_{i+1}$,  $\\\\forall$ $i < N$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$C_1 = K$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\le C_i \\\\le 10^ 9$, $\\\\forall i > 1$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"保證一定有解，不會發生湊不出來的狀況。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/arc134_b/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"給定一個長度為 $N$ 的字串 $s$，你可以執行下方一系列操作一次：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"選擇一個\", _jsx(_components.strong, {\n          children: \"偶數長度\"\n        }), \"的序列滿足 $1\\\\leq x_1< x_2 < \\\\cdots < x_{2k}$，序列長度可以為 $0$。\"]\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"交換 $s_{x_1}$ 和 $s_{x_{2k}}$。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"交換 $s_{x_2}$ 和 $s_{x_{2k-1}}$。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"交換 $s_{x_3}$ 和 $s_{x_{2k-2}}$。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"$\\\\vdots$\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"交換 $s_{x_k}$ 和 $s_{x_{k+1}}$。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"請問在執行一次操作後，得到的字串的最小字典序為何？\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AtCoder/arc134_b/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq N \\\\leq 2\\\\times 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"字串 $s$ 只包含小寫英文字母。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1629/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有 $n$ 場電影，第 $i$ 場電影的開始時間為 $a_i$、結束時間為 $b_i$。在不考慮移動時間的情況下，若你同一時間只能看一場電影，你最多可以看幾場電影？\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1629/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq n \\\\leq 2 \\\\times 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq a_i < b_i \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/721/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"小鴨工廠專門製造黃色小鴨，他們必須和塑膠原料廠訂購塑膠。一共有 $N$ 家塑膠原料廠，其中第 $i$ 家能從第 $s_i$ 天供貨到第 $t_i$ 天。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"小鴨工廠想要選一些原料廠當合作對象。假設最早能供貨的原料廠開始時間是第 $S$ 天，能供貨到最晚的原料廠結束於第 $T$ 天，小鴨工廠希望從 $S$ 到 $T$ 的每天都要與一家原料廠合作。在此限制下，小鴨工廠希望合作廠商愈少愈好，請你回答至少需要幾家廠商。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/721/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\le N\\\\le 1000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\le s_i\\\\le t_i\\\\le 10^ 5$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/74/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"住在月亮上山上的円円族，在舉行完祭月儀式後，並沒有順利解決問題，因為円円族長老所找到願意參加祭月儀式的円円數量實在是太少了。在那之後，由於月相的變異，導致了円円族主食高棕櫚的生產量越來越少，因此円円族們舉辦了部落會議來討論如何解決這個問題。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"為了解決糧食問題，円円族決定要擴展他們的領土。円円族們原本居住在黃河流域（黃河又稱黃 River）北方的月亮山上，因為黃河曾經發展出黃河流域文化，円円族們看上了這一點打算要攻下黃河，佔地為王。經過部落會議之後，円円族們決定推派變態円円們去攻打黃 River。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"居住在黃河流域的居民們得知這件事後，決定建造萬里長城來抵禦円円族的攻擊，請身為建築工程師的你幫忙。萬里長城的特色就是城牆一側總是一高一低的，居民們希望你造的城牆越長越好，而建造城牆的建材是石頭，每塊石頭可能有不同的高度。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但是供應石頭的廠商非常討厭，他每送一塊石頭就會問你要不要買，如果你不買，那塊就永遠不會再賣給你。而且時間非常緊迫，你一買一塊石頭就要馬上用，而且一定要按照購買的順序建造。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"你透過一些內部的管道，得知廠商即將供應給你的石頭高度的順序，你能建造出多長的城牆呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有幾點可能要注意一下：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"石頭不能疊起來，也不能躺下來，不然間隔的接縫會不整齊。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"一定要滿足一塊高一塊低的方式，也就是建造好萬里長城的高度序列若為 $H$ 的話，$H_i$ 滿足 $H_i > H_{i - 1}, H_{i + 1}$ 或 $H_i<H_{i - 1}, H_{i + 1}$。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"城牆的兩側，一定要是比旁邊那塊還高，不然城牆會很醜。若萬里長城長度為 $L$，則滿足 $H_1>H_2, H_{L-1}<H_L$。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"這家廠商相當的優質，每塊石頭的長寬都是一單位，只有高度不均。\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/74/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq N\\\\leq 10^6$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"石頭高度介在 $[1, 2^{31})$ 之間。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1279/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"https://tioj.ck.tp.edu.tw/problems/1546\",\n        children: \"填方格遊戲\"\n      }), \"除了多人模式之外，還有一種不為人所知的單人模式。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有一個 $m$ 乘 $n$ 的方格，每格內有一個非負整數。一開始你的分數是零。每次你都可以選一個還沒被圈過的數，把他圈起來，並且計算出你圈的數字以及與他相鄰（有公共邊）的格子中有圈的那些的總和。算出這個總和之後，將這個總和加到你的分數。繼續這個操作直到整個方格都圈完了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"作為一個單人模式遊戲，你的目標當然是使你自己的分數愈高愈好。然而這個方格有點大，所以你決定藉助程式之力幫你玩這個遊戲。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1279/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq m, n\\\\leq 1000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"方格內的數字皆為小於 $10^9$ 的非負整數。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/733/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"面試麵屋牡丹未果的赤井心，憤而在麵屋牡丹本店對面開了一家烏龍麵，想奪取麵屋牡丹的客源。為了具備和麵屋牡丹對抗的實力，赤井心開始認真研究烏龍麵的配方。她得知了一碗烏龍麵由以下兩個要素組成：麵團配方和調味料配方。\", _jsx(_components.br, {}), \"\\n\", \"於是赤井心備齊了 $N$ 種麵團和 $N$ 種調味料，準備大展身手，搭配出 $N$ 碗烏龍麵。她發現每種麵團都與特定一種調味料會產生「絕配」。當第 $i$ 種麵團和某種調味料是絕配，會產生 $c_i$ 的美味程度；但也可能搭配特定一種調味料後會製造出地獄組合，損失 $d_i$ 點的美味程度。\", _jsx(_components.br, {}), \"\\n\", \"如果某組麵團和調味料的搭配不是絕配，也不是地獄組合則美味程度為 $0$。浪費食材是不可饒恕的事，因此一種麵團一定跟洽一種調味料搭配，一種調味料也跟洽一種麵團搭配。\", _jsx(_components.br, {}), \"\\n\", \"沒有學過演算法的赤井心來找你幫忙，她聽說你是個演算法高手。你能想辦法讓總美味程度最大嗎?\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/733/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq N\\\\leq 5\\\\times 10^ 5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1\\\\leq a_i\\\\leq N$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq b_i\\\\leq N$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0\\\\leq c_i,d_i\\\\leq 10^ 9$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$a_i\\\\neq b_i$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/727/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"一臺圖靈機是擁有一個讀針和\", _jsx(_components.strong, {\n        children: \"無限\"\n      }), \"長的一張充滿格子的紙當作記憶體的機器。今天，你發現圖靈機掉落了 $N$ 張紙片，其中第 $i$ 張上面恰好寫滿了一個由小寫英文字母所組成的字串 $s_i$！你知道，圖靈機在壞掉之前想要做的事是：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"請將所有的 $s_i$ 排列，使得排列之後將這些字串頭接著尾黏起來的字典序最小。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"舉例來說，假設你有三個字串 $[ab, abc, b]$，那如果排成 $[ab, b, abc]$ 的話，就會比 $[abc, b, ab]$ 還要小，因為前者拼起來是 \", _jsx(_components.code, {\n        children: \"abbabc\"\n      }), \" 而後者拼起來是 \", _jsx(_components.code, {\n        children: \"abcbab\"\n      }), \"。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/727/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq N, \\\\sum |s_i| \\\\leq 10^ 5$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"自己找出「選擇」","depth":1,"code":"自己找出「選擇」"},{"text":"「證明」你的策略","depth":1,"code":"「證明」你的策略"},{"text":"目標本質法","depth":2,"code":"「證明」你的策略-目標本質法"},{"text":"反證法","depth":2,"code":"「證明」你的策略-反證法"},{"text":"逆序數對證明法","depth":2,"code":"「證明」你的策略-逆序數對證明法"},{"text":"反過來利用證明方法解題","depth":1,"code":"反過來利用證明方法解題"},{"text":"目標本質法","depth":2,"code":"反過來利用證明方法解題-目標本質法"},{"text":"逆序數對法","depth":2,"code":"反過來利用證明方法解題-逆序數對法"},{"text":"習題","depth":1,"code":"習題"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}