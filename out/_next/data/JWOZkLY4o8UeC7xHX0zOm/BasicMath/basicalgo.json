{"pageProps":{"props":{"mdxPath":"guide/content/BasicMath/basicalgo/basicalgo.mdx","code":"BasicMath/basicalgo","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"廣度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["AlgorithmTechnique/dfs"],"coming":false},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"分治法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting","BasicAlgorithm/recursion","BasicAlgorithm/two_pointers"],"coming":false},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"深度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/structured_binding","BasicAlgorithm/recursion","BasicAlgorithm/enumerate","BasicDataStructure/binary_tree"],"coming":false},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","ImplementationKnowledge/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/backtracking","article":"backtracking","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 回溯","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/basic_optimization","article":"basic_optimization","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 的基本優化","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/structure"],"coming":true},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":false},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":false},{"code":"BasicDynamicProgramming/range_dp","article":"range_dp","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"區間 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/structure","article":"structure","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"動態規劃的必要元素","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","ImplementationSkill/buglist"],"coming":false},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":true,"title":"二分圖","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":true,"title":"圖論基礎","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicAlgorithm/searching","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","AlgorithmTechnique/bfs","AlgorithmTechnique/dfs"],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":true,"title":"單調隊列","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicDataStructure/stack_queue_deque","BasicAlgorithm/sweep"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 III","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/unintuitive_greedy","BasicDataStructure/set_map","BasicAlgorithm/partial_sum","BasicAlgorithm/binary_search_answer"],"coming":false},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 II","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/basic_knowledge","article":"basic_knowledge","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"ImplementationKnowledge/compiler","article":"compiler","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/float_error","article":"float_error","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/input","article":"input","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"ImplementationKnowledge/reference","article":"reference","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/rngbased","article":"rngbased","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Range-based for loop","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/reference","BasicDataStructure/vector"],"coming":false},{"code":"ImplementationKnowledge/structured_binding","article":"structured_binding","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"Structured Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/variable","article":"variable","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/reference","ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationKnowledge/variable_declare","article":"variable_declare","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常用變數宣告方法","authors":["WiwiHo","baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/buglist","article":"buglist","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/debug","article":"debug","topic":"ImplementationSkill","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["ImplementationSkill/buglist"],"coming":false},{"code":"ImplementationSkill/error_message","article":"error_message","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationSkill/pseudo_pointer","article":"pseudo_pointer","topic":"ImplementationSkill","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"ImplementationKnowledge","title":"實作知識","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error"]},{"code":"ImplementationSkill","title":"實作技巧","contents":["ImplementationSkill/error_message","ImplementationSkill/buglist","ImplementationSkill/debug","ImplementationSkill/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","BasicDynamicProgramming/basic_optimization","BasicDynamicProgramming/range_dp","BasicDynamicProgramming/backtracking"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["ImplementationKnowledge"]},{"single":true,"title":"","topics":["ImplementationSkill"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationSkill/error_message","ImplementationSkill/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error","ImplementationSkill/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/BasicMath/basicalgo/basicalgo.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Info, Problem, Proof, Refcode, Theorem, TheoremReference} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Proof) _missingMdxReference(\"Proof\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  if (!Theorem) _missingMdxReference(\"Theorem\", true);\n  if (!TheoremReference) _missingMdxReference(\"TheoremReference\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"模運算\",\n      children: \"模運算\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"「取餘數」，也就是 C++ 中的 \", _jsx(_components.code, {\n        children: \"%\"\n      }), \" 運算子，是一個在程式競賽中很常使用到的運算，除了餘數本身的性質有許多派上用場的時機之外，也有許多題目是因為答案非常大，而要求要先把答案取個餘數後再輸出。「取餘數」這個運算有個名字叫作\", _jsx(_components.strong, {\n        children: \"模運算\"\n      }), \"（modulo），也叫作模或模除，在寫數學式子的時候通常會寫成 $\\\\bmod$，例如 $5 \\\\bmod 2$ 就是取 $5$ 除以 $2$ 的餘數，也就是 $1$，讀作「五模除二」（更多時候會簡稱成「五模二」）或是「$5$ modulo $2$」。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"模運算-C++ 中的除法與模運算\",\n      children: \"C++ 中的除法與模運算\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"在這個小節中，寫成等寬字體的 \", _jsx(_components.code, {\n          children: \"a / b\"\n        }), \" 是指 C++ 程式碼之中的整數除法，數學字體 $a / b$ 或 $\\\\frac{a}{b}$ 是指數學上除法的結果，也就是沒有經過取整的有理數。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 就是 \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" 除以 \", _jsx(_components.code, {\n        children: \"b\"\n      }), \" 取餘數這件事情聽起來非常簡單，畢竟我們國小就學過怎麼取餘數了，不過這件事情其實沒有表面上這麼單純──如果哪天我們需要對負數進行模運算怎麼辦？$-5 \\\\div 3$ 應該是 $-5 \\\\div 3 = -1 \\\\ldots -2$ 還是 $-5 \\\\div 3 = -2 \\\\ldots 1$？在 C++ 中，\", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 就等同於 \", _jsx(_components.code, {\n        children: \"a - a / b * b\"\n      }), \"，而在 C++ 裡面的整數除法是「向零取整」，也就是除完的結果不是整數的時候，會取比較靠近 0 的那個整數，所以 \", _jsx(_components.code, {\n        children: \"-5 / 3\"\n      }), \" 的結果會是 \", _jsx(_components.code, {\n        children: \"-1\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"-5 % 3\"\n      }), \" 的結果會是 \", _jsx(_components.code, {\n        children: \"-5 - (-5) / 3 * 3 == -2\"\n      }), \"，\", _jsx(_components.code, {\n        children: \"5 / -3\"\n      }), \" 的結果也是 \", _jsx(_components.code, {\n        children: \"-1\"\n      }), \"，不過 \", _jsx(_components.code, {\n        children: \"5 % -3\"\n      }), \" 的結果是 \", _jsx(_components.code, {\n        children: \"5 - 5 / (-3) * (-3) == 2\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，在實際的使用上，大多時候我們的模數 $b$ 都是正整數，而且我們其實會比較希望 $a \\\\bmod b$ 是一個非負整數，也就是 $a \\\\bmod b$ 的定義是\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"definition\",\n      title: \"模運算\",\n      number: \"1\",\n      children: _jsx(_components.p, {\n        children: \"$a \\\\bmod b$ 是將 $a$ 表示成 $kb+r$、$k$ 是整數時，最小的可能的非負整數 $r$。在這個時候，$k$ 會是 $\\\\lfloor \\\\frac ab \\\\rfloor$，而 $r$ 肯定是 $[0, \\\\lvert b \\\\rvert)$ 之間的整數。\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果在對一個負數取模的時候，希望獲得非負的餘數，也就是 $a - \\\\lfloor \\\\frac ab \\\\rfloor b$ 的話，可以寫成 \", _jsx(_components.code, {\n        children: \"(a % b + b) % b\"\n      }), \"，這樣就一定會得到 $[0,b)$ 之內的結果了。這麼做的原因是因為 \", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 肯定是一個在 $(-b,b)$ 之內的整數，加上 $b$ 之後肯定會變成 $\\\\geq 0$，最後需要再模 $b$ 一次是因為有可能本來 \", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 的結果就是 $\\\\geq 0$ 了，這樣 $+b$ 之後會 $\\\\geq b$，所以要再模一次。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"注意 \", _jsx(_components.code, {\n          children: \"(a % b + b) % b\"\n        }), \" 這個寫法需要 $b > 0$。\"]\n      })\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"tips\",\n      title: \"整數除法\",\n      number: \"1\",\n      children: [_jsxs(_components.p, {\n        children: [\"剛剛提到 \", _jsx(_components.code, {\n          children: \"a / b\"\n        }), \" 會「向零取整」，也就是在 $\\\\frac ab$ 的結果是正時會向下取整（$\\\\lfloor \\\\frac ab \\\\rfloor$）、是負時會向上取整（$\\\\lceil \\\\frac ab \\\\rceil$），那麼要怎麼實作向下取整或向上取整的運算呢？不要使用 \", _jsx(_components.code, {\n          children: \"<cmath>\"\n        }), \" 提供的 \", _jsx(_components.code, {\n          children: \"floor\"\n        }), \" 和 \", _jsx(_components.code, {\n          children: \"ceil\"\n        }), \" 函數，因為它們都是浮點數運算，會有浮點數誤差的問題，正確的作法是：\"]\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"如果 $a,b$ 同號，那 $\\\\frac ab$ 本來就是正的，可以放心算 \", _jsx(_components.code, {\n            children: \"a / b\"\n          }), \"。\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"如果 $a,b$ 異號，那 $\\\\frac ab$ 就是負的，\", _jsx(_components.code, {\n            children: \"a / b\"\n          }), \" 就是 $\\\\lceil \\\\frac ab \\\\rceil$，如果 $\\\\frac ab$ 不整除的話，$\\\\lfloor \\\\frac ab \\\\rfloor=\\\\lceil \\\\frac ab \\\\rceil - 1$，所以答案是 \", _jsx(_components.code, {\n            children: \"a / b - 1\"\n          }), \"。\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"模運算-同餘與模下的運算\",\n      children: \"同餘與模下的運算\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"剛剛我們其實做了一些不太容易理解的事情：把 $a$ 先模 $b$、再加上 $b$、再模 $b$，這樣答案真的跟 $a \\\\bmod b$ 一樣嗎？要暸解為什麼可以這樣，我們先來暸解同餘的概念：\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"definition\",\n      title: \"同餘\",\n      number: \"2\",\n      children: _jsx(_components.p, {\n        children: \"$a \\\\equiv b \\\\pmod m$ 的條件是 $m \\\\mid (a - b)$，也就是 $\\\\frac{a-b}{m}$ 整除。這個式子完整讀作「$a$ 跟 $b$ 在模 $m$ 下同餘」。\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再寫一次模運算的定義：$k = \\\\lfloor \\\\frac ab \\\\rfloor$、$r = a \\\\bmod b$ 時，$a = kb+r$，移項一下就變成 $\\\\frac{a - r}{b} = k$，而 $k$ 是一個整數，因此 $a \\\\equiv r \\\\pmod{b}$。很明顯地\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\[ a \\\\equiv b \\\\pmod m \\\\iff a \\\\bmod m = b \\\\bmod m \\\\]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也就是模 $m$ 後一樣的數字就同餘。$\\\\equiv$ 這符號跟 $=$ 長得很像，從某種角度來說，可以視為同餘就是「在模運算之下的等於」，它跟等於有多像呢？\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"lemma\",\n      title: \"同餘的遞移律\",\n      number: \"1\",\n      children: _jsx(_components.p, {\n        children: \"對於任意整數 $a,b,c$、正整數 $m$，如果 $a \\\\equiv b \\\\equiv c \\\\pmod m$，就代表 $a \\\\equiv c$。\"\n      })\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"lemma\",\n      title: \"同餘的運算\",\n      number: \"2\",\n      children: [_jsx(_components.p, {\n        children: \"對於任意整數 $a,b,c$、正整數 $m$，如果 $a \\\\equiv b \\\\pmod m$，那麼：\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"$a + c \\\\equiv b + c \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a - c \\\\equiv b - c \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a \\\\times c \\\\equiv b \\\\times c \\\\pmod m$\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這些的證明都很簡單，只要代入同餘的定義即可，讀者可以練習看看。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以說，$\\\\equiv$ 兩邊的兩個數字一起加減乘一個數字，都不會改變它們同餘的關係，而且還有遞移律，就跟我們平常認識的 $=$ 很像！不過也有一些不一樣的地方，注意到我們只提到「加減乘」，但四則運算中的除法並沒有跟它們一起出現，這是因為把兩邊除上一個數後，不見得會保持同餘關係，先不談不整除的時候不知該怎麼辦，光是整除的狀況就可能會出問題，像是 $6 \\\\equiv 12 \\\\pmod 6$，但是如果把兩邊各自除以 $3$，$2 \\\\equiv 4 \\\\pmod 6$ 顯然是錯的。\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"有一個真實存在的性質是當 $c$ 是 $a,b,m$ 的公因數時，$\\\\frac{a}{c} \\\\equiv \\\\frac{b}{c} \\\\pmod{\\\\frac{m}{c}}$，但通常改變模數並不是我們想要的，之後的篇章會再處理除法的問題，這裡我們先不討論。\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然同餘類似於某種「等於的關係」，那其實可以更進一步地說：\"\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"lemma\",\n      title: \"同餘的運算 2\",\n      refId: \"mod2\",\n      number: \"3\",\n      children: [_jsx(_components.p, {\n        children: \"對於任意整數 $a,b,c,d$、正整數 $m$，如果 $a \\\\equiv b \\\\pmod m$ 且 $c \\\\equiv d \\\\pmod m$，那麼：\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"$a + c \\\\equiv b + d \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a - c \\\\equiv b - d \\\\pmod m$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"$a \\\\times c \\\\equiv b \\\\times d \\\\pmod m$\"\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"回來看看我們剛剛寫過的式子：\", _jsx(_components.code, {\n        children: \"(a % b + b) % b\"\n      }), \"，雖然 \", _jsx(_components.code, {\n        children: \"% b\"\n      }), \" 出來的結果可能是負的，但它總是個取餘數的運算，\", _jsx(_components.code, {\n        children: \"a % b\"\n      }), \" 的結果永遠都會跟 $a$ 在模 $b$ 下同餘。所以：\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"\\\\begin{align*}\", _jsx(_components.br, {}), \"\\n\", \"& ((a\\\\ \\\\texttt{%}\\\\ b) + b)\\\\ \\\\texttt{%}\\\\ b \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\equiv\\\\ & (a\\\\ \\\\texttt{%}\\\\ b) + b & (\\\\texttt{%}\\\\text{ 會保持同餘}) \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\equiv\\\\ & a\\\\ \\\\texttt{%}\\\\ b & (\\\\texttt{\\\\(b\\\\) 跟 \\\\(0\\\\) 同餘}) \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"\\\\equiv\\\\ & a & (\\\\texttt{%}\\\\text{ 會保持同餘}) \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"& (\\\\text{mod}\\\\ \\\\ b)\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{align*}\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"得到結果真的會跟 $a$ 模 $b$ 下同餘，我們又知道運算結果是一個 $[0, b)$ 以內的數，所以這個答案就只能是 $a \\\\bmod b$ 了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"模運算-運算過程取模\",\n      children: \"運算過程取模\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在那種「因為答案很大所以要取模再輸出」的題目中，很有可能光是在運算過程中，數字就會大到 \", _jsx(_components.code, {\n        children: \"long long int\"\n      }), \" 也存不下，所以算完最後再取模肯定是不行的！舉例來說，我們想要算 $2^{100} \\\\bmod 10^9+7$，雖然答案是個連 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 都存的下的數，但要是我們先算完 $2^{100}$ 再模，那一般的整數型態肯定存不下。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(TheoremReference, {\n        type: \"lemma\",\n        refId: \"mod2\",\n        number: \"3\",\n        title: \"同餘的運算 2\",\n        mode: \"title\"\n      }), \" 其實也告訴了我們，在加減乘運算之前先把數字模一次，也不會改變運算結果，所以其實可以寫成\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"const long long MOD = 1'000'000'007;\\nlong long ans = 1;\\nfor (int i = 0; i < 100; i++) {\\n    ans = ans * 2 % MOD;\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以得到正確的 $2^{100} \\\\bmod 10^9 + 7$。在做這種題目的時候，可以每做一次運算就模一次，這樣就不會溢位了。\"\n    }), \"\\n\", _jsxs(Info, {\n      type: \"info\",\n      children: [_jsx(_components.p, {\n        children: \"世人其實對於 $\\\\bmod$ 和其他運算符號的優先順序沒有什麼共識，所以在有各種運算交錯出現時，最好還是加個括號才比較不容易搞混。一般來說，$a \\\\bmod 10^9+7$ 就是 $a \\\\bmod (10^9+7)$ 的意思，因為這個式子單獨出現時不太會搞混所以經常省略括號。\"\n      }), _jsxs(_components.p, {\n        children: [\"注意在 C++ 中 \", _jsx(_components.code, {\n          children: \"%\"\n        }), \" 的優先度比 \", _jsx(_components.code, {\n          children: \"+\"\n        }), \" 高、和 \", _jsx(_components.code, {\n          children: \"*\"\n        }), \" 跟 \", _jsx(_components.code, {\n          children: \"/\"\n        }), \" 同級，在寫程式的時候要特別注意加減乘模的優先順序，例如 \", _jsx(_components.code, {\n          children: \"a + b % MOD\"\n        }), \" 的意思其實是 \", _jsx(_components.code, {\n          children: \"a + (b % MOD)\"\n        }), \" 而非 \", _jsx(_components.code, {\n          children: \"(a + b) % MOD\"\n        }), \"。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"模運算-除法很慢\",\n      children: \"除法很慢\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"/\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"%\"\n      }), \" 這兩個運算比 \", _jsx(_components.code, {\n        children: \"+-*\"\n      }), \" 慢很多！在運算量很大（如超過 $10^8$）的時候，要是每次加減乘完都模一次，時限又設比較緊的話，就有可能會 TLE。有一些減少模運算次數又不會溢位的小技巧：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"兩個 $[0,m)$ 之內的數相加肯定 $<2m$，所以可以把直接模 $m$ 改成 \", _jsx(_components.code, {\n          children: \"if (ans >= m) ans -= m;\"\n        }), \"。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"減法也是同理，可以改成 \", _jsx(_components.code, {\n          children: \"if (ans < 0) ans += m;\"\n        }), \"。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"一大堆已經取模過的數相加，不會溢位就可以全部加起來再取模，例如模 $10^9+7$ 時，$10^6$ 個 $10^9+6$ 相加都不會超過 \", _jsx(_components.code, {\n          children: \"long long int\"\n        }), \" 範圍，可以放心地最後再模。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過乘法完通常就非模不可了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"快速冪\",\n      children: \"快速冪\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"剛才我們學會怎麼在不溢位的前提下算出 $2^{100} \\\\bmod 10^9+7$，進階一點，如果我們要算的是 $a^b \\\\bmod m$ 呢？\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1095\",\n      src: \"CSES 1095\",\n      name: \"Exponentiation\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/CSES/1095/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1095/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1095/description.mdx\",\n      importMdx: \"guide/problems/CSES/1095/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"慢慢地把 $a$ 乘 $b$ 次是不行的，那得花上 $O(b)$ 的時間，所以我們得想辦法把指數運算算得更快。在國中的時候，我們有學過指數律：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\[ a^b \\\\times a^c = a^{b+c} \\\\]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"前面我們計算 $a^b$ 的方法，就是直接算 $a^{b-1} \\\\times a = a^b$，所以我們會依序算出 $a^1,a^2,\\\\dots,a^b$，不過我們需要知道的只有最後那個 $a^n$ 而已，可不可以少知道一點？一種想法是我們乾脆把 $b$「分一半」，如果 $b$ 是個偶數 $b=2k$，那我們知道 $a^b=(a^k)^2$，只需要知道 $a^k=a^{b/2}$ 就能算出 $a^b$ 了。照著這個邏輯，要是 $b$ 是個二的冪次 $b=2^k$ 那就很快樂，因為我們只需要一直把 $a$ 平方，就會依序得出\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\\\[ a=a^{2^0}, \\\\quad (a^{2^0})^2=a^{2^1}, \\\\quad (a^{2^1})^2 = a^{2^2}, \\\\quad \\\\dots, \\\\quad a^{2^k}=a^b \\\\]\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"只要花 $O(k)=O(\\\\log b)$ 的時間就能得到 $a^b$ 了！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果 $b$ 不是二的冪次，就代表我們一直除以 2 的話，總有一天會變成一個奇數，這時我們就不能直接分一半了。解決辦法很簡單，把它變成偶數就好了嘛，在 $b$ 是奇數 $b = 2k+1$ 的時候，就有 $a^b=(a^k)^2 \\\\times a$，其實也只要算 $a^k=a^{(b-1)/2}$ 就好了。這樣一來，我們可以先得到一個遞迴的算法：\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"a^b = \\\\begin{cases}\", _jsx(_components.br, {}), \"\\n\", \"(a^{b/2})^2, &\\\\qquad \\\\text{if \\\\(b\\\\) 是偶數} \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"(a^{(b-1)/2})^2 \\\\times a, &\\\\qquad \\\\text{if \\\\(b\\\\) 是奇數}\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{cases}\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"每次遞迴時 $b$ 就會少一半，所以時間複雜度就是 $O(\\\\log b)$。仔細想想，其實這個過程就等同於去看 $b$ 的\", _jsx(_components.strong, {\n        children: \"二進位分解\"\n      }), \"：\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[ b = \\\\underbrace{b_{\\\\lfloor \\\\log_2 b \\\\rfloor} \\\\dots b_1b_0}_{\\\\text{寫成二進位}}\", _jsx(_components.br, {}), \"\\n\", \"= b_{\\\\lfloor \\\\log_2 b \\\\rfloor} \\\\times 2^{\\\\lfloor \\\\log_2 b \\\\rfloor} + \\\\dots + b_1 \\\\times 2^1 + b_0 \\\\times 2^0 \\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"舉例來說，\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"182_{(10)} = 10110110_{(2)} = 2^7 + 2^5 + 2^4 + 2^2 + 2^1\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"a^{182} = a^{2^7} \\\\times a^{2^5} \\\\times a^{2^4} \\\\times a^{2^2} \\\\times a^{2^1}\", _jsx(_components.br, {}), \"\\n\", \"\\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"右邊的東西就是一堆「$a$ 的二的冪次次方」相乘，剛剛我們就已經知道這要怎麼算了，所以可以輕鬆寫成迴圈版本：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"using ll = long long;\\nconst ll MOD = 1'000'000'007;\\nll fastpow(ll a, ll b) {\\n    ll ans = 1;\\n    while (b > 0) {\\n        if (b & 1) ans = ans * a % MOD;\\n        a = a * a % MOD;\\n        b >>= 1;\\n    }\\n    return ans;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在那個 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈第 $i$ 次執行（從 $0$ 開始數）時，當下的 \", _jsx(_components.code, {\n        children: \"a\"\n      }), \" 會是 $a^{2^i}$，\", _jsx(_components.code, {\n        children: \"b\"\n      }), \" 會是 $b$ 少掉最右邊的 $i$ 個 bit，所以 \", _jsx(_components.code, {\n        children: \"b & 1\"\n      }), \" 是在檢查「$b$ 的第 $i$ 個 bit 是不是 1」，是的話就把答案乘上 $a^{2^i}$。用個簡單的小例子，$b=13=1101_{(2)}$，在每次迴圈開始的時候：\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"$i=0$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^0,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^1,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 13 = 1101_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 1，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 被更新成 $a^1$。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"$i=1$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^1,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^2,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 6 = 110_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 0，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 不變。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"$i=2$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^1,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^4,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 3 = 11_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 1，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 被更新成 $a^5$。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"$i=3$：\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" $=a^5,$ \", _jsx(_components.code, {\n          children: \"a\"\n        }), \" $= a^8,$ \", _jsx(_components.code, {\n          children: \"b\"\n        }), \" $= 1 = 1_{(2)}$，\", _jsx(_components.code, {\n          children: \"b & 1\"\n        }), \" 是 1，\", _jsx(_components.code, {\n          children: \"ans\"\n        }), \" 被更新成 $a^{13}$。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.code, {\n          children: \"b\"\n        }), \" 變成 0 了，迴圈結束。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"時間複雜度和遞迴版本同樣是 $O(\\\\log b)$。\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"warning\",\n      children: _jsxs(_components.p, {\n        children: [\"不要直接用 \", _jsx(_components.code, {\n          children: \"<cmath>\"\n        }), \" 裡面的 \", _jsx(_components.code, {\n          children: \"pow()\"\n        }), \"！那是一個浮點數函數。\"]\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"輾轉相除法\",\n      children: \"輾轉相除法\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"國小的時候，老師教我們用短除法計算兩個數 $a,b$ 的最大公因數，作法是先神祕地通靈出一個它們的共同因數 $d$ 之後，把它們都除以 $d$，然後反覆這個動作，直到它們互質為止，過程中所有 $d$ 相乘就是最大公因數了。不過寫程式的時候，我們無法看著數字就猜一個公因數出來，要是像我們在\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicAlgorithm/math_in_school\",\n        mode: \"default\",\n        topicTitle: \"基礎演算法\",\n        articleTitle: \"學校教的數學\"\n      }), \"枚舉因數那樣做的話也得要花 $O(\\\\max(\\\\sqrt{a},\\\\sqrt{b}))$ 的時間。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"要更快算出最大公因數的話，就要用到輾轉相除法了，輾轉相除法也叫作歐幾里得演算法（Euclidean algorithm），它用到一個最大公因數的性質：\"\n    }), \"\\n\", _jsx(Theorem, {\n      type: \"lemma\",\n      title: \"輾轉相除法\",\n      number: \"4\",\n      children: _jsx(_components.p, {\n        children: \"$\\\\gcd(a,b) = \\\\gcd(a,b-a)$，其中 $\\\\gcd(a,b)$ 是 $a,b$ 的最大公因數，$\\\\gcd(a,0)=\\\\gcd(0,a)=a$。\"\n      })\n    }), \"\\n\", _jsxs(Proof, {\n      expanded: \"false\",\n      children: [_jsx(_components.p, {\n        children: \"對於任意一個 $a,b$ 的公因數 $d$，令 $a=a'd,b=b'd$，我們有 $b-a=(b'-a')d$，仍是一個 $d$ 的倍數，所以 $d$ 是 $a,b-a$ 的公因數。\"\n      }), _jsx(_components.p, {\n        children: \"對於任意一個 $a,b-a$ 的公因數 $d$，令 $a=a'd, b-a=td$，我們有 $b=(t+a')d$，仍是一個 $d$ 的倍數，所以 $d$ 是 $a,b$ 的公因數。\"\n      }), _jsx(_components.p, {\n        children: \"總的來說，$d$ 是 $a,b$ 的公因數若且唯若 $d$ 是 $a,b-a$ 的公因數。\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"輾轉相除法的作法很簡單，就是不斷把 $a,b$ 之中大的減去小的，有一個變成 $0$ 之後就直接回傳另一個數字。不過一直慢慢減不見得很快，要是 $a$ 很大、$b=1$，那就要減到天荒地老了，比較聰明的作法是直接令 $a \\\\gets a \\\\bmod b$，畢竟 $a$ 一直扣掉 $b$ 直到變成比 $b$ 還小，那不就是 $a$ 模 $b$ 嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣真的很快嗎？分析一下時間複雜度，假設 $a > b$，那事實上 $a \\\\bmod b \\\\leq a/2$，因為要是 $b \\\\leq a/2$ 那自然是對的，如果 $b > a/2$ 的話，那麼 $a \\\\bmod b = a - b < a/2$，所以每一次都有其中一個數會少一半，時間複雜度就是 $O(\\\\log a + \\\\log b)$。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其實在只是要用最大公因數的時候，不需要自己寫輾轉相除法，從 C++17 開始 \", _jsx(_components.code, {\n        children: \"<numeric>\"\n      }), \" 提供 \", _jsx(_components.code, {\n        children: \"gcd()\"\n      }), \" function，內部的實作就是用輾轉相除法，開心地用下去就好了。在更低的版本的話，在 \", _jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \" 裡面有一個叫作 \", _jsx(_components.code, {\n        children: \"__gcd()\"\n      }), \" 的 function，不過要注意這個 function 不在標準之中，能用 \", _jsx(_components.code, {\n        children: \"gcd\"\n      }), \" 還是用 \", _jsx(_components.code, {\n        children: \"gcd\"\n      }), \" 比較好。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那為什麼要學輾轉相除法呢？不久後就知道了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"質數篩法\",\n      children: \"質數篩法\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"檢查一個數 $n$ 是不是質數可以 $O(\\\\sqrt{n})$ 時間內做到，但是如果我們想要找 $1$ 到 $n$ 內的所有質數，花上 $O(n\\\\sqrt{n})$ 的時間一一檢查好像太慢了，這時就要用更聰明的辦法找質數了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"一個直覺的想法是，我們枚舉 $2$ 到 $n$ 的每一個數 $i$，但我們不是要檢查 $i$ 是不是質數，而是去把 $i$ 的兩倍以上倍數都標記成「不是質數」，而沒被標記的那些數就是質數了。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"vector<bool> sieve1(int n) { // prime[i] = i 是不是質數\\n    vector<bool> prime(n + 1, true);\\n    prime[0] = prime[1] = false;\\n    for (int i = 2; i <= n; i++)\\n        for (int j = 2 * i; j <= n; j += i)\\n            prime[j] = false;\\n    return prime;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"聽起來好暴力，但這其實很快，被枚舉到的倍數數量會是\", _jsx(_components.br, {}), \"\\n\", \"\\\\[ \\\\frac{n}{1} + \\\\frac{n}{2} + \\\\dots + \\\\frac{n}{n} = O(n \\\\log n) \\\\]\", _jsx(_components.br, {}), \"\\n\", \"正整數的倒數和 $\\\\frac{1}{1}+\\\\frac{1}{2}+\\\\dots+\\\\frac{1}{n}$ 叫作\", _jsx(_components.a, {\n        href: \"https://zh.wikipedia.org/zh-tw/%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0\",\n        children: \"調和級數\"\n      }), \"，它的成長率就是 $O(\\\\log n)$，調和級數很常見，在需要枚舉「$1$ 到 $n$ 所有數字在 $n$ 以內的倍數」或是「$1$ 到 $n$ 所有數字的因數」時，要記得總數就只有 $O(n \\\\log n)$ 那麼多。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過篩質數還可以更快！其實我們剛剛做了一些多餘的事情：要是我們已經知道 $i$ 不是質數了，那代表我們曾經用一個它的因數 $x$ 來把它標記成不是質數，而這個 $x$ 當然也已經去砍掉所有 $i$ 的倍數了，因此不是質數的 $i$ 我們就可以跳過：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"vector<bool> sieve2(int n) {\\n    vector<bool> prime(n + 1, true);\\n    prime[0] = prime[1] = false;\\n    for (int i = 2; i <= n; i++)\\n        if (prime[i])\\n            for (int j = 2 * i; j <= n; j += i)\\n                prime[j] = false;\\n    return prime;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這有比較快嗎？有，\", _jsx(_components.a, {\n        href: \"https://zh.wikipedia.org/zh-tw/%E7%B4%A0%E6%95%B0%E7%9A%84%E5%80%92%E6%95%B0%E4%B9%8B%E5%92%8C\",\n        children: \"質數的倒數和\"\n      }), \"成長率是 $O(\\\\log \\\\log n)$，所以這麼做的時間複雜度只要 $O(n \\\\log \\\\log n)$，幾乎跟線性一樣快了，還可以順便知道每個數的質因數。\"]\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"tips\",\n      title: \"因數與質因數的數量\",\n      number: \"2\",\n      children: [_jsx(_components.p, {\n        children: \"一個數 $x$ 會有幾個因數和幾個質因數呢？因為每個質因數都 $\\\\geq 2$，所以 $x$ 的質因數數量是 $O(\\\\log n)$。至於因數數量，如果先找好質因數分解\"\n      }), _jsx(_components.p, {\n        children: \"\\\\[ x = p_1^{e_1} \\\\times p_2^{e_2} \\\\times \\\\dots \\\\times p_k^{e_k} \\\\]\"\n      }), _jsx(_components.p, {\n        children: \"的話，就可以枚舉每個質因數要取幾個，用 $O(\\\\text{因數數量})$ 的時間找到所有因數。在競賽中常見的 $x \\\\leq 10^{9}$ 與 $x \\\\leq 10^{18}$ 範圍中，因數數量最多分別是 $1344$ 與 $103680$，打競賽時通常會直接用 $O(x^{\\\\frac{1}{3}})$ 去算。不過實際上，一個數的因數數量是 $o(x^\\\\epsilon)\\\\ \\\\forall \\\\epsilon > 0$，也就是說，在 $x$ 很大的時候其實是遠少於 $x^{\\\\frac{1}{3}}$ 的。\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=a024\",\n      src: \"ZeroJudge a024\",\n      name: \"最大公因數（GCD）\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/ZeroJudge/a024/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/a024/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a024/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a024/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://oj.ntucpc.org/problems/100\",\n      src: \"NCOJ 100\",\n      name: \"[Tutorial] 找質數\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/NCOJ/100/description.mdx\",\n      constraintsMdx: \"guide/problems/NCOJ/100/constraints.mdx\",\n      importMdx: \"guide/problems/NCOJ/100/description.mdx\",\n      importMdx: \"guide/problems/NCOJ/100/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以試試看用 $O(C \\\\log C)$（$C=$ $x$ 的值域大小）的時間做出這題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1713\",\n      src: \"CSES 1713\",\n      name: \"Counting Divisors\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/CSES/1713/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1713/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1713/description.mdx\",\n      importMdx: \"guide/problems/CSES/1713/constraints.mdx\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"請試試用類似於快速冪的作法做出這題，請不要寫大數運算，也不要用如 \", _jsx(_components.code, {\n        children: \"__int128\"\n      }), \" 等範圍較大的整數型態：\"]\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=b430\",\n      src: \"ZeroJudge b430\",\n      name: \"簡單乘法\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/ZeroJudge/b430/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/b430/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b430/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b430/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1095/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給你非負整數 $a,b$，求 $a^b \\\\bmod 10^9+7$。特別地，定義 $0^0=1$。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1095/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"有 $1 \\\\leq n \\\\leq 2 \\\\times 10^5$ 個詢問\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 \\\\leq a,b \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a024/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給兩個整數 $a,b$，求它們的最大公因數。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a024/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq a,b < 2^{31}$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/100/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給你一個 $\\\\geq 2$ 的正整數 $N$，請輸出所有 $[1,N]$ 之間的質數。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NCOJ/100/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$2 \\\\leq N \\\\leq 10^ 6$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1713/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給 $n$ 個數 $x$，求每個 $x$ 的因數數量。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1713/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq x \\\\leq 10^6$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b430/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給 $a,b,n$，求 $ab \\\\bmod n$。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b430/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"有多筆測資\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 \\\\leq a,b \\\\leq 10^{18}$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 10^{18}$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"模運算","depth":1,"code":"模運算"},{"text":"C++ 中的除法與模運算","depth":2,"code":"模運算-C++ 中的除法與模運算"},{"text":"同餘與模下的運算","depth":2,"code":"模運算-同餘與模下的運算"},{"text":"運算過程取模","depth":2,"code":"模運算-運算過程取模"},{"text":"除法很慢","depth":2,"code":"模運算-除法很慢"},{"text":"快速冪","depth":1,"code":"快速冪"},{"text":"輾轉相除法","depth":1,"code":"輾轉相除法"},{"text":"質數篩法","depth":1,"code":"質數篩法"},{"text":"習題","depth":1,"code":"習題"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}