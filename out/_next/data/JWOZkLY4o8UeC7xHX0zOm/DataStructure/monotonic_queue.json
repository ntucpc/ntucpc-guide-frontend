{"pageProps":{"props":{"mdxPath":"guide/content/DataStructure/monotonic_queue/monotonic_queue.mdx","code":"DataStructure/monotonic_queue","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"廣度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["AlgorithmTechnique/dfs"],"coming":false},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"分治法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting","BasicAlgorithm/recursion","BasicAlgorithm/two_pointers"],"coming":false},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"深度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/structured_binding","BasicAlgorithm/recursion","BasicAlgorithm/enumerate","BasicDataStructure/binary_tree"],"coming":false},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","ImplementationKnowledge/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/backtracking","article":"backtracking","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 回溯","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/basic_optimization","article":"basic_optimization","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 的基本優化","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/structure"],"coming":true},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":false},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":false},{"code":"BasicDynamicProgramming/range_dp","article":"range_dp","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"區間 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/structure","article":"structure","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"動態規劃的必要元素","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","ImplementationSkill/buglist"],"coming":false},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":true,"title":"二分圖","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":true,"title":"圖論基礎","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicAlgorithm/searching","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","AlgorithmTechnique/bfs","AlgorithmTechnique/dfs"],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":true,"title":"單調隊列","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicDataStructure/stack_queue_deque","BasicAlgorithm/sweep"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 III","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/unintuitive_greedy","BasicDataStructure/set_map","BasicAlgorithm/partial_sum","BasicAlgorithm/binary_search_answer"],"coming":false},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 II","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/basic_knowledge","article":"basic_knowledge","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"ImplementationKnowledge/compiler","article":"compiler","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/float_error","article":"float_error","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/input","article":"input","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"ImplementationKnowledge/reference","article":"reference","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/rngbased","article":"rngbased","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Range-based for loop","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/reference","BasicDataStructure/vector"],"coming":false},{"code":"ImplementationKnowledge/structured_binding","article":"structured_binding","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"Structured Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/variable","article":"variable","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/reference","ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationKnowledge/variable_declare","article":"variable_declare","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常用變數宣告方法","authors":["WiwiHo","baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/buglist","article":"buglist","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/debug","article":"debug","topic":"ImplementationSkill","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["ImplementationSkill/buglist"],"coming":false},{"code":"ImplementationSkill/error_message","article":"error_message","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationSkill/pseudo_pointer","article":"pseudo_pointer","topic":"ImplementationSkill","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"ImplementationKnowledge","title":"實作知識","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error"]},{"code":"ImplementationSkill","title":"實作技巧","contents":["ImplementationSkill/error_message","ImplementationSkill/buglist","ImplementationSkill/debug","ImplementationSkill/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","BasicDynamicProgramming/basic_optimization","BasicDynamicProgramming/range_dp","BasicDynamicProgramming/backtracking"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["ImplementationKnowledge"]},{"single":true,"title":"","topics":["ImplementationSkill"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationSkill/error_message","ImplementationSkill/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error","ImplementationSkill/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/DataStructure/monotonic_queue/monotonic_queue.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    strong: \"strong\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Figure, Info, Problem, Refcode} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"左邊第一個比較小的數\",\n      children: \"左邊第一個比較小的數\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1645\",\n      src: \"CSES 1645\",\n      name: \"Nearest Smaller Values\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/CSES/1645/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1645/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1645/description.mdx\",\n      importMdx: \"guide/problems/CSES/1645/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們先把題目說得視覺化一點：有 $n$ 個人站成一排，第 $i$ 個人的身高是 $x_i$，每個人都會往左看，找到最近的比他矮的人。\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/DataStructure/monotonic_queue/figure/smaller.png\",\n      width: \"500\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"要直接通靈出一個人的答案，好像有點困難，這種時候就可以秉持掃描線精神，從左邊開始枚舉，並且用我們以前看過的資訊來找到現在看到的人的答案（畢竟答案就在左邊嘛）。我們試著從左邊第一個人開始，依序決定每個人的答案。要是某個人是第 $i$ 個人的答案，他理所當然就只能比第 $i$ 個人矮，所以如果我們讓左邊身高 $\\\\geq x_i$ 的人都直接「退出隊伍」，那留下來的人之中，站最右邊的就是 $i$ 的答案了。可以想像成整個過程是，我們從第 $1$ 個人開始，依序呼叫每一個人，當第 $i$ 個人被叫到的時候，他就會叫所有在他左邊、身高 $\\\\geq$ 他的人都離開隊伍，然後他就會知道他的答案是站在他左邊的第一個人。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"先不論要怎麼有效率的維護還在隊伍裡面的人，我們先確認一下這個作法是不是正確的。要是我們直接讓那些長太高的人永遠離開隊伍，可能會有一個問題：會不會他們有可能是更右邊的人的答案？其實不會，要是有個人 $j$ 被第 $i$ 個人趕出隊伍了，我們就知道 $j < i$、$a_j \\\\geq a_i$，對於一個位置比 $i$ 還右邊的人 $k$，他的答案絕對不會是 $j$，這是因為如果他的答案是 $j$，那就有 $a_j < a_k$，根據我們剛才知道的資訊，$j < i < k$、$a_i \\\\leq a_j < a_k$，$i$ 也是一個比 $k$ 矮的人，而且還離 $k$ 更近，所以答案當然就不會是 $j$。舉例來說，上面那張圖裡面，左邊數過來第二個人比最左邊的人矮，那所有右邊的人往左看比較矮的人的時候，當然是會先看到第二個人。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"換個角度講，對於一個人 $j$ 來說，一旦他右邊有一個身高一樣，或是比他更矮的人 $i$，那 $j$ 就不會是比 $i$ 更右邊的人的答案，也就是說，當有一個身高 $\\\\leq x_j$ 的人，在 $j$ 之後被叫到了，那 $j$ 這個人就永遠沒有用了，他就可以放心地直接離開隊伍。\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/DataStructure/monotonic_queue/figure/smaller2.png\",\n      width: \"500\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"像是在上圖裡面的 $j$，在我們叫到 $i$ 的時候，我們就知道 $j$ 既不會是 $i$ 的答案，也不會是之後的人（例如 $k$，即便 $k$ 比 $j$ 還高，但中間夾了一個更矮的 $i$）的答案，因此 $j$ 在此時就可以退出隊伍了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那我們要怎麼知道現在誰要被踢出隊伍、留在隊伍裡面，$i$ 之前的最右邊的人是誰呢？先來看看留在隊伍裡面的人會長什麼樣子：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/DataStructure/monotonic_queue/figure/smaller3.png\",\n      width: \"500\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"紅色是我們現在叫到的人，綠色是左邊還留在隊伍裡的人，右邊的人還沒被叫到所以先不理他們。注意到已經被叫過、留在隊伍裡的條件是「右邊沒有一樣高或更矮的人被叫到過」，所以那些被叫到之後還留在隊伍裡的人（綠色那些人），由左至右會是\", _jsx(_components.strong, {\n        children: \"嚴格遞增\"\n      }), \"的，當我們要讓身高 $\\\\geq$ 紅色的人離開隊伍時，這些人一定是最靠右的那些綠色的人。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"講得更明白一些，可以想像成是我們讓被叫過的人去待在一個額外的隊伍裡面，當我們叫到一個人 $i$ 時，就讓額外隊伍裡，身高 $\\\\geq$ 他的人都離開隊伍，額外隊伍裡的最後一個人，就是 $i$ 的答案，然後讓 $i$ 去排在額外隊伍的最後面。這個額外隊伍永遠都會保持\", _jsx(_components.strong, {\n        children: \"嚴格遞增\"\n      }), \"，所以那些要退出隊伍的人，總會是隊伍的最後幾個人，我們只要不斷檢查最後一個人，他太高了就叫他離開，直到最後一個人比 $i$ 還矮或額外隊伍空了為止。也就是說，這個額外隊伍就是一個 stack！我們用一個 stack 維護這個額外隊伍，就可以解決這個問題了。\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint main () {\\n    int n;\\n    cin >> n;\\n    stack<int> stk;\\n    vector<int> x(n + 1);\\n    for (int i = 1; i <= n; i++) {\\n        cin >> x[i];\\n        while (!stk.empty() && x[stk.top()] >= x[i])\\n            stk.pop();\\n        if (stk.empty()) cout << 0;\\n        else cout << stk.top();\\n        cout << \\\" \\\\n\\\"[i == n];\\n        stk.push(i);\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"喔不，這個程式碼裡有兩層迴圈！用不著擔心會 TLE，每次 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈成功執行的時候，都會丟掉一個 \", _jsx(_components.code, {\n        children: \"stk\"\n      }), \" 裡的東西，而每個人都只會被放進 \", _jsx(_components.code, {\n        children: \"stk\"\n      }), \" 一次、最多有 $n$ 個東西被放進 \", _jsx(_components.code, {\n        children: \"stk\"\n      }), \"，因此裡面的 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈最多只會被執行 $n$ 次，總時間複雜度是 $O(n)$。（還記得我們在\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicAlgorithm/complexity\",\n        mode: \"default\",\n        topicTitle: \"基礎演算法\",\n        articleTitle: \"複雜度\"\n      }), \"提過的「一個沒那麼單純的例子」嗎？）\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"單調隊列\",\n      children: \"單調隊列\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"剛才我們維護的額外隊伍，因為保持單調遞增的特性，就被稱為\", _jsx(_components.strong, {\n        children: \"單調隊列\"\n      }), \"（monotonic queue，也有人會叫它單調 stack，但這個我們等等再說）。單調隊列不一定是要維護嚴格遞增，也可以是遞減或是非嚴格，就只要改一下上方程式碼第 11 行 pop 條件中的 \", _jsx(_components.code, {\n        children: \">=\"\n      }), \" 就好。\"]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"候選答案的單調性\"\n          }), _jsx(_components.th, {\n            children: \"pop 條件\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"嚴格遞增（$<$）\"\n          }), _jsx(_components.td, {\n            children: \"$\\\\geq$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"嚴格遞減（$>$）\"\n          }), _jsx(_components.td, {\n            children: \"$\\\\leq$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"非嚴格遞增（$\\\\leq$）\"\n          }), _jsx(_components.td, {\n            children: \"$>$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"非嚴格遞減（$\\\\geq$）\"\n          }), _jsx(_components.td, {\n            children: \"$<$\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"單調隊列在維護的東西其實就是「候選答案」，當一個元素將來再也不會是答案，我們就可以把他丟掉，而單調隊列就是利用「每次會變得沒用的人非常好找，很好維護」的特性，有效率的達到目標。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就像這張表一樣，在使出單調隊列的時候，有兩種方向可以想：一個是像剛剛一樣，思考一個元素沒有用的條件是什麼，另一個就是想想看剩下來的有用東西會有什麼關係，這兩個條件是相反的（像是要維持 $x_i < x_j$ 就是要避免 $x_i \\\\geq x_j$ 出現）。大部分人在描述如何用單調隊列解一道特定題目的時候，都會直接說「維護一個嚴格遞增的單調隊列」之類的話，不過有時候要直接想出要維護的性質為何會比較不直覺，發現一個方向不好想時不妨從另一個方向下手。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"Sliding Window\",\n      children: \"Sliding Window\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=a146\",\n      src: \"ZeroJudge a146\",\n      name: \"Sliding Window\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/ZeroJudge/a146/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/a146/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a146/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a146/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們先找最小值看看。用和剛剛一樣的想法，我們由左至右逐一決定每個長度為 $k$ 的區間的最小值，假設我們現在在看以第 $i$ 個元素為最右邊元素的區間，也就是要找 $a_{i-k+1},a_{i-k+2},\\\\dots,a_i$ 的最小值。既然要用單調隊列，我們就先來想每個元素會變得沒用的條件：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"所有 $j < i-k+1$ 的 $a_j$ 再也不會出現在我們要求答案的區間裡了，所以它將來都沒有用。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"既然我們要求的是「區間最小值」，那要是有一個元素 $a_j$ 右邊有個 $a_k$ 更小，那它對於以 $i \\\\geq k$ 為右界的區間都絕對不是答案。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"第二個條件簡短地說就是「一個元素遇到右邊有人更小就會沒用」，所以我們可以在看到以 $i$ 為右界的區間時，讓左邊所有比 $a_i$ 還\", _jsx(_components.strong, {\n        children: \"大\"\n      }), \"的元素離開隊伍，這樣一來目前隊伍中有用的元素就會是\", _jsx(_components.strong, {\n        children: \"非嚴格遞增\"\n      }), \"，區間 $a_{i-k+1},a_{i-k+2},\\\\dots,a_i$ 的答案就是隊伍之中，位置在 $i-k+1$ 以後的第一個元素。第一個條件跟我們說，$i-k+1$ 之前的元素其實已經沒有用了，所以我們可以放心地也讓它們視為離開隊伍，這樣一來隊伍中第一個元素就是答案了。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在，我們要用來維護隊伍的資料結構其實不再是一個 stack 了，因為我們多了「讓在隊伍前面的人離開隊伍」的操作，所以我們要換成用一個 deque。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\nusing ll = long long;\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n\\n    int n, K;\\n    while (cin >> n >> K) {\\n        if (K > n) K = n;\\n        vector<ll> a(n + 1);\\n        for (int i = 1; i <= n; i++) cin >> a[i];\\n\\n        vector<ll> ans_min(n + 1), ans_max(n + 1);\\n\\n        deque<int> dq; // 在隊伍裡面的元素編號\\n        for (int i = 1; i <= n; i++) {\\n            // 右邊有更小數字的元素就沒用了\\n            while (!dq.empty() && a[dq.back()] > a[i])\\n                dq.pop_back();\\n            // 太左邊的元素就沒用了\\n            if (!dq.empty() && dq.front() < i - K + 1)\\n                dq.pop_front();\\n            dq.push_back(i); // 把 i 放進隊伍\\n            ans_min[i] = a[dq.front()]; // 答案是隊伍裡最左邊的人\\n        }\\n\\n        // 自己寫找最大值的版本！\\n        \\n        for (int i = K; i <= n; i++) cout << ans_min[i] << \\\" \\\\n\\\"[i == n];\\n        for (int i = K; i <= n; i++) cout << ans_max[i] << \\\" \\\\n\\\"[i == n];\\n    }\\n\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"其實就是我們前面在做的單調隊列，只不過存在於隊伍裡的元素僅限於我們考慮的區間之中。像這樣維護一個不斷移動的固定長度區間的作法，被稱為 sliding window。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"更多例題\",\n      children: \"更多例題\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"單調隊列的經典應用就是剛才看到的那兩種：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"找出一個序列中，每個數字左 / 右第一個比較大 / 小的數。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"找出一個序列中，所有長度為 $k$ 的區間中的最大 / 小值。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在需要做這兩種事情的時候，直接用單調隊列就對了。接下來我們再講一些稍微變形的例題來幫助讀者熟悉一下怎麼使用單調隊列。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"更多例題-同時找左邊右邊的第一個較小數\",\n      children: \"同時找左邊右邊的第一個較小數\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://www.luogu.com.cn/problem/P5854\",\n      src: \"洛谷 P5854\",\n      name: \"【模板】笛卡尔树\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Luogu/P5854/description.mdx\",\n      constraintsMdx: \"guide/problems/Luogu/P5854/constraints.mdx\",\n      importMdx: \"guide/problems/Luogu/P5854/description.mdx\",\n      importMdx: \"guide/problems/Luogu/P5854/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"舉例來說，$[2, 8, 3, 1, 9, 5, 7, 4, 6]$ 的笛卡爾樹長這樣：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/DataStructure/monotonic_queue/figure/cartesian.png\",\n      width: \"500\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"笛卡爾樹的性質我們就先不詳細探究，直接說我們要用的結論：仔細看一下上面這張圖就會發現，一個節點的父節點，就是「左右第一個數值比較小的人之中，比較大的那一個」，所以只要先找每個數左右第一個比它小的人，再看哪個比較大，就知道它的父節點是誰，而這剛好就是能用單調隊列直接解決的問題。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，左右第一個比較小的都要找，要正反跑一次也太累了吧？其實我們只要跑一次單調隊列就能找到左邊跟右邊的答案了。如果我們只要找左邊第一個比較小的話，從左看到右邊，一個數會變得沒有用的時機是「我們看到一個比它更小的數」的時候，所以一個人被從隊伍（我們維護的那個 stack）中踢掉時，就代表我們現在看到的數，就是它右邊第一個比它小的數！統整一下，完整的流程是：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"有一個額外的隊伍（實際上是一個 stack），一開始的空的。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"枚舉 $i=1,2,\\\\dots,n$：\", \"\\n\", _jsxs(_components.ol, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"看隊伍裡的最後一個數 $p_j$，如果 $p_j > p_i$ ，$p_j$ 以後都沒有用了，把它丟掉，此時我們得知 $p_i$ 是 $p_j$ 右邊第一個比較小的數。重複直到隊伍裡空了或 $p_j < p_i$ 為止。\"\n          }), \"\\n\", _jsx(_components.li, {\n            children: \"如果隊伍裡面有東西，最後一個是 $p_j$，那麼我們得知 $p_i$ 左邊第一個比較小的數是 $p_j$。\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣就可以同時找到左邊和右邊第一個比較小的數了。有一件事情要特別注意，因為這題的輸入是一個排列，每個數字都不一樣，所以我們還不需要擔心相等數字的問題，但如果有相等數字的時候會發生什麼事？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"先換個符號以免搞混，我們要對一個數字可能有重複的序列 $a_1,a_2,\\\\dots,a_n$ 找每個數左右第一個\", _jsx(_components.strong, {\n        children: \"嚴格小\"\n      }), \"的數，然後按照一樣的路線走：當我們看到 $a_i$ 的時候，我們希望在把隊伍裡面沒用的人踢掉之後，最後一個人就是 $a_i$ 左邊的答案，因此 $a_j$ 變得沒用的條件就是 $a_j \\\\geq a_i$，等於的人必須被踢掉，如此一來可以找到每個人左邊第一個嚴格小的數沒錯，但一個數被踢出隊伍的時機會變成「遇到第一個\", _jsx(_components.strong, {\n        children: \"小於等於\"\n      }), \"它的人的時候」，要是直接把它被 pop 的時機當作答案那就錯了，此時還是左右分開做比較方便。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"上網查笛卡爾樹的話可能會查到一個「用 stack 維護最右側鏈」的作法，那其實也是用單調隊列，只是在維護單調隊列的過程改用「找出每個節點左右子節點」而非找父節點的角度去看，想起來會稍微複雜一些，但寫出來會比較精簡，有興趣的讀者可以自行搜尋。\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"更多例題-把很多東西壓在一起\",\n      children: \"把很多東西壓在一起\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=a813\",\n      src: \"ZeroJudge a813\",\n      name: \"城市觀測\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/ZeroJudge/a813/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/a813/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a813/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a813/constraints.mdx\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"「可以看到」的關係是雙向的，A 能看到 B 那 B 就能看到 A，所以我們只要數「每棟房子往左看會看到幾棟房子」，加起來再乘 2 就是答案了。同樣地，我們從最左邊的房子開始，一一找每一棟房子往左能看到幾棟房子，這次我們改用「看得見的房子會有什麼性質」來想，很直覺地就會想到，一棟房子往左看時，能看見的房子由左至右要\", _jsx(_components.strong, {\n        children: \"非嚴格遞減\"\n      }), \"，所以反過來說，沒用的時機就是出現一棟更高的房子，那較矮的房子就會被擋住，因此 pop 條件是左 $<$ 右。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"至於答案要怎麼算呢？在看到房子 $i$ 的時候，只有先前剩下來的有用房子才可能被它看見，而那些被它 pop 掉的房子，根據非嚴格遞減的性質，它們和 $i$ 之間都不會有更高的房子，因此 $i$ 肯定都看得見它們。要是 pop 完之後還有有用的房子，那最右邊那一棟有用的房子也是看得見的，這個時候數量要 $+1$……只寫這樣就會獲得 WA，舉例來說，$N=3$，三棟房子的高度分別是 $3,2,2$，在看到第 3 棟房子的時候，因為前兩棟房子都還是有用的，那就只會數到 1 棟可以看見的房子，但兩棟房子都是看得見的！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"問題點在於，實際上能看到的房子除了那些剛剛 pop 掉的以外，還有剩下來的有用房子中，最後那些跟現在看到的房子一樣高的，還有再前一棟房子也看得到。然而，暴力檢查有幾個一樣高的房子的話，有可能每看到一個新房子時，都得花 $O(N)$ 的時間做這件事，總時間就會噴到 $O(N^2)$ 了。一一檢查行不通，不如我們把有用房子之中，連續的那些一樣高的合併起來，反正它們要變成沒用就是全部一起變成沒用。我們用一個 pair $(\\\\text{房子的高度},\\\\text{數量})$ 來表示 stack 中維護的有用房子。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\nusing pii = pair<int, int>;\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n\\n    int n;\\n    cin >> n;\\n\\n    stack<pii> stk; // (高度, 數量)\\n    long long cnt = 0;\\n    for (int i = 0; i < n; i++) {\\n        int h;\\n        cin >> h;\\n        // 比較矮的房子以後都沒用了，直接 pop 掉\\n        while (!stk.empty() && stk.top().first < h) {\\n            cnt += stk.top().second; // 全部都看得到\\n            stk.pop();\\n        }\\n        // 如果最後一段房子跟這棟一樣高\\n        if (!stk.empty() && stk.top().first == h) {\\n            cnt += stk.top().second; // 全部都看得到\\n            stk.top().second++; // 直接把數量 +1\\n        }\\n        else stk.push(pii(h, 1)); // 最後一段不一樣高的話要自己開一段\\n        // size >= 2 代表除了最後一樣的那一段之外還有東西，再前面一個是看得到的\\n        if ((int) stk.size() >= 2) cnt++;\\n    }\\n\\n    cout << cnt * 2 << \\\"\\\\n\\\";\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣一來就也在 $O(N)$ 的時間做完了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"總結\",\n      children: \"總結\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"介紹了這麼多例題，相信讀者已經很熟悉使用單調隊列的固定模式了：找出讓東西變得沒用的條件，或是「似乎」有用的東西之間的關係、維護「似乎」有用的東西、再從剩下有用的東西中找到答案，而維護的「有用性質」（也就是單調性）會讓丟掉沒用東西和從有用東西找出答案特別方便，從而給出好的複雜度。就如上面所有例題一樣，單調隊列的題目往往都有包裝，需要自己發現可以使用單調隊列。左右第一個較大 / 小值和 sliding window 極值就是最經典的兩類可以被單調隊列做掉的問題，要用單調隊列的題目大多時候都可以轉換成這兩種問題。單調隊列也有其他種變形，核心精神都是「有用的東西很好維護」，讀者未來學到一些進階的技巧時就會遇到了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最後，我們回來提一下「單調隊列」這個稱呼，剛才我們用來實作單調隊列的資料結構是 stack 或 deque，都不是名稱中的隊列（queue），有些人會把只使用 stack 操作（只需要從一端插入刪除）的單調隊列叫作單調 stack，不過裡面使用的資料結構是什麼其實沒有很重要，根據要做的操作使用對應的資料結構就好。\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"別忘了在 C++ 中，stack 和 queue 預設都是用 deque 實作的，只需要 stack 操作的時候，可以改用 vector 來減少常數。\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/513/\",\n      src: \"NEOJ 513\",\n      name: \"超大螢幕設置\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NEOJ/513/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/513/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/513/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/513/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1063\",\n      src: \"TIOJ 1063\",\n      name: \" 最大矩形 (Area)\",\n      expanded: \"false\",\n      difficulty: \"3\",\n      descriptionMdx: \"guide/problems/TIOJ/1063/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1063/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1063/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1063/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/552/\",\n      src: \"NEOJ 552\",\n      name: \"芽芽的祕密\",\n      expanded: \"false\",\n      difficulty: \"4\",\n      descriptionMdx: \"guide/problems/NEOJ/552/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/552/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/552/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/552/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1645/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給 $n$ 個整數，求每個數往左邊看、第一個比它小的數字的編號，沒有這種數字的話輸出 $0$。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1645/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 2 \\\\times 10^5$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a146/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給你一個長度為 $n$ 的陣列 $a_1,a_2,\\\\dots,a_n$ 和一個數字 $k$，求所有長度為 $k$ 的區間中的最大值與最小值。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a146/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 10^6$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"要開 long long\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$k$ 可能會大於 $n$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Luogu/P5854/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"給一個 $1 \\\\sim n$ 的排列 $p_1,p_2,\\\\dots,p_n$，求它的笛卡爾樹（Cartesian tree）。笛卡爾樹的定義是：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"令 $p_r$ 為序列中的最小值，節點 $r$ 是整棟樹的根。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"$r$ 的左子樹是 $p_1,\\\\dots,p_{r-1}$ 的笛卡爾樹，右子樹是 $p_{r+1},\\\\dots,p_n$ 的笛卡爾樹。空序列的笛卡爾樹就是空的。\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Luogu/P5854/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 10^7$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a813/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 棟房子排成一列，其中由左至右第 $i$ 棟房子的高度是 $H_i$。對於兩棟不同房子 A、B 來說，如果房子 A 與房子 B 之間的所有其他房子，高度都 $\\\\leq$ A 和 B 的高度，則站在房子 A 上的人可以看到房子 B。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"令第 $k$ 棟房子上的人能看見的其他房子數量為 $C_k$，求 $C_1+C_2+\\\\dots+C_N$。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a813/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N \\\\leq 10^6$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$H_i \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/513/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有 $n$ 個大樓排成一列，從左到右第 $i$ 棟的高度是 $a_i$，寬度都是 1，這些大樓都緊緊相鄰，你要在這些大樓上貼一個長方形廣告看板，使得整個看板背後都貼在這些大樓上，且底邊和地面平行。求這個看板的面積最大可以是多少。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/513/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 2 \\\\times 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq a_i \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1063/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有一個 $M \\\\times N$ 的 01 表格，求最大的全部都是 1 的矩形大小。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1063/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$M,N \\\\leq 200$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/552/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $N$ 個資料庫 $1,2,\\\\dots,N$，每個資料庫有各自的通訊半徑 $r_i$ 和保密等級 $s_i$，兩個資料庫 $i,j$ 可以直接通訊的條件是（假設 $s_i < s_j$）\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"$\\\\lvert i - j \\\\rvert \\\\leq \\\\min(r_i,r_j)$，且\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"對於所有 $k$ 滿足 $\\\\min(i,j) < k < \\\\max(i,j)$，滿足以下所有條件：\", \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsx(_components.li, {\n            children: \"$s_k < s_j$。\"\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"$s_k < s_i$ \", _jsx(_components.strong, {\n              children: \"或\"\n            }), \"資料庫 $k$ 不能和 $i$ 直接通訊。\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不能直接通訊的資料庫可以透過其他資料庫傳訊息，令 $f(i,j)$ 是 $i$ 要傳訊息給 $j$ 最少需要經過幾次直接通訊，給定 $S$，求 $\\\\sum_{i=1}^N f(S,i)$。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/552/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$2 \\\\leq N \\\\leq 10^6$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$\\\\forall i \\\\neq j,\\\\ s_i \\\\neq s_j$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"左邊第一個比較小的數","depth":1,"code":"左邊第一個比較小的數"},{"text":"單調隊列","depth":1,"code":"單調隊列"},{"text":"Sliding Window","depth":1,"code":"Sliding Window"},{"text":"更多例題","depth":1,"code":"更多例題"},{"text":"同時找左邊右邊的第一個較小數","depth":2,"code":"更多例題-同時找左邊右邊的第一個較小數"},{"text":"把很多東西壓在一起","depth":2,"code":"更多例題-把很多東西壓在一起"},{"text":"總結","depth":1,"code":"總結"},{"text":"習題","depth":1,"code":"習題"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}