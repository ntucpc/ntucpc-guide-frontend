{"pageProps":{"props":{"mdxPath":"guide/content/AlgorithmTechnique/bfs/bfs.mdx","code":"AlgorithmTechnique/bfs","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"廣度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["AlgorithmTechnique/dfs"],"coming":false},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"分治法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting","BasicAlgorithm/recursion","BasicAlgorithm/two_pointers"],"coming":false},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"深度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/structured_binding","BasicAlgorithm/recursion","BasicAlgorithm/enumerate","BasicDataStructure/binary_tree"],"coming":false},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","ImplementationKnowledge/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/backtracking","article":"backtracking","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 回溯","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/basic_optimization","article":"basic_optimization","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 的基本優化","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/structure"],"coming":true},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":false},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":false},{"code":"BasicDynamicProgramming/range_dp","article":"range_dp","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"區間 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/structure","article":"structure","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"動態規劃的必要元素","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","ImplementationSkill/buglist"],"coming":false},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":true,"title":"二分圖","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":true,"title":"圖論基礎","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicAlgorithm/searching","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","AlgorithmTechnique/bfs","AlgorithmTechnique/dfs"],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":true,"title":"單調隊列","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicDataStructure/stack_queue_deque","BasicAlgorithm/sweep"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 III","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/unintuitive_greedy","BasicDataStructure/set_map","BasicAlgorithm/partial_sum","BasicAlgorithm/binary_search_answer"],"coming":false},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 II","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/basic_knowledge","article":"basic_knowledge","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"ImplementationKnowledge/compiler","article":"compiler","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/float_error","article":"float_error","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/input","article":"input","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"ImplementationKnowledge/reference","article":"reference","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/rngbased","article":"rngbased","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Range-based for loop","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/reference","BasicDataStructure/vector"],"coming":false},{"code":"ImplementationKnowledge/structured_binding","article":"structured_binding","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"Structured Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/variable","article":"variable","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/reference","ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationKnowledge/variable_declare","article":"variable_declare","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常用變數宣告方法","authors":["WiwiHo","baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/buglist","article":"buglist","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/debug","article":"debug","topic":"ImplementationSkill","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["ImplementationSkill/buglist"],"coming":false},{"code":"ImplementationSkill/error_message","article":"error_message","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationSkill/pseudo_pointer","article":"pseudo_pointer","topic":"ImplementationSkill","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"ImplementationKnowledge","title":"實作知識","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error"]},{"code":"ImplementationSkill","title":"實作技巧","contents":["ImplementationSkill/error_message","ImplementationSkill/buglist","ImplementationSkill/debug","ImplementationSkill/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","BasicDynamicProgramming/basic_optimization","BasicDynamicProgramming/range_dp","BasicDynamicProgramming/backtracking"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["ImplementationKnowledge"]},{"single":true,"title":"","topics":["ImplementationSkill"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationSkill/error_message","ImplementationSkill/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error","ImplementationSkill/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/AlgorithmTechnique/bfs/bfs.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Figure, Info, Problem, Refcode} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"流水問題\",\n      children: \"流水問題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"經典題\",\n      name: \"流水問題\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/flood/description.mdx\",\n      constraintsMdx: \"guide/problems/Misc/flood/constraints.mdx\",\n      importMdx: \"guide/problems/Misc/flood/description.mdx\",\n      importMdx: \"guide/problems/Misc/flood/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們先直接看看流水過程的示意圖：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/AlgorithmTechnique/bfs/figure/flood.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"當水在往外擴張的時候，那些「有流水到新的格子」的格子，肯定是本來有水的最外圈格子，而這些最外圈格子，就是上一秒才有水的格子，畢竟如果更早就有水了，它早就流水到隔壁的格子了。也就是說，流水的過程是一圈一圈擴散出去的，那些答案是 $x$ 的格子，再往外擴散一格就是答案是 $x+1$ 的格子。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"直接寫程式模擬這個流程的話，大致上就是先讓起點格子的答案是 $0$，接下來讓答案是 $0$ 的格子往旁邊流水，本來沒水的格子答案就是 $1$，然後讓所有答案是 $1$ 的格子往旁邊流水，新格子的答案是 $2$，再讓答案是 $2$ 的格子往旁邊流水……如此重複下去，直到某一輪裡面沒有再流到新的格子為止。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\n \\nconst int MAXN = 1000;\\nstring board[MAXN + 2];\\nint ans[MAXN + 2][MAXN + 2];\\nusing pii = pair<int, int>;\\npii dir[4] = {pii(-1, 0), pii(1, 0), pii(0, -1), pii(0, 1)};\\n \\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n    \\n    int n, m, si, sj; // 起點是 (si, sj)\\n    cin >> n >> m >> si >> sj;\\n    for (int i = 1; i <= n; i++) {\\n        cin >> board[i];\\n        board[i] = '#' + board[i] + '#';\\n    }\\n    board[0] = board[n + 1] = string(m + 2, '#');\\n\\n    for (int i = 1; i <= n; i++)\\n        fill(ans[i] + 1, ans[i] + m + 1, -1);\\n    // ans[i][j] = -1 代表 (i, j) 目前沒有水\\n\\n    ans[si][sj] = 0;\\n    // 剛剛新流到水的格子\\n    vector<pii> last = {pii(si, sj)};\\n    // last 裡面的格子是答案為 t 的格子\\n    for (int t = 0; t <= n; t++) {\\n        // 流出去的格子，答案是 t + 1\\n        vector<pii> nxt;\\n        for (auto [x, y] : last) {\\n            for (auto [dx, dy] : dir) {\\n                int nx = x + dx, ny = y + dy;\\n                if (board[nx][ny] == '#' || ans[nx][ny] != -1) continue;\\n                ans[nx][ny] = t + 1;\\n                nxt.emplace_back(pii(nx, ny));\\n            }\\n        }\\n        last = nxt;\\n    }\\n\\n    for (int i = 1; i <= n; i++)\\n        for (int j = 1; j <= m; j++)\\n            cout << ans[i][j] << \\\" \\\\n\\\"[j == m];\\n    // 輸出 -1 代表水流不到\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"跟在\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"AlgorithmTechnique/dfs\",\n        mode: \"article\",\n        topicTitle: \"演算法技巧\",\n        articleTitle: \"深度優先搜尋\"\n      }), \"提到的迷宮找路徑一樣，在一個棋盤上做事的時候，可以直接在外面加一圈障礙物以避免戳到棋盤外面。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在這個程式碼中，我們開了一個暫時的 vector \", _jsx(_components.code, {\n        children: \"nxt\"\n      }), \" 來存這一輪新流到、下一輪要往外流的格子，其實這裡可以寫得更精簡一點，我們可以不用明確的一輪一輪地處理，因為我們根本就是做完本來 \", _jsx(_components.code, {\n        children: \"last\"\n      }), \" 裡的格子之後，馬上緊接著處理 \", _jsx(_components.code, {\n        children: \"nxt\"\n      }), \" 裡的格子，再處理它得到的 \", _jsx(_components.code, {\n        children: \"nxt\"\n      }), \" 的格子、……，其實這根本就是一個被我們砍成兩半的 queue，直接用 queue 寫的話就變成：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"    queue<pii> q; // q 的前面一段會是本來寫法的 last、後面是 nxt\\n    ans[si][sj] = 0;\\n     // 對應到本來的 last = {pii(si, sj)}\\n    q.push(pii(si, sj));\\n    while (!q.empty()) {\\n        auto [x, y] = q.front();\\n        q.pop();\\n        for (auto [dx, dy] : dir) {\\n            int nx = x + dx, ny = y + dy;\\n            if (board[nx][ny] == '#' || ans[nx][ny] != -1) continue;\\n            ans[nx][ny] = ans[x][y] + 1;\\n            // 對應到本來的 nxt.emplace_back(pii(nx, ny))\\n            q.push(pii(nx, ny));\\n        }\\n    }\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"實際上做出的事情和前面分成兩個 vector 的版本一模一樣。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因為一個格子只會成為「新的有水的格子」最多一次，因此時間複雜度是 $O(NM)$。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"迷宮最短路徑\",\n      children: \"迷宮最短路徑\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我們已經知道要怎麼用\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"AlgorithmTechnique/dfs\",\n        mode: \"article\",\n        topicTitle: \"演算法技巧\",\n        articleTitle: \"深度優先搜尋\"\n      }), \"找一條在迷宮裡從起點到終點的路徑了，但如果我們要的是最短路徑的話呢？DFS 走出來的路有可能非常迂迴，比最短路徑還要長很多。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"直接找到路徑可能有一點困難，我們先想想看怎麼知道最短路徑要走幾步。從起點走 1 步能到的格子是起點周圍的格子、走 2 步能到的格子就是那些走 1 步可以到的格子再往外走一格……這不就是我們剛剛的流水問題嗎？從起點倒一桶水，水流到終點要花幾秒，就是最短路徑需要幾步。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那要怎麼真的找到那條路徑呢？其實也很簡單，只要記錄每一格水是從哪裡流過來的，從終點往源頭追溯，最後一定會追回到起點，這條流水的路徑就是最短路徑了。\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/AlgorithmTechnique/bfs/figure/flood_path.png\",\n      width: \"400px\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"廣度優先搜尋\",\n      children: \"廣度優先搜尋\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"我們剛才做的事情被稱為廣度優先搜尋（\", _jsx(_components.strong, {\n        children: \"B\"\n      }), \"readth-\", _jsx(_components.strong, {\n        children: \"F\"\n      }), \"irst \", _jsx(_components.strong, {\n        children: \"S\"\n      }), \"earch），聽起來跟深度優先搜尋（DFS）很像，以走迷宮舉例，DFS 會優先往目前還沒走過的地方走，直到無處可走為止，因此 DFS 是優先往\", _jsx(_components.strong, {\n        children: \"深\"\n      }), \"處走，而 BFS 則會一圈一圈地擴大走到的範圍，讓已經走到的區域越來越\", _jsx(_components.strong, {\n        children: \"廣\"\n      }), \"。跟 DFS 相比，BFS 最大的特性是會按照每個地方跟起點的距離順序搜尋，以走迷宮來說就是離起點越近的格子，就會越早被走到。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"廣度優先搜尋-BFS 與枚舉\",\n      children: \"BFS 與枚舉\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然 BFS 跟 DFS 一樣都能拿來走迷宮，那 BFS 是不是也像 DFS 一樣能拿來暴力搜尋呢？答案是可以，之前我們用 DFS 解決過這個問題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"經典題\",\n      name: \"總和有上限的子集\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/subset_bound/description.mdx\",\n      constraintsMdx: \"guide/problems/Misc/subset_bound/constraints.mdx\",\n      importMdx: \"guide/problems/Misc/subset_bound/description.mdx\",\n      importMdx: \"guide/problems/Misc/subset_bound/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在用 DFS 的時候，我們的作法是先決定第 1 個數字要不要選、再決定第 2 個數字要不要選、……，直到決定完每一個數字要不要選為止，最後用一個怪怪的順序枚舉出了所有總和不超過上限 $S$ 的集合。假設我們今天想要按照集合的大小，由數字少的集合到數字多的集合枚舉，那就很適合用「會保持從起點出發的距離順序」的 BFS 了，這裡的「起點」就是集合最少的空集合，然後我們要從一個已經搜尋到的集合找出更多集合，方法是每次往集合裡多加一個數字。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nconst int MAXN = 100;\\nint n;\\nlong long S;\\nint a[MAXN];\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n    \\n    cin >> n >> S;\\n    for (int i = 1; i <= n; i++) cin >> a[i];\\n\\n    queue<vector<int>> q;\\n    q.push(vector<int>()); // 起點是空集合\\n    while (!q.empty()) {\\n        vector<int> now = q.front(); // 目前我們找到的集合\\n        q.pop();\\n        // 哪些數字在這個集合裡，防止等一下重複拿到\\n        vector<bool> use(n + 1);\\n        int sum = 0; // 目前集合裡數字的總和\\n        for (int i = 0; i < int(now.size()); i++) {\\n            sum += a[now[i]];\\n            use[now[i]] = true;\\n            if (i > 0) cout << \\\" \\\"; // 順便輸出\\n            cout << now[i];\\n        }\\n        cout << \\\"\\\\n\\\";\\n        for (int i = 1; i <= n; i++) {\\n            if (use[i]) continue; // 這個數字已經在集合裡就不要拿\\n            if (sum + a[i] > S) continue; // 總和太大就不要拿\\n            vector<int> nxt = now;\\n            nxt.emplace_back(i);\\n            sort(nxt.begin(), nxt.end()); // 保持一下排序，也可以用 insert\\n            q.push(nxt); // 放進 queue 裡等等處理\\n        }\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"BFS 的實作核心就是用一個 queue 放我們還未處理過的東西，每次新找到一個集合，就把它放進 queue 裡，然後不斷從 queue 裡面拿出一個集合，再從它找出新的集合。這對應到剛才流水問題的例子中，每找到一個還沒有水的格子，就把它放進 queue 裡，然後不斷從 queue 裡拿出一個還沒往外流水過的格子，從它繼續往外流。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過這個實作有一點問題，如果輸入\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"4 10\\n1 4 6 8\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"輸出會是\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"（一個空行）\\n1\\n2\\n3\\n4\\n1 2\\n1 3\\n1 4\\n1 2\\n2 3\\n1 3\\n2 3\\n1 4\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"出現了重複的集合！這是因為我們並沒有避免找到同樣的集合，例如我們可以往 $\\\\{1\\\\}$ 裡面多加一個數字得到 $\\\\{1,2\\\\}$，也可以往 $\\\\{2\\\\}$ 裡面多加一個數字得到 $\\\\{1,2\\\\}$。剛才的流水問題不會遇到這件事，是因為我們有避免把一個已經有水的格子再放進 queue 裡面（也就是如果 \", _jsx(_components.code, {\n        children: \"ans[nx][ny] != -1\"\n      }), \" 就不處理），這裡也可以用類似的方法解決，像是在外面開一個 \", _jsx(_components.code, {\n        children: \"set<vector<int>>\"\n      }), \" 儲存已經找到過、放進 queue 裡的集合，然後每次搜尋時，先確定新集合沒有出現在這個 set 中，才把它加進 queue。\"]\n    }), \"\\n\", _jsxs(Info, {\n      type: \"warning\",\n      children: [_jsx(_components.p, {\n        children: \"注意這裡「是否已經搜尋到」的檢查是針對「是否有放進 queue 裡面過」的，而非「是否已經從 queue 拿出來處理過」，雖然要這樣做也不是不行，不過這樣無意義地被放進 queue 裡的東西會比較多，白白浪費時間和記憶體。不小心混用這兩種作法是一個常見的 bug，這兩個作法各自是正確的：\"\n      }), _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"放進 queue 前檢查是否已經找到、放進 queue 的同時標記已經找到了。\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"拿出 queue 的時候先檢查是否已經處理過，沒處理過才進行處理，然後標記成已經處理過。\"\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"如果不小心寫成「拿出 queue 的時候標記成已經處理過、放進 queue 的時候先檢查是否已經處理過」，因為拿出 queue 的時候並沒有檢查是否有被處理過，它又現在才被標記成已處理，可能早就已經被放進 queue 裡好幾次了，這樣會造成同個東西被重複處理。\"\n      }), _jsxs(_components.p, {\n        children: [\"像是如果不小心把流水問題的程式碼寫成這樣，就會有這個問題，讀者可以自己實驗看看第 9 行的 \", _jsx(_components.code, {\n          children: \"cerr\"\n        }), \" 是不是會輸出重複的格子。\"]\n      }), _jsx(Refcode, {\n        lang: \"cpp\",\n        lineno: \"true\",\n        code: \"    // vst[i][j] = (i, j) 是否被處理過\\n    queue<pii> q;\\n    ans[si][sj] = 0;\\n    q.push(pii(si, sj));\\n    while (!q.empty()) {\\n        auto [x, y] = q.front();\\n        q.pop();\\n        vst[x][y] = true; // 標記成已處理\\n        cerr << x << \\\" \\\" << y << \\\"\\\\n\\\";\\n        for (auto [dx, dy] : dir) {\\n            int nx = x + dx, ny = y + dy;\\n            // 已經處理過的不要放進 queue\\n            if (board[nx][ny] == '#' || vst[nx][ny]) continue;\\n            ans[nx][ny] = ans[x][y] + 1;\\n            q.push(pii(nx, ny));\\n        }\\n    }\",\n        startFrom: \"1\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"記錄已經搜尋到的集合是一種方法，不過這題有更簡單的解決方式：只要我們放進集合裡的數字編號都越來越大，那肯定不會枚舉到重複的集合，也就是我們每次搜尋的方式是「找到下一個要選擇的數字」，而選擇數字的順序必須按照編號，就像之前用 DFS 時我們是從第一個數字決定到最後一個，只是寫法有一點不一樣而已。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nconst int MAXN = 100;\\nint n;\\nlong long S;\\nint a[MAXN];\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n    \\n    cin >> n >> S;\\n    for (int i = 1; i <= n; i++) cin >> a[i];\\n\\n    queue<vector<int>> q;\\n    q.push(vector<int>()); // 起點是空集合\\n    while (!q.empty()) {\\n        vector<int> now = q.front(); // 目前我們找到的集合\\n        q.pop();\\n        int sum = 0; // 目前集合裡數字的總和\\n        for (int i = 0; i < int(now.size()); i++) {\\n            sum += a[now[i]];\\n            if (i > 0) cout << \\\" \\\"; // 順便輸出\\n            cout << now[i];\\n        }\\n        cout << \\\"\\\\n\\\";\\n        // 只能加入編號更大的數字\\n        for (int i = now.empty() ? 1 : now.back() + 1; i <= n; i++) {\\n            if (sum + a[i] > S) continue;\\n            vector<int> nxt = now;\\n            nxt.emplace_back(i); // 不用排序了！\\n            q.push(nxt);\\n        }\\n    }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣輸出就會自然是：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"（一個空行）\\n1\\n2\\n3\\n4\\n1 2\\n1 3\\n1 4\\n2 3\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既沒有重複的集合，也按照我們要求的按照數字少到多列出了所有答案。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"廣度優先搜尋-BFS vs DFS\",\n      children: \"BFS vs DFS\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"BFS 跟 DFS 看起來可以做到的事情差不多，都可以走迷宮、都可以枚舉東西，總的來說，他們的功能都是搜尋，走迷宮是搜尋可以走到的地方、暴力枚舉就是搜尋要枚舉的東西，聽起來他們能做到的事情一樣，只是搜尋出東西的順序不一樣而已。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在某些狀況，確實兩者都行得通、沒有太大的差別，例如單純只是要找迷宮裡起點可以走到的格子，沒有要求要找最短路徑的話，BFS 跟 DFS 同樣都可以做到這件事，時間、空間複雜度都是 $O(\\\\text{迷宮大小})$，不過並不是所有例子都是這樣。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在枚舉物件時使用 BFS 通常會比較麻煩，首先是 DFS 的遞迴過程用在暴力枚舉相對直覺許多，通常會比較好寫，再來是 BFS 需要把還未處理過的物件放在 queue 裡面，而 DFS 通常只要存下目前搜尋到的物件的長相以及遞迴的 stack 即可，例如在枚舉集合時，DFS 只要存下集合裡面至多 $n$ 個數字，BFS 的 queue 裡卻可能有高達 $O(2^n)$ 個集合，這種時候如果沒有特別的需求，用 DFS 是比較適合的。走迷宮不會這樣是因為一個格子也就用兩個 int 表示就好了，雖然 BFS 的 queue 可能需要存下 $O(\\\\text{格子數量})$ 個格子，但 DFS 的遞迴 stack（是一條從起點走到目前格子的路徑）也同樣可能是一條這麼長的路，所以它們才會有一樣的空間複雜度。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，如果要找的是最短路徑，那這是 DFS 沒有的功能，用 BFS 就對了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1192\",\n      src: \"CSES 1192\",\n      name: \"Counting Rooms\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/CSES/1192/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1192/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1192/description.mdx\",\n      importMdx: \"guide/problems/CSES/1192/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1143\",\n      src: \"TIOJ 1143\",\n      name: \"靈犬尋寶\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/TIOJ/1143/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1143/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1143/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1143/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/46/\",\n      src: \"NEOJ 46\",\n      name: \"染色遊戲\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NEOJ/46/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/46/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/46/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/46/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1194\",\n      src: \"CSES 1194\",\n      name: \"Monsters\",\n      expanded: \"false\",\n      difficulty: \"3\",\n      descriptionMdx: \"guide/problems/CSES/1194/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1194/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1194/description.mdx\",\n      importMdx: \"guide/problems/CSES/1194/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1008\",\n      src: \"TIOJ 1008\",\n      name: \"量杯問題\",\n      expanded: \"false\",\n      difficulty: \"4\",\n      descriptionMdx: \"guide/problems/TIOJ/1008/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1008/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1008/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1008/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/flood/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"有一個 $N \\\\times M$ 的棋盤，裡面有一些障礙物，其餘格子是空地，障礙物以 \", _jsx(_components.code, {\n      children: \"#\"\n    }), \" 表示、空地以 \", _jsx(_components.code, {\n      children: \".\"\n    }), \" 表示，現在在一格空地倒水，每過一秒，每一個有水的格子都會流水到它上、下、左、右本來沒有水的格子，求每個空地格子幾秒後會有水。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/flood/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N,M \\\\leq 1000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/subset_bound/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給 $n$ 個正整數 $a_1,a_2,\\\\dots,a_n$ 和一個數字 $S$，請列出所有 index 的集合 $i_1,i_2,\\\\dots,i_k$，滿足 $a_{i_1}+a_{i_2}+\\\\dots+a_{i_k} \\\\leq S$。輸出的每一行代表一個集合，將集合中的數字 index 由小到大輸出，不同集合可以用任意順序輸出。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/subset_bound/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 100$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"保證答案個數 $\\\\leq 10^4$。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1192/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給一個 $n \\\\times m$ 的迷宮，有些格子是障礙物，其他是空地，求這個迷宮裡有幾個連通的區域。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1192/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n,m \\\\leq 1000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1143/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給一個左下角格子點座標是 $(0,0)$、右上角是 $(99,99)$ 的棋盤，棋子放在格子點上，有些格子點上有障礙物，現在有一個棋子每次可以走 $1 \\\\times 3$，給這個棋子的起點和所有障礙物位置，求它要走到指定終點最少要幾步。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1143/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 1000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/46/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有一個 $N \\\\times N$ 的白布，有三支顏色分別是紅、黃、藍的滴墨管，在時間 $0$ 的時候，它們會同時在某三個位置滴下墨水，滴下之後墨水會八方位擴散，並且不同顏色會混色（請看題目敘述裡面的圖片），求某個顏色 $X$ 曾出現過的最大面積。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/46/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$T$ 筆輸入，$T \\\\leq 5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$N \\\\leq 1000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1194/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有一個 $n \\\\times m$ 的迷宮，有些格子是空地，有些是障礙物。有一些格子上一開始有怪物，每過一秒，你可以往上、下、左、右移動一格，且每一隻怪物可能會往它自己的上、下、左、右移動一格，也有可能不會動。你想要從指定的起點走到任意一個迷宮邊界的格子，求一條這樣的路徑，滿足無論怪物怎麼移動，你都絕對不會跟任何怪物同時出現在同一個格子裡。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1194/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n,m \\\\leq 1000$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1008/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    p: \"p\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"有 $n$ 個量杯，容量分別為 $m_1,m_2,\\\\dots,m_n$，一開始它們都是空的，你可以做的操作有：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"把某個量杯裝滿水。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"把某個量杯的水都倒掉。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"把一個量杯 $A$ 的水倒到另一個量杯 $B$，直到 $A$ 空了或 $B$ 滿了為止（不能倒到一半）。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"求至少要幾步才能讓隨意一個量杯裡的水量恰好是 $t$。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1008/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq t,m_i \\\\leq 50$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"流水問題","depth":1,"code":"流水問題"},{"text":"迷宮最短路徑","depth":1,"code":"迷宮最短路徑"},{"text":"廣度優先搜尋","depth":1,"code":"廣度優先搜尋"},{"text":"BFS 與枚舉","depth":2,"code":"廣度優先搜尋-BFS 與枚舉"},{"text":"BFS vs DFS","depth":2,"code":"廣度優先搜尋-BFS vs DFS"},{"text":"習題","depth":1,"code":"習題"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}