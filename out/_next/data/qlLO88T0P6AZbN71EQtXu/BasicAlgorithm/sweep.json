{"pageProps":{"props":{"mdxPath":"guide/content/BasicAlgorithm/sweep/sweep.mdx","code":"BasicAlgorithm/sweep","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"廣度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["AlgorithmTechnique/dfs"],"coming":false},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"分治法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"深度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/structured_binding","BasicAlgorithm/recursion","BasicAlgorithm/enumerate","BasicDataStructure/binary_tree"],"coming":false},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","ImplementationKnowledge/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/backtracking","article":"backtracking","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 回溯","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/basic_optimization","article":"basic_optimization","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 的基本優化","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/structure"],"coming":true},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":false},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":false},{"code":"BasicDynamicProgramming/range_dp","article":"range_dp","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"區間 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/structure","article":"structure","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"動態規劃的必要元素","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","ImplementationSkill/buglist"],"coming":false},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":true,"title":"二分圖","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":true,"title":"圖論基礎","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicAlgorithm/searching","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","AlgorithmTechnique/bfs","AlgorithmTechnique/dfs"],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":true,"title":"單調隊列","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicDataStructure/stack_queue_deque","BasicAlgorithm/sweep"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 III","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 II","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/basic_knowledge","article":"basic_knowledge","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"ImplementationKnowledge/compiler","article":"compiler","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/float_error","article":"float_error","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/input","article":"input","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"ImplementationKnowledge/reference","article":"reference","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/rngbased","article":"rngbased","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Range-based for loop","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/reference","BasicDataStructure/vector"],"coming":false},{"code":"ImplementationKnowledge/structured_binding","article":"structured_binding","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"Structured Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/variable","article":"variable","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/reference","ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationKnowledge/variable_declare","article":"variable_declare","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常用變數宣告方法","authors":["WiwiHo","baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/buglist","article":"buglist","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/debug","article":"debug","topic":"ImplementationSkill","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["ImplementationSkill/buglist"],"coming":false},{"code":"ImplementationSkill/error_message","article":"error_message","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationSkill/pseudo_pointer","article":"pseudo_pointer","topic":"ImplementationSkill","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"ImplementationKnowledge","title":"實作知識","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error"]},{"code":"ImplementationSkill","title":"實作技巧","contents":["ImplementationSkill/error_message","ImplementationSkill/buglist","ImplementationSkill/debug","ImplementationSkill/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","BasicDynamicProgramming/basic_optimization","BasicDynamicProgramming/range_dp","BasicDynamicProgramming/backtracking"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["ImplementationKnowledge"]},{"single":true,"title":"","topics":["ImplementationSkill"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationSkill/error_message","ImplementationSkill/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error","ImplementationSkill/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/BasicAlgorithm/sweep/sweep.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Figure, Info, Problem, Refcode} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"從左到右枚舉\",\n      children: \"從左到右枚舉\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在看到一個序列的時候，「從左到右枚舉」是一個非常常見的枚舉策略，不只是因為迴圈很好寫，更重要的原因是「某一格的答案」經常對求出它右邊那一格的答案很有幫助，像是我們在\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicAlgorithm/partial_sum\",\n        mode: \"article\",\n        topicTitle: \"基礎演算法\",\n        articleTitle: \"前綴和與差分\"\n      }), \"提過的經典問題：\"]\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"經典題\",\n      name: \"區間加值問題\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/segment_add/description.mdx\",\n      importMdx: \"guide/problems/Misc/segment_add/description.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"用差分的作法是，令 $d_i=a_i-a_{i-1}$，把 $a_l,\\\\dots,a_r$ 都加上 $x$，就是把 $d_l$ 加去 $x$、$d_{r+1}$ 減去 $x$，最後再還原出 $a_i=d_1+d_2+\\\\dots+d_i$。這個作法其實有一個很直觀的解釋方式，先想像一條有 $n$ 個格子的紙帶，題目給了我們 $q$ 個區間，每個區間都帶有一個權重（就是 $x$），並且是一段連續格子，我們要求的就是「對於紙帶上的每個格子，包含這個格子的區間總和有多大」，然後再想像我們從紙帶上由左往右走，並且記錄包含我們現在所在位置的區間權重總和 $s$。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"一開始我們站在格子 $1$ 的左邊（可以想像有多一個格子 $0$，就和做前綴和時我們會多一個 $s_0=0$ 一樣），所以我們現在記錄的數字 $s$ 是 $0$。接下來每當\", _jsx(_components.strong, {\n        children: \"遇到\"\n      }), \"一個區間的左界，就要把 $s$ 加上這個區間的權重，而\", _jsx(_components.strong, {\n        children: \"離開\"\n      }), \"一個區間的右界時，就要把 $s$ 減去這個區間的權重，所以 $l,r,x$ 這個操作的區間帶來的結果就是：我們走到格子 $l$ 的時候 $s$ 被加上 $x$、走到格子 $r+1$ 的時候 $s$ 被減去 $x$，也就是說前面算的 $d_i$，就是走到格子 $i$ 的時候 $s$ 會被改變多少。在計算完這個改變量之後，$s$ 就是答案的 $a_i$。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"只要開一個長度為 $n$ 的陣列，來存下走到格子 $1$ 到 $n$ 時，當下所在地的總和改變量，做前綴和就等於我們前面敘述的過程，寫出來就和差分一模一樣，時間複雜度是 $O(n)$。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"數線上的問題\",\n      children: \"數線上的問題\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們把「從左到右枚舉」這個行為解釋成了「從左邊走到右邊」，在遇到這一類很多區間的問題時，想像我們從左邊走到右邊、維護當下所在地的狀態，是一個很常見的作法。除了在紙帶上面走，也可以在數線上面走。（其實都是差不多的事情！）\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=b966\",\n      src: \"APCS 2016/03 P3\",\n      name: \"線段覆蓋長度\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/APCS/201603P3/description.mdx\",\n      constraintsMdx: \"guide/problems/APCS/201603P3/constraints.mdx\",\n      importMdx: \"guide/problems/APCS/201603P3/description.mdx\",\n      importMdx: \"guide/problems/APCS/201603P3/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如法炮製，想像我們從數線的左邊開始走，因為我們想知道的是「數線上有多長的部分被至少一個線段覆蓋」，所以可能會想要維護我們當下所在的地方，有沒有在至少一條線段裡面。不過這樣會有一個問題，就是要是我們單純只有記錄「有沒有覆蓋」，在遇到一條線段的左端點時，我們當然知道接下來的狀態是「有覆蓋」，但如果是遇到右端點，接下來的狀態不見得會變成「沒有覆蓋」，因為我們可能本來在很多條線段裡，現在只是少了一條而已。因此，我們要維護的應該是「我們現在在幾條線段裡面」。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們的目標是要知道，當我們記錄的狀態，也就是包含我們現在位置的線段數量 $cnt \\\\geq 1$ 時，走過的路有多長，就是所有線段覆蓋的總長度。要是座標範圍（我們叫它 $C$）很小，那我們可以在走到每一個整數點時，更新好接下來的狀態是什麼以後，如果 $cnt \\\\geq 1$ 就把答案加上 1，也就是走到下一個整數點之間那段路。這題的 $C$ 只到 $10^7$ 所以其實也還可以，但要是 $C$ 到 $10^9$ 甚至 $10^{18}$ 的話要怎麼辦？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"事實上，我們只關心「狀態改變的時機」，也就是所有線段端點而已，兩個端點之間如果沒有任何其他線段端點，那也就不會發生狀態改變，因此我們只要知道這一段究竟有沒有被線段覆蓋，有的話把答案加上一整段的長度就好。換句話說，可以想像整條數線被所有端點分成很多段，每一段一起算就好。在實作上，只要把所有端點左到右排序，就可以摸擬在數線上走的過程了。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\nusing pii = pair<int, int>;\\nint main () {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n\\n    int n;\\n    cin >> n;\\n    vector<pii> events;\\n    for (int i = 0; i < n; i++) {\\n        int l, r;\\n        cin >> l >> r;\\n        events.emplace_back(pii(l, 1));\\n        events.emplace_back(pii(r, -1));\\n        // 1 代表左端點，-1 代表右端點\\n        // 也就是走到那個點時，包住當前位置線段數的改變量\\n    }\\n    sort(events.begin(), events.end());\\n    int cur = 0; // 包住當前位置的線段數\\n    int ans = 0;\\n    int lst = -1; // 上一個碰到的端點\\n    for (auto [x, diff] : events) {\\n        // 如果前面那一段的是有被包住的，要加上那一段的長度\\n        if (cur > 0) ans += x - lst;\\n        cur += diff;\\n        lst = x;\\n    }\\n    cout << ans << \\\"\\\\n\\\";\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"注意到在這裡，我們的實作方法是「走到一個點時看上一段」，因為要知道下一段的長度比較麻煩一點，所以乾脆看上一段。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"掃描線與事件\",\n      children: \"掃描線與事件\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這種想像自己在走的方法稱為掃描線，就是想像有一條直線掃過去，你就是那條直線。剛剛我們討論的都是一維版本的掃描線，掃描對象是很單純的一個序列（一些格子）配上一些區間，或者一條數線配上一些線段，然後很單純的左往右掃，這種題目的作法框架基本上都差不多，首先先找出你關心的當下\", _jsx(_components.strong, {\n        children: \"狀態\"\n      }), \"，然後看看狀態什麼時候會發生改變，狀態改變的事情就被稱為\", _jsx(_components.strong, {\n        children: \"事件\"\n      }), \"，把事件按照發生時間點（通常就是座標）排序後，就可以好好摸擬掃描的過程，如果座標範圍不大，也可以直接開一個長度是 $C$ 的陣列來直接儲存每個整數時間點發生的事件，並一一枚舉所有整數時間點。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"掃描線與事件-掃描的起點\",\n      children: \"掃描的起點\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在用掃描線的時候，我們需要有一個起始狀態，在線段覆蓋長度的程式碼裡，\", _jsx(_components.code, {\n        children: \"lst\"\n      }), \" 的初始值是 $-1$，可以理解成是我們假設起點是 $-1$，而起始狀態是包住現在位置（也就是起點）的線段數量是 $0$。通常只要挑一個在所有端點左邊的點當起點就好，而在對序列掃描時，可以自己加一個 index 是 0 的位置當起點。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"掃描線與事件-邊界條件\",\n      children: \"邊界條件\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在處理任何區間相關問題的時候，都要特別注意邊界究竟有沒有被包含。舉剛剛的例子：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"在區間加值問題中，一個區間 $[l,r]$ 的意思是對元素 $a_l,a_{l+1},\\\\dots,a_r$ 加值，區間內的總元素數量是 $r-l+1$，進入區間的時間是走到第 $l$ 個元素的時候，離開區間的時間是走到第 $r+1$ 個元素的時候。\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"在線段覆蓋長度中，一個線段 $[l,r]$ 的意思就是數線上 $[l,r]$ 的範圍，注意到因為這裡關心的是\", _jsx(_components.strong, {\n          children: \"長度\"\n        }), \"，因此在單一一個點上面的狀態並不重要，我們只在乎每個時間點\", _jsx(_components.strong, {\n          children: \"之間\"\n        }), \"的狀態而已，進入區間的時間是走過 $l$ 以後，離開區間的時間是走過 $r$ 以後。\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這兩題的差別並不是在區間和線段，而是我們關心的時間到底是\", _jsx(_components.strong, {\n        children: \"每一個點上\"\n      }), \"還是\", _jsx(_components.strong, {\n        children: \"點與點之間\"\n      }), \"，總之就是要仔細想一想，每個事件到底是在什麼時候發生。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"掃描線與事件-同時發生的事件\",\n      children: \"同時發生的事件\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"剛才的兩個例題中，其實都有同時發生的事件。在區間加值問題中，我們直接用一個陣列來記錄某一刻會發生的所有事件一起造成的效果（所在地的總和會改變多少），所以我們確確實實地讓同時發生的事件一起發生了，不過在線段覆蓋長度中，我們並沒有對位置相同的端點做任何特殊處理，某種程度來說它們就不是同時發生的。舉例來說，我們有四個線段：$(1,3),(2,3),(3,4),(3,5)$，這樣排序過後的 \", _jsx(_components.code, {\n        children: \"events\"\n      }), \" 就會長成：\", _jsx(_components.br, {}), \"\\n\", \"\\\\[ (1, 1) \\\\quad (2, 1) \\\\quad \\\\color{red}{(3, -1) \\\\quad (3, -1) \\\\quad (3, 1) \\\\quad (3, 1)} \\\\quad (4, -1) \\\\quad (5, -1) \\\\]\", _jsx(_components.br, {}), \"\\n\", \"因為 \", _jsx(_components.code, {\n        children: \"pair\"\n      }), \" 比較時，如果第一項相同，會再比第二項，因此所有同時發生的事件中，右端點（離開事件）會先被處理到，然後才處理左端點（進入事件）。其實這根本就不會怎麼樣，因為我們真正關心的是\", _jsx(_components.strong, {\n        children: \"點與點之間的狀態\"\n      }), \"，而非點上的狀態，因此在時間點 $3$ 上面發生什麼都沒有差，只要走到 $3$ 之前的狀態和走到 $3$ 之後的狀態正確就好了。即便在處理完第二個 $(3,-1)$ 之後 \", _jsx(_components.code, {\n        children: \"cur\"\n      }), \" 會變成 $0$，走到緊接著的 $(3,1)$ 時就會把答案加上它們兩個之間的長度，但它們之間的長度根本就是 $0$，無論如何都不會對答案有所影響，就算時間一樣的事件亂排，不要照第二項排序都沒有關係。\"]\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicAlgorithm/sweep/figure/same_time.png\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"不過，並不是所有題目都能這樣亂排序。舉例來說，我們把題目改成問「給一些\", _jsx(_components.strong, {\n        children: \"左閉右閉\"\n      }), \"區間，是不是所有區間的聯集，是一個連續的區間」，如果是剛剛舉的那四條線段直接當成端點一樣的閉區間，它們的聯集是 $[1,5]$，因此答案是 Yes，但要是我們直接把區間覆蓋問題的作法改成「在碰到第一個事件以後，最後一個事件以前，有任何時候 \", _jsx(_components.code, {\n        children: \"cur\"\n      }), \" 變成 $0$，答案就是 No，都沒有就是 Yes」，那就會獲得一個 WA，因為處理完第二個 $(3,-1)$ 後 \", _jsx(_components.code, {\n        children: \"cur\"\n      }), \" 就會短暫地變成 $0$。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"一種處理方式是改變排序順序，我們讓同時發生的事件中，進入事件先發生，然後才發生離開事件，就不會遇到這個問題。另一種選擇是真的把同時發生的事件一起處理好，再去算答案，比較直覺的方法是直接用一個 \", _jsx(_components.code, {\n        children: \"map<int, vector<int>>\"\n      }), \" 存每個時間點發生的每個事件（在這題也可以把 \", _jsx(_components.code, {\n        children: \"vector<int>\"\n      }), \" 換成只用一個 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 存總和），但是 \", _jsx(_components.code, {\n        children: \"map\"\n      }), \" 很慢，只用 \", _jsx(_components.code, {\n        children: \"vector\"\n      }), \" 加上 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 的方法是：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(events.begin(), events.end());\\nint cur = 0; // 包住當前位置的線段數\\nbool ans = true;\\nfor (int i = 0; i < (int)events.size(); ) { // 不要有 i++！\\n    int x = events[i].first; // 目前時間點\\n    // 所有在時間點 x 發生的事件\\n    for (; i < (int)events.size() && events[i].first == x; i++)\\n        cur += events[i].second;\\n    // 跑完上面這個迴圈以後，i 會是第一個時間 > x 的事件\\n    // cur 變成 0 了卻還沒走完最後一個事件\\n    if (cur == 0 && i < (int)events.size()) ans = false;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣就可以直接抓出所有同時發生的事件一併處理。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"掃描線與事件-複雜的事件\",\n      children: \"複雜的事件\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"剛剛我們會發生的事件只有兩種：走進一條線段和走出一條線段，有時候事件會更複雜，例如：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"經典題\",\n      name: \"包含點的線段數\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/segment_query/description.mdx\",\n      constraintsMdx: \"guide/problems/Misc/segment_query/constraints.mdx\",\n      importMdx: \"guide/problems/Misc/segment_query/description.mdx\",\n      importMdx: \"guide/problems/Misc/segment_query/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"詢問點也是數線上的一個點，把「遇到詢問點」也當成是一種事件的話，現在我們的事件有三種：在 $l_i$ 進入線段 $i$、在 $r_i$ 離開線段 $i$、在 $q_i$ 記錄現在在的地方被幾條線段包含。當有多種事件的時候，就要特別注意同時發生的事件的處理順序，由於線段是閉區間，正確的處理順序是先處理進入線段事件、處理詢問事件，最後再處理離開線段事件。注意這個順序會跟你設計的邊界有關，如果是想成「因為 $r_i+1$ 是第一個不在線段 $i$ 裡的整數點，所以離開線段 $i$ 的時間是 $r_i+1$」，那正確的順序就是最後再處理詢問事件。\"\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsx(_components.p, {\n        children: \"讀者可能有注意到我們偷偷把所有詢問先讀進來，一併處理完找到答案，而不是讀一個詢問就回答一個詢問。這種技巧叫做離線回答，未來會有更詳細的解說。\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"實作的時候，當然可以用前面提到抓出所有同時發生的事件一併處理的方式，好好地把所有在一個時間點的事件都拿出來後，再寫三個迴圈分別處理三種事件，但這樣終究是有點麻煩，因此也可以直接把同時的事件按照類型用正確的順序排序。\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\nstruct event {\\n    // type 0: 進入, 1: 詢問, 2: 離開\\n    // type 0,2 的 id 其實不會用到\\n    int time, type, id;\\n};\\nbool operator<(event a, event b) {\\n    if (a.time != b.time) return a.time < b.time;\\n    return a.type < b.type; // 同時的事件照類型排序\\n}\\nint main () {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n\\n    int n;\\n    cin >> n;\\n    vector<event> events;\\n    for (int i = 0; i < n; i++) {\\n        int l, r;\\n        cin >> l >> r;\\n        events.emplace_back(event({l, 0, i}));\\n        events.emplace_back(event({r, 2, i}));\\n    }\\n    int q;\\n    cin >> q;\\n    for (int i = 0; i < q; i++) {\\n        int x;\\n        cin >> x;\\n        events.emplace_back(event({x, 1, i}));\\n    }\\n    sort(events.begin(), events.end());\\n\\n    int cur = 0; // 包住當前位置的線段數\\n    vector<int> ans(q);\\n    for (auto [time, type, id] : events) {\\n        if (type == 0) cur++;\\n        else if(type == 2) cur--;\\n        else ans[id] = cur;\\n    }\\n    for (int i = 0; i < q; i++) cout << ans[i] << \\\"\\\\n\\\";\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在需要排序帶有有點多資訊的物件的時候，可以善加利用 \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \"，而不是使用 \", _jsx(_components.code, {\n        children: \"tuple\"\n      }), \" 或很多層 \", _jsx(_components.code, {\n        children: \"pair\"\n      }), \"，雖然 \", _jsx(_components.code, {\n        children: \"pair\"\n      }), \" 或 \", _jsx(_components.code, {\n        children: \"tuple\"\n      }), \" 自帶比較運算子，但可讀性會很差，也比較容易寫錯。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"總結\",\n      children: \"總結\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"掃描線是一種把演算法具體化的方式，而不是一種特定的技巧框架，核心精神就只有想像一個移動的過程、嘗試維護當下的狀態，並找出所有會造成狀態改變或者需要記錄狀態的時間點。雖然在上面這些例題中，從左到右掃都是還算顯然的策略，而且也不一定非得要用掃描線去想（像區間加值直接用差分的作法，就不用在腦裡想一個掃描線），不過在更複雜的題目之中，把作法用掃描線這樣的方式具體化往往可以降低思考難度，將來讀者就會慢慢見識到這種方法的厲害之處了。\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=b526\",\n      src: \"ZeroJudge b526\",\n      name: \"先別管這個了，你聽過微鼓勵嗎？\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/ZeroJudge/b526/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/b526/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b526/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/b526/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"AP325 Q-4-20\",\n      name: \"監看華山練功場\",\n      expanded: \"false\",\n      difficulty: \"3\",\n      descriptionMdx: \"guide/problems/AP325/Q-4-20/description.mdx\",\n      constraintsMdx: \"guide/problems/AP325/Q-4-20/constraints.mdx\",\n      importMdx: \"guide/problems/AP325/Q-4-20/description.mdx\",\n      importMdx: \"guide/problems/AP325/Q-4-20/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://codeforces.com/problemset/problem/22/D\",\n      src: \"Codeforces 22D\",\n      name: \"Segments\",\n      expanded: \"false\",\n      difficulty: \"3\",\n      descriptionMdx: \"guide/problems/Codeforces/22D/description.mdx\",\n      constraintsMdx: \"guide/problems/Codeforces/22D/constraints.mdx\",\n      importMdx: \"guide/problems/Codeforces/22D/description.mdx\",\n      importMdx: \"guide/problems/Codeforces/22D/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1076\",\n      src: \"CSES 1076\",\n      name: \"Sliding Window Median\",\n      expanded: \"false\",\n      difficulty: \"3\",\n      descriptionMdx: \"guide/problems/CSES/1076/description.mdx\",\n      constraintsMdx: \"guide/problems/CSES/1076/constraints.mdx\",\n      importMdx: \"guide/problems/CSES/1076/description.mdx\",\n      importMdx: \"guide/problems/CSES/1076/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/segment_add/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"一開始序列 $a_1,a_2,\\\\ldots,a_n$ 都是 $0$，接下來會有 $q$ 次操作，每次操作會給你 $l,r,x$，代表要把 $a_l,a_{l+1},\\\\ldots,a_r$ 的每一項都加上 $x$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"請輸出最後的 $a_1,a_2,\\\\ldots,a_n$。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/APCS/201603P3/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給定一維座標上 $N$ 條線段，求這些線段所覆蓋的長度，注意，重疊的部分只能算一次。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/APCS/201603P3/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$N < 10^4$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 \\\\leq \\\\text{端點座標} < 10^7$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/segment_query/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有一條數線，上面有 $N$ 條線段，第 $i$ 條線段是 $[l_i,r_i]$，然後有 $Q$ 個詢問點，第 $i$ 個詢問點在 $x_i$，求每個詢問點被幾條線段包含。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/segment_query/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq N,Q \\\\leq 5 \\\\times 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq l_i, r_i, x_i \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b526/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有 $n$ 個人排成一列，一開始所有人都是站著，然後有 $m$ 個操作，每個操作是讓一個區間裡面，站著的人蹲下、蹲下的人站著，求最後有多少人站著。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/b526/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 2 \\\\times 10^9$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$m \\\\leq 10^5$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AP325/Q-4-20/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"華山派有 $n$ 個弟子，每個弟子的練功時間都不盡相同，第 $i$ 個弟子到練功場所練功的時間是區間 $[s(i),t(i)]$。最近華山頗不平靜，掌門岳不群要求令狐沖找一些弟子練功時順便監看練功場，對於想要監看的時間區間 $[x,y]$，請問他最少只要找幾位弟子，這些弟子的練功時間就可以涵蓋整個 $[x,y]$。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/AP325/Q-4-20/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 \\\\leq x < y \\\\leq 10^9$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$0 \\\\leq s(i) < t(i) \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Codeforces/22D/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"一個數線上有 $n$ 個線段，你要在數線上放一些點，使得每個線段都包含到至少一個點（端點也算），求你至少要放幾個點。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Codeforces/22D/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq n \\\\leq 1000$（但是可以做到 $O(n \\\\log n)$）\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1076/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有一個陣列 $x_1,x_2,\\\\dots,x_n$，求所有長度為 $k$ 的區間中的中位數。中位數的定義是第 $\\\\lceil k/2 \\\\rceil$ 小的數。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1076/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq k \\\\leq n \\\\leq 2 \\\\times 10^5$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$1 \\\\leq x_i \\\\leq 10^9$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"從左到右枚舉","depth":1,"code":"從左到右枚舉"},{"text":"數線上的問題","depth":1,"code":"數線上的問題"},{"text":"掃描線與事件","depth":1,"code":"掃描線與事件"},{"text":"掃描的起點","depth":2,"code":"掃描線與事件-掃描的起點"},{"text":"邊界條件","depth":2,"code":"掃描線與事件-邊界條件"},{"text":"同時發生的事件","depth":2,"code":"掃描線與事件-同時發生的事件"},{"text":"複雜的事件","depth":2,"code":"掃描線與事件-複雜的事件"},{"text":"總結","depth":1,"code":"總結"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}