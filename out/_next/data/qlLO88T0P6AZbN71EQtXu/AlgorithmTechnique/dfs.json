{"pageProps":{"props":{"mdxPath":"guide/content/AlgorithmTechnique/dfs/dfs.mdx","code":"AlgorithmTechnique/dfs","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"廣度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["AlgorithmTechnique/dfs"],"coming":false},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"分治法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"深度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/structured_binding","BasicAlgorithm/recursion","BasicAlgorithm/enumerate","BasicDataStructure/binary_tree"],"coming":false},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","ImplementationKnowledge/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/backtracking","article":"backtracking","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 回溯","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/basic_optimization","article":"basic_optimization","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 的基本優化","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/structure"],"coming":true},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":false},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":false},{"code":"BasicDynamicProgramming/range_dp","article":"range_dp","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"區間 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/structure","article":"structure","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"動態規劃的必要元素","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","ImplementationSkill/buglist"],"coming":false},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":true,"title":"二分圖","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":true,"title":"圖論基礎","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicAlgorithm/searching","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","AlgorithmTechnique/bfs","AlgorithmTechnique/dfs"],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":true,"title":"單調隊列","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicDataStructure/stack_queue_deque","BasicAlgorithm/sweep"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 III","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 II","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/basic_knowledge","article":"basic_knowledge","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"ImplementationKnowledge/compiler","article":"compiler","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/float_error","article":"float_error","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/input","article":"input","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"ImplementationKnowledge/reference","article":"reference","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/rngbased","article":"rngbased","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Range-based for loop","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/reference","BasicDataStructure/vector"],"coming":false},{"code":"ImplementationKnowledge/structured_binding","article":"structured_binding","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"Structured Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/variable","article":"variable","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/reference","ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationKnowledge/variable_declare","article":"variable_declare","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常用變數宣告方法","authors":["WiwiHo","baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/buglist","article":"buglist","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/debug","article":"debug","topic":"ImplementationSkill","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["ImplementationSkill/buglist"],"coming":false},{"code":"ImplementationSkill/error_message","article":"error_message","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationSkill/pseudo_pointer","article":"pseudo_pointer","topic":"ImplementationSkill","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"ImplementationKnowledge","title":"實作知識","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error"]},{"code":"ImplementationSkill","title":"實作技巧","contents":["ImplementationSkill/error_message","ImplementationSkill/buglist","ImplementationSkill/debug","ImplementationSkill/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","BasicDynamicProgramming/basic_optimization","BasicDynamicProgramming/range_dp","BasicDynamicProgramming/backtracking"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["ImplementationKnowledge"]},{"single":true,"title":"","topics":["ImplementationSkill"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationSkill/error_message","ImplementationSkill/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error","ImplementationSkill/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/AlgorithmTechnique/dfs/dfs.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  }, {ContentReference, Figure, Problem, Refcode} = _components;\n  if (!ContentReference) _missingMdxReference(\"ContentReference\", true);\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"遞迴與枚舉\",\n      children: \"遞迴與枚舉\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=i644\",\n      src: \"ZeroJudge i644\",\n      name: \"列舉八皇后問題所有解\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/ZeroJudge/i644/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/i644/description.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然題目都要我們列出所有放法了，那想必就是很暴力地枚舉出全部的可能性就結束了，不過要怎麼列出全部的可能性呢？試想一下如果我們試圖自己在紙上畫出一個解，方法不外乎就是先隨便放一個、再找一個看似合理的地方放第二個，不斷找一個「感覺合理的地方」放，要是在放滿 8 個之前，就已經找不到合理的地方放了，那就把上一個放的棋子擦掉，換一個地方放。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們用個小一點的棋盤來舉例，假設我們現在要在 $4 \\\\times 4$ 棋盤上放 4 個皇后：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"一開始我們先選一格放，假設就是左上角那格，然後我們把會被它吃到的格子先標記成不能放東西，得到下圖的 (1)。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"再選一個可以放的格子，不過如果我們放成 (2) 那個樣子，會發現剩下能放東西的格子只剩一格。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"我們就直接回到上一步（回到 (1) 的狀態）、換一個地方放，變成 (3) 那樣。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"無論下一個棋子放在哪裡，最後一個棋子都不會有地方可以放。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"每一橫列總得要放一個棋子，但我們已經在放下左上角那個棋子以後，試過第二列的所有放法了，因此我們勢必得重放第一列的棋子。所以我們把第一列棋子往右放一格，得到 (5)。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下來順順的放完就成功了！\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/AlgorithmTechnique/dfs/figure/queen.png\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"別忘了本來要做的問題是「列出所有可能」，所以就是我們放了一個棋子後，試完了所有可能性，就把這個棋子換下一個地方放繼續試。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"要用程式做的話，我們先利用剛剛提到的「每一橫列要放恰好一個棋子」，在放第 $i$ 個棋子的時候，我們就一一嘗試第 $i$ 橫列的「不會被已放置棋子吃到」的格子，放下這一列的棋子後，再去放下一個棋子。發現了嗎？這個過程其實就是遞迴！\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nint ans[9];\\nint cnt = 0;\\n// ans[i] = 第 i 列的棋子放在哪裡\\n// cnt = 已經找到了幾個解\\nvoid solve(int x) { // 現在要放第 x 列的棋子\\n    if (x == 9) { // 找到一個解了\\n        cnt++;\\n        cout << cnt << \\\": \\\";\\n        for (int i = 1; i <= 8; i++) cout << ans[i];\\n        cout << \\\"\\\\n\\\";\\n        return;\\n    }\\n    // 放在 (x, i)\\n    for (int i = 1; i <= 8; i++) {\\n        bool ok = true;\\n        for (int j = 1; j < x; j++) {\\n            // 檢查 (j, ans[j]) 的那個棋子會不會吃到這一格\\n            if (ans[j] == i) ok = false; // 同個 column\\n            if (ans[j] + j == i + x) ok = false; // 同個左下右上斜線\\n            if (ans[j] - j == i - x) ok = false; // 同個左上右下斜線\\n        }\\n        if (!ok) continue;\\n        ans[x] = i;\\n        solve(x + 1); // 繼續做下一列\\n    }\\n}\\n\\nint main() {\\n    solve(1);\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"檢查要放的位置 $(x,i)$ 究竟能不能放（會不會被之前放的棋子吃到）可以做得更快一些，像是用幾個陣列來存每一個直行、斜線有沒有放過東西，這部分的細節就留給讀者自己嘗試了。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"剪枝\",\n      children: \"剪枝\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在剛剛的例題裡，讀者可能有發現，由於每一直行、橫列都得放恰一個棋子，因此我們把每一橫列棋子所在的直行行號列出來，會是一個 $1 \\\\sim 8$ 的排列，讀者可能會想到要用\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicAlgorithm/enumerate\",\n        mode: \"default\",\n        topicTitle: \"基礎演算法\",\n        articleTitle: \"枚舉\"\n      }), \"中提過的枚舉排列，事實上拿掉上面的「檢查有沒有棋子在同一個斜線上」，那就是在枚舉排列了，所以也可以想成是我們在枚舉排列的過程中，把一些「不可能成為我們要求的解」的排列直接丟掉了，跟枚舉排列最後再檢查相比，多省去了一些不必要的枚舉。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"換一個方式說，就是我們在尋找解的過程中，可能到一半就發現我們走在一條錯誤的道路上，繼續走下去怎麼找都不會找到我們想要的答案，此時我們可以直接放棄這一條路，這個動作就稱為「剪枝」。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們再看一個例題：\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"經典題\",\n      name: \"總和有上限的子集\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/subset_bound/description.mdx\",\n      constraintsMdx: \"guide/problems/Misc/subset_bound/constraints.mdx\",\n      importMdx: \"guide/problems/Misc/subset_bound/description.mdx\",\n      importMdx: \"guide/problems/Misc/subset_bound/constraints.mdx\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"很直覺地可以直接用\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicAlgorithm/enumerate\",\n        mode: \"article\",\n        topicTitle: \"基礎演算法\",\n        articleTitle: \"枚舉\"\n      }), \"裡面枚舉子集的方法，枚舉所有子集並檢查總和，不過這樣就會枚舉到全部的集合，如果我們用像剛剛一樣的思路自己用遞迴枚舉，並且過程中總和太大就直接剪枝，這樣一來我們枚舉的集合數量就剛好會是答案大小了。\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nconst int MAXN = 100;\\nint n;\\nlong long K;\\nint a[MAXN];\\nbool chosen[MAXN + 1];\\n// chosen[i] = 第 i 個數字要不要選\\n\\n// 現在要決定第 id 個數字要不要選\\n// 之前選過的數字總和是 sum\\nvoid dfs(int id, long long sum) {\\n    if (id == n + 1) {\\n        for (int i = 1; i <= n; i++)\\n            if (chosen[i]) cout << i << \\\" \\\";\\n        cout << \\\"\\\\n\\\"; // 空的會輸出空行\\n        return;\\n    }\\n    // 不要選 id\\n    chosen[id] = 0;\\n    dfs(id + 1, sum);\\n    // 要選 id，並且遞迴之前先檢查總和會不會超過\\n    chosen[id] = 1;\\n    if (sum + a[id] <= K) dfs(id + 1, sum + a[id]);\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n    \\n    cin >> n >> K;\\n    for (int i = 1; i <= n; i++) cin >> a[i];\\n    dfs(1, 0);\\n\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"純手工要枚舉所有集合的話，可能會想要畫一個樹狀圖，遞迴的過程就很像是這樣做。像是假設 $n=4,k=10,a=[1,4,6,8]$：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/AlgorithmTechnique/dfs/figure/subset_bound.png\",\n      width: \"500\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那些灰色的集合就是總和超過 $k=10$ 的集合，因為我們在遞迴之前就會先檢查總和有沒有超過 $k$，所以上面的程式碼是不會枚舉出灰色的集合的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有的時候，剪枝過的枚舉方式會有點難計算時間複雜度，像是前面的八皇后，因為有可能放了好幾個棋子後才發現這條路行不通，而且最後放的幾個棋子全部都不該那樣放，我們可能浪費非常多時間在枚舉不會有答案的放法，就連用答案數量來表示花費時間都不太容易。不過，在這個例子就明顯許多：假設答案有 $x$ 個，那樹狀圖上走到底也只有 $x$ 個集合，枚舉出這些集合的路上我們會走 $n$ 步，所以時間複雜度就是 $O(nx)$。想想看樹狀圖的樣子通常可以幫助分析花費時間。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"嗯？你問 function 名稱 \", _jsx(_components.code, {\n        children: \"dfs\"\n      }), \" 是什麼意思？\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"深度優先搜尋\",\n      children: \"深度優先搜尋\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這種枚舉方式的核心精神就是，我們先「做出一個決定」，像是一個棋子要放在哪一格、或是某一個數字要不要選，然後就朝著做出這個決定之後的未來前進，直到我們探索完「做出這個決定以後」的所有可能性以後，我們把這個決定反悔、改做另一個決定，以此來找出所有「做決定」的可能性。這種「一旦決定以後就去把所有接下來的可能性找完」的搜尋方法，稱為深度優先搜尋（\", _jsx(_components.strong, {\n        children: \"D\"\n      }), \"epth-\", _jsx(_components.strong, {\n        children: \"F\"\n      }), \"irst \", _jsx(_components.strong, {\n        children: \"S\"\n      }), \"earch），可以想成「深度優先」的意思是我們會優先往上面那種樹狀圖的深處走。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"深度優先搜尋-枚舉的順序\",\n      children: \"枚舉的順序\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"剛才八皇后那一題有要求「要按照字典序輸出答案」，因為我們在每個橫列都是「先試試看把棋子放在第一格、再試第二格、……」，所以我們發現答案的順序會很自然地滿足答案要求。至於在枚舉總和有上限的子集那題，因為答案是可以用任意順序輸出的，所以我們怎麼找都可以，但要是多加上一個限制「要按照字典序輸出」的話，剛才的寫法就行不通了！像是剛才舉的 $a=[1,4,6,8]$ 的例子，上面程式碼會輸出：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"\",\n      lineno: \"true\",\n      code: \"(這是一個空行)\\n4 \\n3 \\n2 \\n2 3 \\n1 \\n1 4 \\n1 3 \\n1 2 \",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但照字典序的話應該要是：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"\",\n      lineno: \"true\",\n      code: \"(這是一個空行)\\n1 \\n1 2 \\n1 3 \\n1 4 \\n2 \\n3 \\n4 \\n2 3 \",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"會不會原因是我們先枚舉不選的狀況、再枚舉要選的狀況呢？事情沒那麼簡單，要是直接把順序對調，會得到的輸出是（其實就是剛才的輸出直接反過來）：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"\",\n      lineno: \"true\",\n      code: \"1 2 \\n1 3 \\n1 4 \\n1 \\n2 3 \\n2 \\n3 \\n4 \\n(這是一個空行)\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"當然有一個非常無腦的方法是先把所有答案存下來，排序後再輸出，但這麼做的缺點很多，除了寫起來麻煩以外，還要多花排序的時間以及存下所有答案的空間（本來的空間複雜度可是非常好的 $O(n)$！），要是可以直接用要求的順序枚舉出答案，那當然再好不過。這題就留給讀者想想要怎麼在不先存下來再排序的情況下，用正確的順序輸出答案。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"例題：走迷宮\",\n      children: \"例題：走迷宮\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"\",\n      src: \"自編題\",\n      name: \"迷宮找路徑\",\n      expanded: \"false\",\n      difficulty: \"0\",\n      descriptionMdx: \"guide/problems/Misc/maze_find_path/description.mdx\",\n      constraintsMdx: \"guide/problems/Misc/maze_find_path/constraints.mdx\",\n      importMdx: \"guide/problems/Misc/maze_find_path/description.mdx\",\n      importMdx: \"guide/problems/Misc/maze_find_path/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們就直接……暴力找出所有的走法？\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"#include <bits/stdc++.h>\\nusing namespace std;\\n\\nconst int MAXN = 1000;\\nint n;\\nstring maze[MAXN + 2];\\n\\nusing pii = pair<int, int>;\\npii dir[4] = {pii(-1, 0), pii(1, 0), pii(0, -1), pii(0, 1)};\\nstring dir_char = \\\"UDLR\\\";\\nstring cur; // 表示目前走法的字串\\nvoid dfs(int x, int y) {\\n    if (x == n && y == n) {\\n        cout << cur << \\\"\\\\n\\\";\\n        exit(0); // 直接結束程式\\n    }\\n    for (auto [dx, dy] : dir) {\\n        int nx = x + dx, ny = y + dy;\\n        // 不要走進障礙物\\n        if (maze[nx][ny] == '#') continue;\\n        cur += dir_char[i];\\n        dfs(nx, ny);\\n        cur.pop_back(); // 要記得拔掉\\n    }\\n}\\n\\nint main() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(0);\\n    \\n    cin >> n;\\n    // 直接在外面多加一圈障礙物防止走出去\\n    for (int i = 1; i <= n; i++) {\\n        cin >> maze[i];\\n        maze[i] = '#' + maze[i] + '#';\\n    }\\n    maze[0] = maze[n + 1] = string(n + 2, '#');\\n    dfs(1, 1);\\n\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"光是 $n=2$、沒有障礙物都走不出來！這是因為我們會先往下走、再往上走、再往下走、再往上走……如此無限重複，其實我們走的路線沒有必要繞圈圈，也就是經過重複的地方嘛，所以可以記錄一下每個格子是不是在目前路線上，不要走到已經在路上的格子：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"// vst[x][y]= (x,y) 是不是在路線上\\nbool vst[MAXN + 2][MAXN + 2];\\nvoid dfs(int x, int y) {\\n    vst[x][y] = true;\\n    if (x == n && y == n) {\\n        cout << cur << \\\"\\\\n\\\";\\n        exit(0); // 直接結束程式\\n    }\\n    for (auto [dx, dy] : dir) {\\n        int nx = x + dx, ny = y + dy;\\n        // 不要走進障礙物\\n        if (maze[nx][ny] == '#') continue;\\n        // 不要走到已經在路線上的格子\\n        if (vst[nx][ny]) continue;\\n        cur += dir_char[i];\\n        dfs(nx, ny);\\n        cur.pop_back(); // 要記得拔掉\\n    }\\n    vst[x][y] = false; // 要記得還原\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然而，在這筆測資：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"10\\n..........\\n.########.\\n........#.\\n........#.\\n........#.\\n........#.\\n........#.\\n........#.\\n........#.\\n........#.\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"會跑超級久！雖然我們一眼就可以看出唯一的走法是走進右邊那條狹窄的走道，但我們的程式會先走進左下方那個大塊區域，然後試過所有在那個區域裡面的走法，這會花上非常多的時間。其實，我們並不需要知道走到一個格子的所有走法，而是只要知道其中一種就好了，所以我們其實不需要把 \", _jsx(_components.code, {\n        children: \"vst[nx][ny]\"\n      }), \" 還原成 false，只要把上面程式碼裡的第 19 行拔掉，就能成功輸出答案了！\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"作法變成這樣後，與其想成我們是在「搜尋走法」，不如說我們其實是在找「所有走得到的地方」，要是我們不要管走到 $(n,n)$ 了沒，也就是把上面程式碼的 5 到 8 行也拔掉，那呼叫 \", _jsx(_components.code, {\n        children: \"dfs(1, 1)\"\n      }), \" 之後，\", _jsx(_components.code, {\n        children: \"vst[x][y]\"\n      }), \" 就代表從 $(1,1)$ 能不能走到 $(x,y)$，所以想成我們是在搜尋能夠走到的格子還比較直接一點。反正既然我們確定了一個格子可以被走到，當然也就代表我們知道有一條走到那裡的路徑了，DFS 的遞迴過程還會順便隨時幫我們維護好目前走到的地方的路徑。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這裡放一個比較複雜的迷宮的例子，讓讀者能更好感受一下 DFS 的過程，紅色線條是從左上角開始走，用上面的寫法 DFS 走遍所有格子會走的路線：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/AlgorithmTechnique/dfs/figure/maze.png\",\n      width: \"300\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"複習：拜訪一棵樹\",\n      children: \"複習：拜訪一棵樹\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"既然剛剛都說 DFS 的過程可以想像成是在畫一張樹狀圖，那我們何不真的對一棵樹 DFS？其實在\", _jsx(ContentReference, {\n        type: \"content\",\n        code: \"BasicDataStructure/binary_tree\",\n        mode: \"default\",\n        topicTitle: \"基礎資料結構\",\n        articleTitle: \"二元樹\"\n      }), \"就有做過這件事了，就是這段程式碼：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void travel(node *x) {\\n    if (!x)  return;\\n    travel(x->lson);\\n    printf(\\\"%d \\\",x->val);\\n    travel(x->rson);\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那時我們用這個 function 來由小到大印出一棵二元搜尋樹中所有的元素，也就是中序遍歷。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"當我們對一個二元樹上的節點 \", _jsx(_components.code, {\n        children: \"x\"\n      }), \" 呼叫 \", _jsx(_components.code, {\n        children: \"travel(x)\"\n      }), \" 時，這個 function 就會去走遍它的所有子孫，走的順序是先去走它的左小孩，把左子樹走完後，才會回來、執行第 4 行的 \", _jsx(_components.code, {\n        children: \"printf\"\n      }), \"、再走去右小孩，右子樹整個走完後再回來，然後結束這個 function。這個過程就是「還可以往下走就先把子孫都走完」，正好就是我們剛剛說的「優先往深處走」。而會先把所有子孫走完的特性，也是為什麼這個 function 會輸出中序遍歷的原因，呼叫 \", _jsx(_components.code, {\n        children: \"travel(x->lson)\"\n      }), \" 就會把左子樹（比較小的元素）都先輸出、輸出自己之後再呼叫 \", _jsx(_components.code, {\n        children: \"travel(x->rson)\"\n      }), \" 去輸出右子樹（比較大的元素），合起來就是我們要的中序遍歷。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"小結\",\n      children: \"小結\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"看了這麼多例子之後，我們統整一下 DFS 的流程：DFS 的實作往往是寫成一個遞迴 function 的形式，在遞迴的過程中，我們會需要知道我們現在枚舉的「狀態」，例如八皇后問題中目前的盤面長什麼樣子、我們放好了幾個橫列就是目前枚舉的狀態，狀態可以寫在 function 的參數，也可以存在全域，像是我們剛才就把「目前盤面的樣子」（\", _jsx(_components.code, {\n        children: \"ans\"\n      }), \" 陣列）放在全域、「放好了幾個橫列」（參數 \", _jsx(_components.code, {\n        children: \"x\"\n      }), \"，代表接下來要放的那個橫列）放在 function 參數。在 function 的過程中，就是要枚舉下一步的操作是什麼，計算出對應的狀態改變後，遞迴呼叫 function，呼叫完後要視需要還原剛剛被修改過的狀態。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DFS 可以幫我們以很直觀、像是我們在畫樹狀圖的方式枚舉我們想要的東西。與其說是在枚舉，將 DFS 用「搜尋」的角度理解會更準確一點，使用 DFS 的情境並不只有在我們想要枚舉東西時，像是走迷宮，比起枚舉，我們更像是在尋找所有可以走到的地方，而枚舉物件也可以想成我們是在搜尋所有我們想要枚舉的物件。DFS 除了是一種搜尋的方式之外，「優先往深處走」的特性，有時也可以幫我們達到特殊的目的，中序遍歷就是一個例子，將來我們還會發掘更多 DFS 的特殊用途。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/63/\",\n      src: \"NEOJ 63\",\n      name: \"Lotto\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/NEOJ/63/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/63/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/63/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/63/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://neoj.sprout.tw/problem/62/\",\n      src: \"NEOJ 62\",\n      name: \"數獨\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/NEOJ/62/description.mdx\",\n      constraintsMdx: \"guide/problems/NEOJ/62/constraints.mdx\",\n      importMdx: \"guide/problems/NEOJ/62/description.mdx\",\n      importMdx: \"guide/problems/NEOJ/62/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=c129\",\n      src: \"ZeroJudge c129\",\n      name: \"Oil Deposits\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/ZeroJudge/c129/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/c129/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/c129/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/c129/constraints.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=a597\",\n      src: \"ZeroJudge a597\",\n      name: \"祖靈被榨乾了!!!!!!!!\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/ZeroJudge/a597/description.mdx\",\n      constraintsMdx: \"guide/problems/ZeroJudge/a597/constraints.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a597/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/a597/constraints.mdx\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/i644/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"西洋棋這個遊戲是在一個 $8 \\\\times 8$ 的棋盤上進行的，我們定義棋盤的左上角那一格是 $(1,1)$、第 $r$ 列（row）第 $c$ 行（column）的格子是 $(r,c)$。在西洋棋中，一個皇后可以吃到跟它在同一行、同一列或同一條斜線上其他棋子，現在有一個空的棋盤，請你在棋盤上放置恰好 $8$ 個皇后，使得它們都不能吃到對方。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"請輸出所有可能的放法，一個放法以第 8 個數字表示，其中第 $i$ 個數字代表第 $i$ 橫列（row）上的棋子要放在哪一個直行（column），按照字典序輸出。也就是說，如果有兩種不一樣的放法，在它們第一個放在不同直行的橫列上，放得比較左邊的放法要優先被輸出。\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/problems/ZeroJudge/i644/figure/board.png\",\n      width: \"250\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/subset_bound/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給 $n$ 個正整數 $a_1,a_2,\\\\dots,a_n$ 和一個數字 $S$，請列出所有 index 的集合 $i_1,i_2,\\\\dots,i_k$，滿足 $a_{i_1}+a_{i_2}+\\\\dots+a_{i_k} \\\\leq S$。輸出的每一行代表一個集合，將集合中的數字 index 由小到大輸出，不同集合可以用任意順序輸出。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/subset_bound/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 100$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"保證答案個數 $\\\\leq 10^4$。\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/maze_find_path/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"有一個 $n \\\\times n$ 的棋盤，上面有一些障礙物，其餘格子是空地，障礙物以 \", _jsx(_components.code, {\n      children: \"#\"\n    }), \" 表示、空地以 \", _jsx(_components.code, {\n      children: \".\"\n    }), \" 表示，一開始你在左上角，你每一步可以上、下、左、右移動一格，但是不能走出棋盤或是走進障礙物裡，請找一條長度是 $n^2$ 以內的走到右下角的路徑，以一個 \", _jsx(_components.code, {\n      children: \"UDLR\"\n    }), \" 字串表示，這四個字元分別代表往上下左右走一格。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/Misc/maze_find_path/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\leq 1000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"左上角和右下角不會是障礙物\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"保證走得到\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/63/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"給你 $k > 6$ 個數字，按字典序輸出所有大小恰好為 6 的子集（一個子集裡的數字按照小到大排序）。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/63/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"有 $T$ 筆測資，$T \\\\leq 1000$\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"$6 < k < 13$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/62/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Figure} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"在數獨遊戲中，遊戲給你一個 $9\\\\times 9$ 的方陣，其中還可以分成 $9$ 個 $3\\\\times 3$ 的子方陣。例如：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/problems/NEOJ/62/figure/ZtaggER.png\",\n      width: \"200\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"數獨的遊戲規則是這樣的，最後完成數獨的時候，每個格子都必須填上 $1\\\\sim 9$ 其中一個數字，並且在每一行、每一列、每一個子方陣中，都不能有重複的數字。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"現在給你一個 $9\\\\times 9$ 的方陣，上面有一些格子已經寫上數字了，你的任務是完成這個數獨。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/NEOJ/62/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"每筆測試資料未填上數字的格子數保證不超過 $15$ 個\"\n    }), \"\\n\", _jsx(_components.li, {\n      children: \"單一測資檔不超過十筆測試資料\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/c129/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"有一個 $m \\\\times n$ 的棋盤，每個格子分成有石油或沒有石油，求有幾個八方位連通的有石油的區域。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/c129/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$m,n \\\\leq 100$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a597/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"有一個 $m \\\\times n$ 的棋盤，每個格子上寫著 \", _jsx(_components.code, {\n      children: \"X\"\n    }), \" 或 \", _jsx(_components.code, {\n      children: \"J\"\n    }), \"，求有幾個 \", _jsx(_components.code, {\n      children: \"J\"\n    }), \" 的連通塊（四方位）、最大的連通塊有多大。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/a597/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$m,n \\\\leq 500$\"\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"遞迴與枚舉","depth":1,"code":"遞迴與枚舉"},{"text":"剪枝","depth":1,"code":"剪枝"},{"text":"深度優先搜尋","depth":1,"code":"深度優先搜尋"},{"text":"枚舉的順序","depth":2,"code":"深度優先搜尋-枚舉的順序"},{"text":"例題：走迷宮","depth":1,"code":"例題：走迷宮"},{"text":"複習：拜訪一棵樹","depth":1,"code":"複習：拜訪一棵樹"},{"text":"小結","depth":1,"code":"小結"},{"text":"習題","depth":1,"code":"習題"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}