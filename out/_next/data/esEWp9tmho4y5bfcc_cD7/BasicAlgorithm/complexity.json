{"pageProps":{"props":{"mdxPath":"guide/content/BasicAlgorithm/complexity/complexity.mdx","code":"BasicAlgorithm/complexity","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"廣度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["AlgorithmTechnique/dfs"],"coming":false},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"分治法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting","BasicAlgorithm/recursion","BasicAlgorithm/two_pointers"],"coming":false},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":true,"title":"深度優先搜尋","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/structured_binding","BasicAlgorithm/recursion","BasicAlgorithm/enumerate","BasicDataStructure/binary_tree"],"coming":false},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","ImplementationKnowledge/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/backtracking","article":"backtracking","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 回溯","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/basic_optimization","article":"basic_optimization","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"DP 的基本優化","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/structure"],"coming":true},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":false},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":false},{"code":"BasicDynamicProgramming/range_dp","article":"range_dp","topic":"BasicDynamicProgramming","chapter":null,"valid":true,"title":"區間 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":false},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicDynamicProgramming/structure","article":"structure","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"動態規劃的必要元素","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/rolling"],"coming":false},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":false},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","ImplementationSkill/buglist"],"coming":false},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":true,"title":"二分圖","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicGraph/graph_concepts"],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":true,"title":"圖論基礎","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicAlgorithm/searching","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","AlgorithmTechnique/bfs","AlgorithmTechnique/dfs"],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":true,"title":"單調隊列","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicDataStructure/stack_queue_deque","BasicAlgorithm/sweep"],"coming":false},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 III","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":true,"title":"貪心法 II","authors":["baluteshih"],"contributors":[],"prerequisites":["GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/basic_knowledge","article":"basic_knowledge","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"ImplementationKnowledge/compiler","article":"compiler","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/float_error","article":"float_error","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/input","article":"input","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge"],"coming":false},{"code":"ImplementationKnowledge/reference","article":"reference","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"ImplementationKnowledge/rngbased","article":"rngbased","topic":"ImplementationKnowledge","chapter":"III","valid":true,"title":"Range-based for loop","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/reference","BasicDataStructure/vector"],"coming":false},{"code":"ImplementationKnowledge/structured_binding","article":"structured_binding","topic":"ImplementationKnowledge","chapter":"III","valid":false,"title":"Structured Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"ImplementationKnowledge/variable","article":"variable","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/reference","ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationKnowledge/variable_declare","article":"variable_declare","topic":"ImplementationKnowledge","chapter":"II","valid":true,"title":"常用變數宣告方法","authors":["WiwiHo","baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/buglist","article":"buglist","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["ImplementationKnowledge/variable"],"coming":false},{"code":"ImplementationSkill/debug","article":"debug","topic":"ImplementationSkill","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["ImplementationSkill/buglist"],"coming":false},{"code":"ImplementationSkill/error_message","article":"error_message","topic":"ImplementationSkill","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["ImplementationKnowledge/compiler"],"coming":false},{"code":"ImplementationSkill/pseudo_pointer","article":"pseudo_pointer","topic":"ImplementationSkill","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"ImplementationKnowledge","title":"實作知識","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error"]},{"code":"ImplementationSkill","title":"實作技巧","contents":["ImplementationSkill/error_message","ImplementationSkill/buglist","ImplementationSkill/debug","ImplementationSkill/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","BasicDynamicProgramming/basic_optimization","BasicDynamicProgramming/range_dp","BasicDynamicProgramming/backtracking"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["ImplementationKnowledge"]},{"single":true,"title":"","topics":["ImplementationSkill"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["ImplementationKnowledge/basic_knowledge","ImplementationKnowledge/input","ImplementationKnowledge/reference","ImplementationKnowledge/compiler","ImplementationKnowledge/variable","ImplementationKnowledge/variable_declare","ImplementationSkill/error_message","ImplementationSkill/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","ImplementationKnowledge/rngbased","ImplementationKnowledge/structured_binding","ImplementationKnowledge/float_error","ImplementationSkill/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","BasicDynamicProgramming/structure","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/BasicAlgorithm/complexity/complexity.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    blockquote: \"blockquote\",\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\",\n    table: \"table\",\n    tbody: \"tbody\",\n    td: \"td\",\n    th: \"th\",\n    thead: \"thead\",\n    tr: \"tr\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Figure, Refcode, Theorem} = _components;\n  if (!Figure) _missingMdxReference(\"Figure\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  if (!Theorem) _missingMdxReference(\"Theorem\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"究竟什麼是效率？\",\n      children: \"究竟什麼是效率？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"假設一位老師要發考卷給班上 $5$ 位學生，反正人也沒很多，每張考卷拿起來再直接找到對應的學生給他就好。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過如果我們事先排好考卷的順序呢？這樣這位老師只要走過一圈教室就可以把考卷發完了，也不會發生他要反覆從教室一端跑到另一端的狀況。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣到底省下了多少時間？我們就假設 $5$ 位學生的座位大概也不會坐太遠，可能最遠也只要花費 $3$ 秒的時間就可以自由的在任兩個學生之間來回。所以最慘就花個 $5\\\\times 3=15$ 秒吧。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果走過一圈教室也差不多要花 $5$ 秒，照這樣看來，先排好考卷頂多只幫助我們省下 $10$ 秒的時間。好像沒有很多嘛。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但要是學生變成十倍，也就是 $50$ 位呢？這時候在兩個學生之間來回可能就得花費 $30$ 秒，$50$ 位學生更是會讓總花費時間變成 $1500$ 秒！這時，因為走過一圈教室也許只要花 $50$ 秒，所以事先排好考卷的優勢便開始出現了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"更進一步的，如果學生變成 $500$ 位呢？$5000$ 位呢？你能想像這個差距嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在寫程式的世界中，我們常常要面對的就是這種「比平常還要大非常多」的測試資料，很可能動不動就是 $5000$ 行字串、$10^5$ 個數字。想當然的，資料量變多，程式一定會變慢，而所謂的效率，就是能穩定的在數字變大時，還可以控制「程式變慢的幅度」，使得程式雖然變慢了，也不至於太誇張。這才是我們所要追求的「效率」。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"演算法的效率 ─ 時間複雜度\",\n      children: \"演算法的效率 ─ 時間複雜度\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"演算法的效率 ─ 時間複雜度-分析效率的必要性\",\n      children: \"分析效率的必要性\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我們知道，程式競賽中的題目都有著所謂的「時限」，而判斷自己的演算法在寫成程式後能不能在規定的時限內執行完畢，就得來分析他的效率了。就好比我們寫出了下面這段程式碼：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void bubble_sort(int arr[], int n) { \\n    for (int i = 0; i < n - 1; ++i)         \\n        for (int j = 0; j < n - i - 1; ++j) \\n            if (arr[j] > arr[j + 1]) {      \\n                int tmp = arr[j];           \\n                arr[j] = arr[j + 1];        \\n                arr[j + 1] = tmp;           \\n            }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"那當 $n=10$ 時，他能在一秒內跑完嗎？$n=1000$ 可以嗎？$n=10^5$ 呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果盲目的將程式寫完後就傳上 Online Judge 等待結果，可想而知的就是會時常因為獲得 TLE 而落後其他對自己程式的效率夠清楚的選手。更可怕的是，如果我們設計好的演算法其實不管怎麼樣都無法被寫成一個能在時限內跑完的程式的話，還一無所知的浪費大把時間下去寫，不就白忙一場了嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也因此，提前想清楚自己演算法的效率便成為一個非常重要的事項。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"演算法的效率 ─ 時間複雜度-如何分析效率？\",\n      children: \"如何分析效率？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果我們仔細一行一行計算上面程式所需要花費的「步驟數量」的話，似乎可以這樣條列：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void bubble_sort(int arr[], int n) { // arr: 要排序的陣列，n: 陣列大小\\n    for (int i = 0; i < n - 1; ++i)              // n 次運算\\n        for (int j = 0; j < n - i - 1; ++j)      // (n - 1) + (n - 2) + ... + 1 = n * (n - 1) / 2 次運算\\n            if (arr[j] > arr[j + 1]) {           // n * (n - 1) / 2 次運算\\n                int tmp = arr[j];                // 至多 n * (n - 1) / 2 次運算\\n                arr[j] = arr[j + 1];             // 至多 n * (n - 1) / 2 次運算\\n                arr[j + 1] = tmp;                // 至多 n * (n - 1) / 2 次運算\\n            }\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"也因此，可以計算出這個程式需要執行的步驟數量至多為\", _jsx(_components.br, {}), \"\\n\", \"$$ n + 5 \\\\times \\\\frac{n(n-1)}{2} = \\\\frac{5}{2} n^2 - \\\\frac{3}{2} n$$\", _jsx(_components.br, {}), \"\\n\", \"在算出步驟數量後，我們就可以去預估程式的執行時間了。因此當 $n=1000$ 時，這個程式至多需要跑 $2.5\\\\times 1000\\\\times 1000-1.5\\\\times 1000=2498500$ 步；而當 $n=10^5$ 時就是 $24999850000$ 步。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"等等……算出步驟量然後呢？到底能不能跑進一秒啊？\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在現代的程式競賽中，我們會有一些簡單的共識：電腦一秒鐘大約可以跑 $10^9$ 次\", _jsx(_components.strong, {\n        children: \"基礎運算\"\n      }), \"。所謂的基礎運算，就是泛指 C++ 中基本的五則運算（\", _jsx(_components.code, {\n        children: \"+ - * / %\"\n      }), \"）、變數賦值、陣列存取、條件判斷（\", _jsx(_components.code, {\n        children: \"< == >\"\n      }), \"）等。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也因此，$n=1000$ 的情況下只需要不用 $0.003$ 秒就可以跑完了，但 $n=10^5$ 時可就要跑大約 $25$ 秒！\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"演算法的效率 ─ 時間複雜度-何謂時間複雜度\",\n      children: \"何謂時間複雜度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讀者讀到這裡可能開始起疑了：怎麼可能每次我分析效率都要這麼麻煩的算式子？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"沒錯，我們在設計演算法時，是不會真的把程式先寫出來再一行一行計算的，在講究速度的比賽中，哪有閒功夫做這些瑣碎的麻煩事呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"為了簡單描述演算法的效率，我們會採用「時間複雜度」這個概念。例如上述的程式，我們會說「他的時間複雜度是 $O(n^2)$」。就讓我們先認識一下這個符號：\"\n    }), \"\\n\", _jsxs(Theorem, {\n      type: \"definition\",\n      title: \"Big-O\",\n      number: \"1\",\n      children: [_jsx(_components.p, {\n        children: \"$O$ 這個符號讀做 Big-O，表示一個函數成長趨勢的上限。為了表示上限，我們會無視係數、並捨棄那些成長趨勢較緩慢的項。\"\n      }), _jsx(_components.p, {\n        children: \"例如當 $T(n) = \\\\frac{5}{2} n^2 - \\\\frac{3}{2} n$ 時：\"\n      }), _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"我們可以丟棄係數 $\\\\frac{5}{2}$ 和 $\\\\frac{3}{2}$ 得到 $n^2 - n$\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"再丟棄成長趨勢比較緩慢的 $n$\"\n        }), \"\\n\"]\n      }), _jsx(_components.p, {\n        children: \"就可以直接說 $T(n)$ 是 $O(n^2)$。\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"省略了這麼多東西有什麼好處呢？我們重新將 $n=1000$ 和 $n=10^5$ 代入 $n^2$ 看看，就會分別得到 $10^6$ 和 $10^{10}$，而使用電腦一秒可以執行 $10^9$ 次基礎運算的基準去衡量的話，就會很明顯的看出 $n=10^5$ 肯定跑不進一秒了！\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"演算法的效率 ─ 時間複雜度-計算時間複雜度\",\n      children: \"計算時間複雜度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"認識完時間複雜度後，我們就可以來學習如何計算時間複雜度了。想像我們打算寫出上面那段程式，我們在腦袋中想的會是什麼呢？\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"我要跑一個迴圈，\", _jsx(_components.code, {\n          children: \"i\"\n        }), \" 從 \", _jsx(_components.code, {\n          children: \"0\"\n        }), \" 到 \", _jsx(_components.code, {\n          children: \"n-2\"\n        }), _jsx(_components.br, {}), \"\\n\", \"每次我會依序檢查前 \", _jsx(_components.code, {\n          children: \"n-i-1\"\n        }), \" 個位置\", _jsx(_components.br, {}), \"\\n\", \"如果前一項大於後一項，就交換這兩個位置上的數字\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"有上述思路後，複雜度的計算就呼之欲出了：迴圈要跑 $n$ 次、每次檢查至多 $n$ 次、交換是瞬間的，所以就大約是 $n\\\\times n$，時間複雜度為 $O(n^2)$！\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"讀者可以注意到，上述的計算我們也不在乎什麼 \", _jsx(_components.code, {\n        children: \"n-i-1\"\n      }), \" 這種詳細的次數，反正他也只會造成係數上的差距而已，不如就直接當成 \", _jsx(_components.code, {\n        children: \"n\"\n      }), \" 就行了。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"是不是單純多了呢？\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"演算法的效率 ─ 時間複雜度-複雜度之間的運算\",\n      children: \"複雜度之間的運算\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"總不可能每次寫程式都只有簡單的幾層迴圈吧？就好比在執行完上面的程式後，如果還要輸出整個陣列的樣子的話，就要多花 $O(n)$ 的時間將其輸出出來，那這樣的時間複雜度是多少呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讀者可以當成我們是直接在進行「相加」的運算，也就是試著直接求 $O(n^2) + O(n)$ 是多少！這時，比較弱的項可以被丟棄，因此就會直接得到 $O(n^2)$ 這個答案。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"「相乘」在複雜度上也是沒問題的，而其實我們早就偷偷用過相關的概念了。前述的例子其實就是一個典型的「$O(n)$ 次窮舉，每次執行 $O(n)$ 次的檢查」，所以直接透過 $O(n) \\\\times O(n)$，就能得出 $O(n^2)$ 了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，在分析時間複雜度時，我們可以放心的直接對這些複雜度進行加法跟乘法。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"同樣也很重要 ─ 空間複雜度\",\n      children: \"同樣也很重要 ─ 空間複雜度\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"除了程式的執行時間，我們也很在乎這個程式用了多少記憶體，過大的記憶體使用量會導致電腦無法執行。記憶體使用量就是這個程式的空間複雜度，而這會與變數型態、變數數量以及陣列大小有關。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"計算空間複雜度的方法與時間複雜度類似，甚至更為單純，我們只需要去估計程式會宣告出來的記憶體量即可，就好比宣告一個長度為 $n$ 的陣列，使用的空間複雜度就至少是 $O(n)$。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由於空間複雜度還不會是初學競賽程式時的重點，這裡就不再多描述，相信讀者在未來的篇章慢慢熟悉後，真的遇到了需要認真分析空間複雜度的狀況也不會太過陌生。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"範例\",\n      children: \"範例\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下透過幾份程式碼，來幫助大家學會分析複雜度。當然，前面也說過實際在比賽時，我們是不會等到寫完程式碼才去分析複雜度的。不過畢竟我們也還沒教過什麼演算法嘛！就讓我們先試著用程式碼來練習分析，等到未來的章節就能看到各式不同演算法是如何被分析的，就能漸漸熟悉了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"為了方便起見，我們會用 $T(n)$ 來表示每一份程式的時間複雜度。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"範例-判斷質數\",\n      children: \"判斷質數\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"bool is_prime(int n) { // 判斷 n 是否是質數\\n    if (n == 1) return false;\\n    for (int i = 2; i * i <= n; ++i)\\n        if (n % i == 0) return false;\\n    // 若 n 不是質數，假設 n = a * b (a, b > 1)，則 min(a, b) * min(a, b) <= a * b = n\\n    // 也就是 n 不是質數若且唯若 n 的其中一個因數會介於 2 到 sqrt(n) 之間或 n = 1\\n    return true;\\n    // 若找不到介於 2 到 sqrt(n) 的因數，則 n 為質數\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其中特判 \", _jsx(_components.code, {\n        children: \"n == 1\"\n      }), \" 的部分是 $O(1)$， \", _jsx(_components.code, {\n        children: \"for\"\n      }), \" 迴圈總共會跑至多 $\\\\sqrt{n}$ 次，而迴圈內的運算每次執行都是 $O(1)$ 時間，因此總時間複雜度為 $T(n) = O(1) + O(\\\\sqrt{n}) \\\\cdot O(1) = O(1) + O(\\\\sqrt{n}) = O(\\\\sqrt{n})$。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"空間複雜度的部分，除了 $n$ 以外只多用了一個變數 $i$ ，因此空間複雜度為 $O(1)$。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"範例-簡單的遞迴函數\",\n      children: \"簡單的遞迴函數\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int solve(int n) {\\n    if (n == 0) return 0;\\n    return solve(n - 1) + 1;\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在 \", _jsx(_components.code, {\n        children: \"return\"\n      }), \" 之前的部分時間複雜度為 $O(1)$，因此將可以列出複雜度的遞迴關係為 $T(n) = T(n - 1) + O(1)$，然後繼續往下遞迴可以得知時間複雜度為\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\\\[\", _jsx(_components.br, {}), \"\\n\", \"\\\\begin{align*}\", _jsx(_components.br, {}), \"\\n\", \"T(n) &= T(n - 1) + O(1) \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"&= T(n - 2) + 2 \\\\cdot O(1)  \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"&= T(n - 3) + 3 \\\\cdot O(1)  \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"&= \\\\cdots  \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"&= T(0) + n \\\\cdot O(1)  \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"&= O(1) + n \\\\cdot O(1)  \\\\\\\\\", _jsx(_components.br, {}), \"\\n\", \"&= O(n)\", _jsx(_components.br, {}), \"\\n\", \"\\\\end{align*}\\\\]\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"空間複雜度的部分，雖然看起來沒有用到新的變數，但實際上每次函數中的參數 $n$ 會占用 $O(1)$ 的空間，因此 $n$ 次遞迴加總起來的結果會占用 $O(n)$ 的空間。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"範例-一個沒那麼單純的例子\",\n      children: \"一個沒那麼單純的例子\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"再來看一個比較難的例子：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int monotonic_stack(int arr[], int stk[], int n) { // n: arr 陣列的大小\\n    int stk_size = 0;\\n    for (int i = 0; i < n; ++i) {\\n        while (stk_size > 0 && stk[stk_size - 1] <= arr[i]) {\\n            --stk_size;\\n        }\\n        stk[stk_size++] = arr[i];\\n    }\\n    return stk_size;\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在第四行的 \", _jsx(_components.code, {\n        children: \"for\"\n      }), \" 迴圈會跑 $n$ 次，由於 \", _jsx(_components.code, {\n        children: \"stk_size\"\n      }), \" 可能會到 $n$，因此第五行的 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈可能會被跑 $n$ 次，此時可能會想說時間複雜度就是 $O(n) \\\\times O(n) = O(n^2)$。但實際上不是這樣的，如果我們不是關注每次 \", _jsx(_components.code, {\n        children: \"for\"\n      }), \" 迴圈時 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈會被跑幾次，而是關注 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈\", _jsx(_components.strong, {\n        children: \"總共\"\n      }), \"會被跑幾次呢？\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"由於每次跑 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈會讓 \", _jsx(_components.code, {\n        children: \"stk_size\"\n      }), \" 減去一、卻不會使其 $<0$，又因為 \", _jsx(_components.code, {\n        children: \"stk_size\"\n      }), \" 頂多只會增加 $n$ 次（因為第七行只會跑 $n$ 次），所以這個 \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈只會被跑過 $n$ 次，因此總時間複雜度 $=$ \", _jsx(_components.code, {\n        children: \"stk_size\"\n      }), \" 增加次數 $+$ \", _jsx(_components.code, {\n        children: \"while\"\n      }), \" 迴圈執行次數 $= O(n)$。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"空間複雜度的部分，包含了 \", _jsx(_components.code, {\n        children: \"arr\"\n      }), \" 陣列（大小為 $n$）、變數 \", _jsx(_components.code, {\n        children: \"n\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"i\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"stk_size\"\n      }), \"（大小為 $O(1)$）、\", _jsx(_components.code, {\n        children: \"stk\"\n      }), \" 需要使用到的空間（\", _jsx(_components.code, {\n        children: \"stk_size\"\n      }), \" 最大只到 $n$），因此加總起來空間複雜度為 $O(n)$。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過這份程式碼在做什麼呢？相信不久遠的未來就會再看見他了……\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"重新了解複雜度\",\n      children: \"重新了解複雜度\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"重新了解複雜度-何謂「趨勢」\",\n      children: \"何謂「趨勢」\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"也許讀者對於我們省略了這麼多係數和項數還保留著一些存疑，但就好比我們最一開始舉的例子，我們關注的總是「當資料量越來越大時，你的演算法究竟能多快？」，也因此「成長趨勢最快」的那項理當才會變成我們最在乎的。就讓我們用以下圖片來再解釋一下：\"\n    }), \"\\n\", _jsx(Figure, {\n      src: \"/files/content/BasicAlgorithm/complexity/figure/functions.png\",\n      width: \"300\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"上圖中，綠色曲線符號是 $f(n) = n^2$，紅色曲線是 $g(n) = 3n^2$，藍色曲線是 $h(n) = \\\\frac{1}{3} n^3$，儘管 $h$ 的係數很小，$f, g$ 的係數很大，但由於 $n^3$ 的成長趨勢比 $n^2$ 快，所以當 $n$ 足夠大時 $h(n)$ 還是會比 $f(n)$ 跟 $g(n)$ 大。所以這就是為什麼我們計算時間複雜度時只看成長趨勢最快的那項，並且不過度在意係數的原因。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"重新了解複雜度-為何是「上限」？\",\n      children: \"為何是「上限」？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通常我們在做題目的時候，只會考慮這個做法的複雜度的上限，儘管他在大部分的情況不會達到這個複雜度，我們還是必須考慮最糟的情況，確保每個情況都能在這個複雜度的時間內跑完。就好比以下這份程式碼：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"long long solve(int n) {\\n    if (n % 100000 == 0) {\\n        long long sum = 0;\\n        for (int i = 1; i <= n; ++i)\\n            sum += i;\\n        return sum;\\n    }\\n    return 0;\\n}\\n\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"他的時間複雜度是多少呢？答案是 $O(n)$ 的！就算 $n$ 不是 $10^5$ 的倍數他會立即結束，只要出題者在題目裡面放上一個 $10^5$ 的倍數當做測試資料，這份程式碼就會因此花費 $n$ 的時間。這也是為什麼我們只在意、也必須在意上限了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"重新了解複雜度-常數\",\n      children: \"常數\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"前面我們已經宣導了省略係數的好處，但我們再次把前面分析成 $O(n^2)$ 的程式碼拿回來講：如果我執行這段程式碼 $1000$ 次，那他還能跑進一秒嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"假設我們直接用一般的時間複雜度去分析，$1000n^2$，可以省略係數，所以也是 $O(n^2)$ 吧？但如果實際用前面分析出來的 $0.003$ 秒下去算的話，$1000$ 倍的時間就是 $3$ 秒，差距非常慘烈。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這種隱藏在複雜度包裝下、看不見的係數我們又稱為「常數」。實際上，即使是 C++ 的基本運算，還是有一些比較慢的操作。就好比除法跟 \", _jsx(_components.code, {\n        children: \"%\"\n      }), \" 運算，這兩者的運算速度其實幾乎是加減法的 $5$ 倍以上！而我們最常使用的輸入、輸出其實也非常非常的慢，常常在輸入有 $10^7$ 個數字時，程式就得花費個好幾秒才能輸入完畢。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此，就算有時候演算法的時間複雜度很好，也還是要稍微考慮一下有沒有可能因為執行了過多倍的運算，導致速度比想像中還要慢一些。就好像如果執行了 $10^5$ 次 $O(n)$ 的演算法，在 $n=10^5$ 的情況下，不就跟 $O(n^2)$ 一樣慢了嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過其實在初學程式競賽時還不用太過擔心這個問題，還是先分析出單純的時間複雜度才比較要緊。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"真正應用在程式競賽上的話……\",\n      children: \"真正應用在程式競賽上的話……\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"真正應用在程式競賽上的話……-選手們的估計方式\",\n      children: \"選手們的估計方式\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"假設時間限制是 $t$ 秒，而某個做法複雜度是 $O(f(n))$，只要常數不要太大的話，通常我們可以當成只要 $f(n) \\\\leq 10^8\\\\times t$ 就可以通過，有時候順利的話 $10^9\\\\times t$ 也可以通過。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但是還請別忘記，複雜度並不能計算絕對時間，只能計算 $n$ 大小變化時的成長趨勢，常在 $n$ 很小、或是某些特殊情況下時，複雜度大但常數小的演算法反而會跑的比複雜度小但常數大的演算法快，這就是未來各位讀者可能會逐漸體會到的課題了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"真正應用在程式競賽上的話……-常見複雜度以及對應範圍\",\n      children: \"常見複雜度以及對應範圍\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由於分析複雜度實在是太過重要，因此競賽選手們時常會直接以輸入的範圍限制，例如 $n$ 的大小上限，並搭配可能的常數大小來判斷自己設計出來的演算法時間複雜度是否吻合於範圍限制，就不用再浪費時間慢慢代入 $n$ 的值來估計執行速度了。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下皆假設題目的時間限制為 $1$ 秒，用來估算的數字為 $n$：\"\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"時間複雜度\"\n          }), _jsx(_components.th, {\n            children: \"常數大小\"\n          }), _jsx(_components.th, {\n            children: \"常見 $n$ 的上限\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n)$\"\n          }), _jsx(_components.td, {\n            children: \"夠小\"\n          }), _jsx(_components.td, {\n            children: \"$10^7$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n)$\"\n          }), _jsx(_components.td, {\n            children: \"略大\"\n          }), _jsx(_components.td, {\n            children: \"$10^6$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n\\\\log n)$\"\n          }), _jsx(_components.td, {\n            children: \"夠小\"\n          }), _jsx(_components.td, {\n            children: \"$10^6$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n\\\\log n)$\"\n          }), _jsx(_components.td, {\n            children: \"一般\"\n          }), _jsx(_components.td, {\n            children: \"$5\\\\times 10^5$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n\\\\log n)$\"\n          }), _jsx(_components.td, {\n            children: \"過大\"\n          }), _jsx(_components.td, {\n            children: \"$2\\\\times 10^5$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n\\\\log^2 n)$\"\n          }), _jsx(_components.td, {\n            children: \"夠小\"\n          }), _jsx(_components.td, {\n            children: \"$10^5$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n\\\\log^2 n)$\"\n          }), _jsx(_components.td, {\n            children: \"一般\"\n          }), _jsx(_components.td, {\n            children: \"$5\\\\times 10^4$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n^2)$\"\n          }), _jsx(_components.td, {\n            children: \"夠小\"\n          }), _jsx(_components.td, {\n            children: \"$10000$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n^2)$\"\n          }), _jsx(_components.td, {\n            children: \"一般\"\n          }), _jsx(_components.td, {\n            children: \"$5000$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n^2)$\"\n          }), _jsx(_components.td, {\n            children: \"略大\"\n          }), _jsx(_components.td, {\n            children: \"$3000$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n^2\\\\log n)$\"\n          }), _jsx(_components.td, {\n            children: \"夠小\"\n          }), _jsx(_components.td, {\n            children: \"$3000$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n^2\\\\log n)$\"\n          }), _jsx(_components.td, {\n            children: \"一般\"\n          }), _jsx(_components.td, {\n            children: \"$1000$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n^3)$\"\n          }), _jsx(_components.td, {\n            children: \"極小\"\n          }), _jsx(_components.td, {\n            children: \"$1000$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(n^3)$\"\n          }), _jsx(_components.td, {\n            children: \"一般\"\n          }), _jsx(_components.td, {\n            children: \"$500$\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"$O(2^n)$\"\n          }), _jsx(_components.td, {\n            children: \"需要仔細評估\"\n          }), _jsx(_components.td, {\n            children: \"$20\\\\sim 25$\"\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"當然，上表只不過是一種估計而已，實際狀況還是有不少變化，這裡僅供初學者參考。至於上述「判斷常數大不大」的欄位，常數到底怎樣算大呢？這可能就要各位讀者自行多體會幾次了──總是得在試錯中成長！\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"另外就是上表提供的參考基準是 $1$ 秒，所以也常可以看到解答是 $O(n\\\\log^2n)$ 的題目將範圍出到 $2\\\\times 10^5$，並直接將時限開到 $5$ 秒等狀況。而根據 Online Judge 的不同，程式碼的執行速度也會有差距，甚至在一些古老的 Judge 上，會出現 $10^6$ 幾乎無法讓 $O(n\\\\log n)$ 通過的現象，所以實際上還是要多遇過幾次狀況才會比較有經驗。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"總結\",\n      children: \"總結\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"希望大家在想到一個題目的做法時，可以先想想看這個演算法的複雜度是多少，來判斷這個做法寫出的程式大約要執行多久。如果真的很難分析的話，約略估計也可以得到不錯的效果。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"順帶一提，我們在複雜度使用的 big-O 符號其實在數學上是真的存在應用的符號，只不過擔心太過複雜，我們省略了較為嚴謹的數學定義和敘述。等到未來的篇章，我們會再次提起他們並詳細解釋一遍。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"究竟什麼是效率？","depth":1,"code":"究竟什麼是效率？"},{"text":"演算法的效率 ─ 時間複雜度","depth":1,"code":"演算法的效率 ─ 時間複雜度"},{"text":"分析效率的必要性","depth":2,"code":"演算法的效率 ─ 時間複雜度-分析效率的必要性"},{"text":"如何分析效率？","depth":2,"code":"演算法的效率 ─ 時間複雜度-如何分析效率？"},{"text":"何謂時間複雜度","depth":2,"code":"演算法的效率 ─ 時間複雜度-何謂時間複雜度"},{"text":"計算時間複雜度","depth":2,"code":"演算法的效率 ─ 時間複雜度-計算時間複雜度"},{"text":"複雜度之間的運算","depth":2,"code":"演算法的效率 ─ 時間複雜度-複雜度之間的運算"},{"text":"同樣也很重要 ─ 空間複雜度","depth":1,"code":"同樣也很重要 ─ 空間複雜度"},{"text":"範例","depth":1,"code":"範例"},{"text":"判斷質數","depth":2,"code":"範例-判斷質數"},{"text":"簡單的遞迴函數","depth":2,"code":"範例-簡單的遞迴函數"},{"text":"一個沒那麼單純的例子","depth":2,"code":"範例-一個沒那麼單純的例子"},{"text":"重新了解複雜度","depth":1,"code":"重新了解複雜度"},{"text":"何謂「趨勢」","depth":2,"code":"重新了解複雜度-何謂「趨勢」"},{"text":"為何是「上限」？","depth":2,"code":"重新了解複雜度-為何是「上限」？"},{"text":"常數","depth":2,"code":"重新了解複雜度-常數"},{"text":"真正應用在程式競賽上的話……","depth":1,"code":"真正應用在程式競賽上的話……"},{"text":"選手們的估計方式","depth":2,"code":"真正應用在程式競賽上的話……-選手們的估計方式"},{"text":"常見複雜度以及對應範圍","depth":2,"code":"真正應用在程式競賽上的話……-常見複雜度以及對應範圍"},{"text":"總結","depth":1,"code":"總結"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}