{"pageProps":{"props":{"mdxPath":"guide/content/BasicAlgorithm/algorithm_numeric/algorithm_numeric.mdx","code":"BasicAlgorithm/algorithm_numeric","structure":{"articles":[{"code":"AlgorithmAnalysis/proof","article":"proof","topic":"AlgorithmAnalysis","chapter":null,"valid":true,"title":"證明方法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion"],"coming":false},{"code":"AlgorithmTechnique/bfs","article":"bfs","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"廣度優先搜尋","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dc","article":"dc","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"分治法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/dfs","article":"dfs","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"深度優先搜尋","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/discretization","article":"discretization","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"離散化","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"AlgorithmTechnique/doubling","article":"doubling","topic":"AlgorithmTechnique","chapter":"III","valid":false,"title":"倍增法","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicAlgorithm/algorithm_numeric","article":"algorithm_numeric","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"標準函式庫 ── <algorithm> 與 <numeric>","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/sorting"],"coming":false},{"code":"BasicAlgorithm/binary_search_answer","article":"binary_search_answer","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"對答案二分搜","authors":["WiwiHo"],"contributors":["rabhunter"],"prerequisites":["BasicAlgorithm/enumerate","BasicAlgorithm/searching","GreedyAlgorithm/intuitive_greedy"],"coming":false},{"code":"BasicAlgorithm/complexity","article":"complexity","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"複雜度","authors":["baluteshih"],"contributors":["chengbilly92"],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/enumerate","article":"enumerate","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"枚舉","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/intro","article":"intro","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"介紹","authors":["double"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"BasicAlgorithm/math_in_school","article":"math_in_school","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"學校教的數學","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/searching","BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/partial_sum","article":"partial_sum","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"前綴和與差分","authors":["WiwiHo"],"contributors":["Fysty"],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicAlgorithm/recursion","article":"recursion","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"遞迴","authors":["nathanlee726"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":false},{"code":"BasicAlgorithm/searching","article":"searching","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"搜尋","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicAlgorithm/sorting","article":"sorting","topic":"BasicAlgorithm","chapter":"II","valid":true,"title":"排序演算法","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/complexity"],"coming":false},{"code":"BasicAlgorithm/sweep","article":"sweep","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"一維掃描線","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/rngbased","Implementation/structure_binding","BasicAlgorithm/enumerate","BasicAlgorithm/partial_sum"],"coming":false},{"code":"BasicAlgorithm/two_pointers","article":"two_pointers","topic":"BasicAlgorithm","chapter":"III","valid":true,"title":"雙指標","authors":["rabhunter"],"contributors":[],"prerequisites":["BasicAlgorithm/enumerate"],"coming":false},{"code":"BasicDataStructure/binary_tree","article":"binary_tree","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"二元樹","authors":["建中大講義團隊"],"contributors":["8e7","WiwiHo"],"prerequisites":["BasicDataStructure/linked_list","Implementation/reference"],"coming":false},{"code":"BasicDataStructure/binary_tree_and_stack","article":"binary_tree_and_stack","topic":"BasicDataStructure","chapter":null,"valid":true,"title":"二元樹與 Stack","authors":["8e7"],"contributors":["建中大講義團隊","WiwiHo"],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/heap","article":"heap","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Heap","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/binary_tree"],"coming":false},{"code":"BasicDataStructure/intro","article":"intro","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"介紹","authors":["8e7"],"contributors":["建中大講義團隊"],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"BasicDataStructure/iterator","article":"iterator","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Iterator","authors":["8e7","建中大講義團隊"],"contributors":[],"prerequisites":["BasicDataStructure/intro"],"coming":false},{"code":"BasicDataStructure/linked_list","article":"linked_list","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Linked List","authors":["建中大講義團隊","baluteshih"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/set_map","article":"set_map","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Set 與 Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/heap"],"coming":false},{"code":"BasicDataStructure/stack_queue_deque","article":"stack_queue_deque","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"Stack、Queue 與 Deque","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/vector"],"coming":false},{"code":"BasicDataStructure/unordered","article":"unordered","topic":"BasicDataStructure","chapter":"III","valid":true,"title":"Unordered Set 與 Unordered Map","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/set_map"],"coming":false},{"code":"BasicDataStructure/vector","article":"vector","topic":"BasicDataStructure","chapter":"II","valid":true,"title":"動態的陣列","authors":["建中大講義團隊"],"contributors":["8e7"],"prerequisites":["BasicDataStructure/intro","BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"BasicDynamicProgramming/concept","article":"concept","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"基本概念","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/intro"],"coming":true},{"code":"BasicDynamicProgramming/knapsack","article":"knapsack","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"背包問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/multidimensional"],"coming":true},{"code":"BasicDynamicProgramming/multidimensional","article":"multidimensional","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"多個維度的 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/state_and_transition"],"coming":true},{"code":"BasicDynamicProgramming/rolling","article":"rolling","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"滾動 DP","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/knapsack","BasicDataStructure/vector"],"coming":true},{"code":"BasicDynamicProgramming/state_and_transition","article":"state_and_transition","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"狀態與轉移","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/top_down_and_bottom_up","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/partial_sum"],"coming":true},{"code":"BasicDynamicProgramming/subproblem","article":"subproblem","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"第一道動態規劃問題","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/recursion","BasicAlgorithm/complexity","BasicDynamicProgramming/concept"],"coming":true},{"code":"BasicDynamicProgramming/top_down_and_bottom_up","article":"top_down_and_bottom_up","topic":"BasicDynamicProgramming","chapter":"III","valid":true,"title":"Top down 與 Bottom up","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicDynamicProgramming/subproblem","Implementation/buglist"],"coming":true},{"code":"BasicGraph/basic_tree","article":"basic_tree","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/bipartite_graph","article":"bipartite_graph","topic":"BasicGraph","chapter":"III","valid":false,"title":"二分圖","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/dfs_order","article":"dfs_order","topic":"BasicGraph","chapter":"III","valid":false,"title":"樹壓平","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/graph_concepts","article":"graph_concepts","topic":"BasicGraph","chapter":"III","valid":false,"title":"圖論導論","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/lca","article":"lca","topic":"BasicGraph","chapter":"III","valid":false,"title":"最低共同祖先","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/mst","article":"mst","topic":"BasicGraph","chapter":"III","valid":false,"title":"最小生成樹","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/shortest_path","article":"shortest_path","topic":"BasicGraph","chapter":"III","valid":false,"title":"最短路徑","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicGraph/topological_sort","article":"topological_sort","topic":"BasicGraph","chapter":"III","valid":false,"title":"拓撲排序","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/basicalgo","article":"basicalgo","topic":"BasicMath","chapter":"III","valid":true,"title":"常用數學演算法","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicAlgorithm/math_in_school"],"coming":false},{"code":"BasicMath/combinatorics","article":"combinatorics","topic":"BasicMath","chapter":"III","valid":false,"title":"基礎組合","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/matrix","article":"matrix","topic":"BasicMath","chapter":"III","valid":false,"title":"什麼是矩陣","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"BasicMath/number_theory","article":"number_theory","topic":"BasicMath","chapter":"III","valid":true,"title":"基礎數論","authors":["WiwiHo"],"contributors":[],"prerequisites":["BasicMath/basicalgo"],"coming":false},{"code":"DataStructure/dsu","article":"dsu","topic":"DataStructure","chapter":"III","valid":false,"title":"併查集","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"DataStructure/monotonic_queue","article":"monotonic_queue","topic":"DataStructure","chapter":"III","valid":false,"title":"單調隊列","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Example/subexample","article":"subexample","topic":"Example","chapter":null,"valid":true,"title":"subexample","authors":["example_author1","example_author2"],"contributors":["example_contributor1","example_contributor2"],"prerequisites":["example/example_dependency1","example/example_dependency2"],"coming":false},{"code":"GreedyAlgorithm/greedy_with_ds","article":"greedy_with_ds","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 III","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"GreedyAlgorithm/intuitive_greedy","article":"intuitive_greedy","topic":"GreedyAlgorithm","chapter":"II","valid":true,"title":"貪心法 I","authors":["baluteshih"],"contributors":[],"prerequisites":["BasicAlgorithm/algorithm_numeric"],"coming":false},{"code":"GreedyAlgorithm/unintuitive_greedy","article":"unintuitive_greedy","topic":"GreedyAlgorithm","chapter":"III","valid":false,"title":"貪心法 II","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Guide/chapters","article":"chapters","topic":"Guide","chapter":"I","valid":true,"title":"章節與主題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/language","article":"language","topic":"Guide","chapter":"I","valid":true,"title":"語法學習資源","authors":["abc864197532"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/learning","article":"learning","topic":"Guide","chapter":"I","valid":true,"title":"服用方法","authors":["baluteshih","WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/math_symbol","article":"math_symbol","topic":"Guide","chapter":"I","valid":true,"title":"基本數學符號","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Guide/problems","article":"problems","topic":"Guide","chapter":"I","valid":true,"title":"習題","authors":["baluteshih"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Guide/qa","article":"qa","topic":"Guide","chapter":"I","valid":true,"title":"NTUCPC Guide Q & A","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/basic_knowledge","article":"basic_knowledge","topic":"Implementation","chapter":"II","valid":true,"title":"基本常識","authors":["baluteshih"],"contributors":["dj4zo6u.6"],"prerequisites":["Introduction/online_judge"],"coming":false},{"code":"Implementation/buglist","article":"buglist","topic":"Implementation","chapter":"II","valid":true,"title":"常見錯誤列表","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/variable"],"coming":false},{"code":"Implementation/compiler","article":"compiler","topic":"Implementation","chapter":"II","valid":true,"title":"編譯器","authors":["WiwiHo"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/debug","article":"debug","topic":"Implementation","chapter":null,"valid":true,"title":"Debug","authors":["nathanlee726"],"contributors":[],"prerequisites":["Implementation/buglist"],"coming":false},{"code":"Implementation/error_message","article":"error_message","topic":"Implementation","chapter":"II","valid":true,"title":"如何看錯誤訊息","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/compiler"],"coming":false},{"code":"Implementation/float_error","article":"float_error","topic":"Implementation","chapter":"III","valid":false,"title":"浮點數誤差","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/input","article":"input","topic":"Implementation","chapter":"II","valid":true,"title":"常見輸入類型","authors":["baluteshih"],"contributors":[],"prerequisites":["Implementation/basic_knowledge"],"coming":false},{"code":"Implementation/pseudo_pointer","article":"pseudo_pointer","topic":"Implementation","chapter":"III","valid":false,"title":"偽指標","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/reference","article":"reference","topic":"Implementation","chapter":"II","valid":true,"title":"Reference","authors":["baluteshih"],"contributors":[],"prerequisites":[],"coming":false},{"code":"Implementation/rngbased","article":"rngbased","topic":"Implementation","chapter":"III","valid":false,"title":"Range-Based for loop","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/structure_binding","article":"structure_binding","topic":"Implementation","chapter":"III","valid":false,"title":"Structure Binding","authors":[],"contributors":[],"prerequisites":[],"coming":true},{"code":"Implementation/variable","article":"variable","topic":"Implementation","chapter":"II","valid":true,"title":"全域、區域變數","authors":["WiwiHo"],"contributors":[],"prerequisites":["Implementation/basic_knowledge","Implementation/reference","Implementation/compiler"],"coming":false},{"code":"Introduction/competitive_programming","article":"competitive_programming","topic":"Introduction","chapter":"I","valid":true,"title":"資訊競賽介紹","authors":["臺灣大學程式解題社"],"contributors":[],"prerequisites":["Guide/learning"],"coming":false},{"code":"Introduction/contests_type","article":"contests_type","topic":"Introduction","chapter":"I","valid":true,"title":"比賽類型","authors":["abc864197532","baluteshih"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/online_judge","article":"online_judge","topic":"Introduction","chapter":"I","valid":true,"title":"線上評測系統","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/resources","article":"resources","topic":"Introduction","chapter":"I","valid":true,"title":"網路學習資源介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/competitive_programming"],"coming":false},{"code":"Introduction/tactics","article":"tactics","topic":"Introduction","chapter":"III","valid":true,"title":"比賽 + 練習策略","authors":["nathanlee726"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false},{"code":"Introduction/tw_contests","article":"tw_contests","topic":"Introduction","chapter":"I","valid":true,"title":"台灣資訊競賽介紹","authors":["abc864197532"],"contributors":[],"prerequisites":["Introduction/contests_type"],"coming":false}],"topics":[{"code":"Guide","title":"網站簡介","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa"]},{"code":"Introduction","title":"資訊競賽介紹","contents":["Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources","Introduction/tactics"]},{"code":"Implementation","title":"實作技巧","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","Implementation/debug","Implementation/rngbased","Implementation/structure_binding","Implementation/float_error","Implementation/pseudo_pointer"]},{"code":"BasicAlgorithm","title":"基礎演算法","contents":["BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer"]},{"code":"BasicDataStructure","title":"基礎資料結構","contents":["BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","BasicDataStructure/binary_tree_and_stack"]},{"code":"GreedyAlgorithm","title":"貪心演算法","contents":["GreedyAlgorithm/intuitive_greedy","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds"]},{"code":"BasicMath","title":"基礎數學","contents":["BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix"]},{"code":"AlgorithmTechnique","title":"演算法技巧","contents":["AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling"]},{"code":"BasicDynamicProgramming","title":"基礎動態規劃","contents":["BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling"]},{"code":"DataStructure","title":"資料結構","contents":["DataStructure/monotonic_queue","DataStructure/dsu"]},{"code":"BasicGraph","title":"基礎圖論","contents":["BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}],"topicGroups":[{"single":true,"title":"","topics":["Guide"]},{"single":true,"title":"","topics":["Introduction"]},{"single":true,"title":"","topics":["Implementation"]},{"single":true,"title":"","topics":["BasicAlgorithm"]},{"single":true,"title":"","topics":["BasicDataStructure"]},{"single":true,"title":"","topics":["GreedyAlgorithm"]},{"single":true,"title":"","topics":["BasicMath"]},{"single":true,"title":"","topics":["AlgorithmTechnique"]},{"single":true,"title":"","topics":["BasicDynamicProgramming"]},{"single":true,"title":"","topics":["DataStructure"]},{"single":true,"title":"","topics":["BasicGraph"]}],"chapters":[{"code":"I","title":"Chapter I. 初來乍到","contents":["Guide/learning","Guide/chapters","Guide/problems","Guide/math_symbol","Guide/language","Guide/qa","Introduction/competitive_programming","Introduction/contests_type","Introduction/tw_contests","Introduction/online_judge","Introduction/resources"]},{"code":"II","title":"Chapter II. 新手上路","contents":["Implementation/basic_knowledge","Implementation/input","Implementation/reference","Implementation/compiler","Implementation/error_message","Implementation/variable","Implementation/buglist","BasicAlgorithm/intro","BasicAlgorithm/complexity","BasicAlgorithm/sorting","BasicAlgorithm/algorithm_numeric","BasicAlgorithm/enumerate","BasicAlgorithm/searching","BasicAlgorithm/math_in_school","GreedyAlgorithm/intuitive_greedy","BasicDataStructure/intro","BasicDataStructure/vector","BasicDataStructure/stack_queue_deque","BasicDataStructure/linked_list"]},{"code":"III","title":"Chapter III. 漸入佳境","contents":["Introduction/tactics","Implementation/rngbased","Implementation/structure_binding","Implementation/float_error","Implementation/pseudo_pointer","BasicAlgorithm/recursion","BasicAlgorithm/partial_sum","BasicAlgorithm/sweep","BasicAlgorithm/two_pointers","BasicAlgorithm/binary_search_answer","BasicDataStructure/binary_tree","BasicDataStructure/heap","BasicDataStructure/set_map","BasicDataStructure/unordered","BasicDataStructure/iterator","GreedyAlgorithm/unintuitive_greedy","GreedyAlgorithm/greedy_with_ds","BasicMath/basicalgo","BasicMath/number_theory","BasicMath/combinatorics","BasicMath/matrix","AlgorithmTechnique/dfs","AlgorithmTechnique/bfs","AlgorithmTechnique/discretization","AlgorithmTechnique/dc","AlgorithmTechnique/doubling","BasicDynamicProgramming/concept","BasicDynamicProgramming/subproblem","BasicDynamicProgramming/top_down_and_bottom_up","BasicDynamicProgramming/state_and_transition","BasicDynamicProgramming/multidimensional","BasicDynamicProgramming/knapsack","BasicDynamicProgramming/rolling","DataStructure/monotonic_queue","DataStructure/dsu","BasicGraph/graph_concepts","BasicGraph/bipartite_graph","BasicGraph/basic_tree","BasicGraph/dfs_order","BasicGraph/topological_sort","BasicGraph/shortest_path","BasicGraph/mst","BasicGraph/lca"]}]},"content":[["guide/content/BasicAlgorithm/algorithm_numeric/algorithm_numeric.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    br: \"br\",\n    code: \"code\",\n    h2: \"h2\",\n    h3: \"h3\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  }, {Info, Problem, Refcode} = _components;\n  if (!Info) _missingMdxReference(\"Info\", true);\n  if (!Problem) _missingMdxReference(\"Problem\", true);\n  if (!Refcode) _missingMdxReference(\"Refcode\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      refId: \"不要造輪子\",\n      children: \"不要造輪子\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"別人已經幫你做好的事，就別再自己做了。我們在用的 C++ 其實有提供「標準函式庫（Standard Library，簡稱 STL）」來輔助程式設計者引用各式各樣常用的功能來簡化程式碼，避免寫程式時還要浪費時間寫一堆已經寫過的東西。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"讓我們來複習一下在排序演算法時學過的插入排序法演算法：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void selection_sort(int a[], int n) {\\n    for (int i = 1; i < n; ++i) {\\n        int min_pos = i;\\n        for (int j = i + 1; j <= n; ++j) {\\n            if (a[min_pos] > a[j]) {\\n                min_pos = j;\\n            }\\n        }\\n        if (min_pos != i) { \\n            int tmp = a[min_pos];\\n            a[min_pos] = a[i];\\n            a[i] = tmp;\\n        }\\n    }\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果好好運用 \", _jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \" 的幫助，就可以簡化成這樣！\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"void selection_sort(int a[], int n) {\\n    for (int i = 1; i < n; ++i) {\\n        swap(a[i], *min_element(a + i, a + n + 1));\\n    }\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"是不是簡潔多了呢？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下我們就來跟大家介紹幾個在演算法競賽中常用的函式。只要能熟悉的使用函式庫提供的函式，在比賽中往往都會是有利的加速。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"<algorithm>\",\n      children: _jsx(_components.code, {\n        children: \"<algorithm>\"\n      })\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-介紹\",\n      children: \"介紹\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \" 是 C++ 用來提供各式簡易演算法操作的函式庫，在裡面可以找到各種寫程式常常會用到的演算法。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只要在程式的開頭寫上 \", _jsx(_components.code, {\n        children: \"#include <algorithm>\"\n      }), \" 就可以使用裡面的函式們。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-swap(val1, val2)\",\n      children: _jsx(_components.code, {\n        children: \"swap(val1, val2)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"交換兩個元素時，如果總是要花三行寫\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int tmp = a;\\na = b;\\nb = tmp;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不覺得很麻煩嗎？\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這時候你只要使用\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"swap(a, b);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以乾淨的搞定！\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      refId: \"<algorithm>-min(val1, val2)\",\n      children: [_jsx(_components.code, {\n        children: \"min(val1, val2)\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"max(val1, val2)\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"每次要問兩個元素誰小誰大時，總是要多寫一個 \", _jsx(_components.code, {\n        children: \"if\"\n      }), \" 很麻煩嗎？只要使用\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"min(a, b);\\nmax(a, b);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以分別回傳兩個元素中較小和較大的值，\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"更進階一點，如果希望一次知道多個元素的最小或最大值時，只要多加一個大括號在外面，例如\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"min({a, b, c});\\nmax({a, b, c});\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以了。\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      refId: \"<algorithm>-min_element(first, last)\",\n      children: [_jsx(_components.code, {\n        children: \"min_element(first, last)\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"max_element(first, last)\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"不過，如果是要尋找一個陣列的最小值的話怎麼辦？自己寫的話得多開一個變數、寫一個迴圈遍歷元素才能搞定。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但如果使用函式庫的話，在 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" ~ \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 之間找最小值，就只需要寫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int min_val = *min_element(a + 1, a + n + 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"需要特別注意的是，\", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 裡面第一個放的參數是「陣列開始位置的指標」，第二個則是「陣列結束位置的\", _jsx(_components.strong, {\n        children: \"後一個位置\"\n      }), \"的指標」。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"註：\", _jsx(_components.br, {}), \"\\n\", \"大多數 STL 函式庫的函式在指定「範圍」的時候，結尾都是用「陣列結束位置的\", _jsx(_components.strong, {\n          children: \"後一個位置\"\n        }), \"的指標」傳入的。其理由有非常多種，其中一個筆者認為最合理的理由就是當傳入的範圍是空的時候，STL 可以直接用「開始跟結尾相同」來直接判斷。這在數學上又稱作「左閉右開」。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"那前面的 \", _jsx(_components.code, {\n        children: \"*\"\n      }), \" 是來幹嘛的？這是因為我們偶爾尋找最小值時，不一定只是需要這個最小值的「值」，而是可能會希望知道「最小值位於哪個位置」。因此，\", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 回傳的值其實是「指標」，因此要加一個 \", _jsx(_components.code, {\n        children: \"*\"\n      }), \" 來把值取出來。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"所以，如果想知道位置的話，就可以寫\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int min_pos = min_element(a + 1, a + n + 1) - a;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"那如果有多個最小值呢？這時候得到的位置會是「最前面的最小值」，也就是從 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 掃到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \"，最早碰到的最小值。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"最大值的用法也完全一樣，供參考\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int max_val = *max_element(a + 1, a + n + 1);\\nint max_pos = max_element(a + 1, a + n + 1) - a;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-sort(first, last)\",\n      children: _jsx(_components.code, {\n        children: \"sort(first, last)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"程式競賽最重要的武器之一，排序！要把一個序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 排序，用法也跟 \", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 等函式一樣，只要呼叫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"整個序列就會在 $O(n\\\\log n)$ 的時間內被排序好了！是不是很方便呢？\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-nth_element(first, nth_pos, last)\",\n      children: _jsx(_components.code, {\n        children: \"nth_element(first, nth_pos, last)\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"既然有最小、最大，那就有第 $k$ 小！如果要找出一個序列中第 $k$ 小的數字，聰明的讀者應該可以馬上想到以下寫法\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1);\\nint kth_val = a[k];\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這樣的缺點是，時間複雜度是 $O(n\\\\log n)$，但實際上尋找第 $k$ 小可以 $O(n)$ 搞定！因此，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 就實作了足夠快的演算法來完成這件事。\"]\n    }), \"\\n\", _jsx(Info, {\n      type: \"info\",\n      children: _jsxs(_components.p, {\n        children: [\"註：\", _jsx(_components.br, {}), \"\\n\", \"實際上在 C++ 的規範中，\", _jsx(_components.code, {\n          children: \"nth_element\"\n        }), \" 只需要實作在「平均情況複雜度」是 $O(n)$ 的演算法即可，這意味著在運氣很差的情況下，呼叫 \", _jsx(_components.code, {\n          children: \"nth_element\"\n        }), \" 還是有可能比 $O(n)$ 還慢。但這種情況是不容易遇到的，甚至可以打亂整個序列來迴避特別設計過的測試資料。\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 的用法與 \", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 有些差別，假設要找第 $k$ 小，可以這樣寫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"nth_element(a + 1, a + k, a + n + 1);\\nint kth_val = a[k];\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 的第一個和第三個參數與 \", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \" 一樣，而第二個參數就是「第 $k$ 小的值的位置」。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"沒錯，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 不直接回傳第 $k$ 小的值，而是讓使用者告訴他第 $k$ 小的值的位置，之後他就會幫忙把這個值放在這個位置。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"更準確的說，讀者可以想像 \", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 在做的事就是把「排序好後，會出現在第二個參數位置的值放過去」。不僅如此，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 還會額外保證函式執行完後，「第 $1\\\\sim k-1$ 小」會放在第 $k$ 小的值的左邊；「第 $k+1\\\\sim n$ 小」則會放在第 $k$ 小的值的右邊，但不保證排序的順序。舉例來說，如果序列是\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"3 1 4 1 5 9 2 6\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"呼叫找第四小的話，一種可能的長相是\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"1 2 1 \\\"3\\\" 9 4 6 5\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在已知第四小的數字是 \", _jsx(_components.code, {\n        children: \"3\"\n      }), \" 的情況下，\", _jsx(_components.code, {\n        children: \"3\"\n      }), \" 就會出現在第四個位置，而比較小的數字就會出現在左邊，但順序不一定；反之，比較大的數字就會出現在右邊，順序一樣不一定。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 在未來優化搜尋演算法時會有妙用，但現階段讀者可以先知道其存在就好。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<algorithm>-unique(first, last)\",\n      children: _jsx(_components.code, {\n        children: \"unique(first, last)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"unique\"\n      }), \" 從字面意義上來看，很像是在「把一樣的數字過濾到只剩一個」，但實際上略有差異。準確的說，\", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 在做的事情是「把\", _jsx(_components.strong, {\n        children: \"相鄰\"\n      }), \"一樣的數字過濾到只剩一個」，舉例來說，如果 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[10]\"\n      }), \" 是\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"1 3 3 2 4 4 4 3 3 5\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"呼叫 \", _jsx(_components.code, {\n        children: \"unique(a + 1, a + 11)\"\n      }), \" 之後會變成\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"plaintext\",\n      lineno: \"false\",\n      code: \"1 3 2 4 3 5 ? ? ? ?\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"其中 \", _jsx(_components.code, {\n        children: \"?\"\n      }), \" 的值代表不重要，這是因為我們需要的就是前六個「過濾完」的值。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但要怎麼知道呼叫完 \", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 後，過濾完的值有幾個呢？這時候就要仰賴 \", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 的回傳值，在上面的例子中，\", _jsx(_components.code, {\n        children: \"unique\"\n      }), \" 會回傳的值是 \", _jsx(_components.code, {\n        children: \"a + 7\"\n      }), \"，其實可以想像成「過濾完後序列結尾的下一個位置」，就跟我們傳入結尾時是一樣的概念。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"unique\"\n      }), \" 一個簡單的應用，就是可以真的把一樣的數字過濾掉，要達成這件事，我們勢必得讓所有一樣的數字「相鄰」。這要怎麼做呢？其實只要呼叫 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 就完事了！也就是說，對於給定的序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \"，只要先呼叫一次 \", _jsx(_components.code, {\n        children: \"sort(a + 1, a + n + 1)\"\n      }), \"，再 \", _jsx(_components.code, {\n        children: \"unique(a + 1, a + n + 1)\"\n      }), \"，就完成一樣數字的過濾了。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"<numeric>\",\n      children: _jsx(_components.code, {\n        children: \"<numeric>\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"<numeric>\"\n      }), \" 很類似 \", _jsx(_components.code, {\n        children: \"<algorithm>\"\n      }), \"，但專注在提供各式\", _jsx(_components.strong, {\n        children: \"數值相關\"\n      }), \"簡易演算法操作的函式庫，只要牽扯到數值（例如：四則運算），就容易被分類進 \", _jsx(_components.code, {\n        children: \"<numeric>\"\n      }), \"。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"只要在程式的開頭寫上 \", _jsx(_components.code, {\n        children: \"#include <numeric>\"\n      }), \" 就可以使用裡面的函式們。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<numeric>-accumulate(first, last, init_value)\",\n      children: _jsx(_components.code, {\n        children: \"accumulate(first, last, init_value)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"計算一個序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 的總和，最直接的做法就是開一個變數紀錄總和、再用一個迴圈掃過所有序列的值並加進變數內。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"但 \", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 可以一行完成總和的計算，用法大致如下：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"accumulate(a + 1, a + n + 1, 0);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"前兩個參數跟我們前面學的一樣，是序列的開頭和結尾的後一個位置，最後一個參數則是「起始值」，也就是說，\", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 函式回傳的數值會是「起始值加上整段序列的總和」。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"為什麼需要起始值呢？可以想成是其實 C++ 把「開好一個存值的變數」的決定權交給使用者了，讀者可以執行下面這段程式碼看看效果：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int a[3] = {1000000000, 1000000000, 1000000000};\\ncout << accumulate(a, a + 3, 0) << \\\"\\\\n\\\";\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"理想上，上面這段程式碼的輸出應該要是 $3\\\\times 10^9$，但實際上，讀者可能會得到 \", _jsx(_components.code, {\n        children: \"-1294967296\"\n      }), \" 之類的輸出，應該不難猜到，總和吃了整數溢位（overflow），才會輸出不了超過 \", _jsx(_components.code, {\n        children: \"int\"\n      }), \" 上限的 $3\\\\times 10^9$。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這時候如果是一般跑迴圈算總和的寫法，修正方法應該是把一開始開好的變數設成 \", _jsx(_components.code, {\n        children: \"long long int\"\n      }), \"。而這就是 \", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 讓使用者自己給起始值的一種用意，使用者可以直接讓起始值的變數型態是 \", _jsx(_components.code, {\n        children: \"long long int\"\n      }), \" 來迴避這樣基本的溢位問題。因此，只要改成以下模樣，就可以正常輸出了！\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"int a[3] = {1000000000, 1000000000, 1000000000};\\ncout << accumulate(a, a + 3, 0LL) << \\\"\\\\n\\\";\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"這樣「指定起始值」的功能其實還可以配合自定義運算子（Operator overloading）等來產生一些妙用，但這就稍微進階一些了，這裡不再贅述。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"<numeric>-iota(first, last, init_value)\",\n      children: _jsx(_components.code, {\n        children: \"iota(first, last, init_value)\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"iota\"\n      }), \" 在做的事情其實非常單純，他可以在給定的序列範圍中填入一段連續的數字，例如以下的 code\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"for (int i = 1; i <= n; ++i)\\n    a[i] = i;\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"用 \", _jsx(_components.code, {\n        children: \"iota\"\n      }), \" 取代的話就是\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"iota(a + 1, a + n + 1, 1);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"前兩個參數跟一樣是序列的開頭和結尾的後一個位置，最後一個參數則是「連續數字的起始值」，代表這個範圍中藥填入的數字開頭是多少。因此，如果要改填入 \", _jsx(_components.code, {\n        children: \"10\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"n + 9\"\n      }), \" 的話，可以呼叫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"iota(a + 1, a + n + 1, 10);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"來達成。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"自定義比較函式\",\n      children: \"自定義比較函式\"\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"自定義比較函式-簡介\",\n      children: \"簡介\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"有了上述工具可以用確實很方便，但感覺缺少了一點自由度。舉例來說，如果想用 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 來把數字大到小排序該怎麼辦呢？或甚至複雜一點，如果我們要讓奇數擺前面、偶數擺後面，兩邊再各自比大小怎麼辦呢？又或者我們要排序自定義的 \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \"，C++ 要怎麼在我們沒有告訴他誰要擺前面的情況下知道要怎麼排序呢？\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"C++ 為了應付這種情況，其實大多數的函式他都提供了「自定義比較函式」的功能，我們用排序來當例子白話一點的說，還記得我們在排序時介紹過「 基於比較的排序演算法」這個概念嗎？在大多數的排序問題中，程式其實只需要不斷的詢問「元素 $x$ 和元素 $y$ 誰要擺前面？」就可以排出使用者期望的順序，而這個問題預設的答案就是「$x$ 比 $y$ 小的話，就擺前面」。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"因此，如果要把數字大排到小的話，只需要把問題的答案改成「$x$ 比 $y$ \", _jsx(_components.strong, {\n        children: \"大\"\n      }), \"的話，就擺前面」，這樣就好了！\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"自定義比較函式-實作\",\n      children: \"實作\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"要告訴 C++「誰擺前面」的指示時，使用者需要寫一個 \", _jsx(_components.code, {\n        children: \"bool\"\n      }), \" 函式，支援傳入兩個元素的值 $x$ 和 $y$ 後，回傳 $x$ 是不是\", _jsx(_components.strong, {\n        children: \"一定\"\n      }), \"要在 $y$ 前面。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"大致上會寫出如下的東西，拿大排到小當範例：\"\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"bool cmp(int x, int y) {\\n    return x > y;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"上述這個函式，會在傳入的 \", _jsx(_components.code, {\n        children: \"x\"\n      }), \" 比 \", _jsx(_components.code, {\n        children: \"y\"\n      }), \" 大時回傳 \", _jsx(_components.code, {\n        children: \"true\"\n      }), \"，也就達成了我們前面說的結果，\", _jsx(_components.code, {\n        children: \"x\"\n      }), \" 必須要在 \", _jsx(_components.code, {\n        children: \"y\"\n      }), \" 前面。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"而要呼叫 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 時，排序 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 只需要寫成\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1, cmp);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"也就是在原本呼叫 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 時在後面多加一個參數負責傳入比較函式，就完成大到小排序的操作了！\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"再拿自定義 \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \" 當例子，如果要對自定義的 \", _jsx(_components.code, {\n        children: \"struct\"\n      }), \" 排序時，可以寫成以下樣子：\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"struct Data {\\n    int key;\\n    Custom_Type something_else;\\n};\\n\\nbool cmp(Data a, Data b) {\\n    return a.key < b.key;\\n}\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"這樣一樣對型態是 \", _jsx(_components.code, {\n        children: \"Data\"\n      }), \" 的序列 \", _jsx(_components.code, {\n        children: \"a[1]\"\n      }), \" 到 \", _jsx(_components.code, {\n        children: \"a[n]\"\n      }), \" 排序時，一樣寫\"]\n    }), \"\\n\", _jsx(Refcode, {\n      lang: \"cpp\",\n      lineno: \"true\",\n      code: \"sort(a + 1, a + n + 1, cmp);\",\n      startFrom: \"1\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就可以完成排序，是不是很方便呢？\"\n    }), \"\\n\", _jsxs(Info, {\n      type: \"warning\",\n      children: [_jsxs(_components.p, {\n        children: [\"文章內有特別強調函式的作用是「$x$ 是不是\", _jsx(_components.strong, {\n          children: \"一定\"\n        }), \"要在 $y$ 前面」，這個「一定」非常的重要，如果不巧把比較函式寫成\"]\n      }), _jsx(Refcode, {\n        lang: \"cpp\",\n        lineno: \"true\",\n        code: \"bool cmp(int x, int y) {\\n    return x <= y;\\n}\",\n        startFrom: \"1\"\n      }), _jsx(_components.p, {\n        children: \"就會讓 C++ 在兩數相等時，搞不清楚誰要在前面，造成自相矛盾出現不預期的行為。\"\n      }), _jsxs(_components.p, {\n        children: [\"最簡單避免這件事發生的方法，就是多確認一下如果傳入兩個一樣的元素給自己的函式作比較時，函式會回傳 \", _jsx(_components.code, {\n          children: \"false\"\n        }), \"。\"]\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      refId: \"自定義比較函式-延伸\",\n      children: \"延伸\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"自定義比較函式的使用範圍，其實不只有 \", _jsx(_components.code, {\n        children: \"sort\"\n      }), \" 而已，包含前面提到的 \", _jsx(_components.code, {\n        children: \"min\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"min_element\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 其實都適用，可以想成 \", _jsx(_components.code, {\n        children: \"min\"\n      }), \" 就是指要擺在最前面的元素，\", _jsx(_components.code, {\n        children: \"nth_element\"\n      }), \" 當然就一樣是把第 $k$ 小的基準想成是利用給予的比較函式排序後的第 $k$ 個位置。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"unique\"\n      }), \" 則比較特殊，因為他是要把相鄰一樣的元素過濾掉，所以他的比較函式反而是「詢問兩個元素 $x$ 和 $y$ 是不是一樣？」，這聽起來很奇怪，但其實在一些特殊的狀況下是真的需要自定義的喔！\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"實作上一樣，比較函式只需要擺在最後面當一個額外的參數就可以了。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"再順帶一提，\", _jsx(_components.code, {\n        children: \"accumulate\"\n      }), \" 其實也可以額外傳入自定義函式，但講起來有點複雜，有興趣的讀者可以去他的說明頁面看看。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"習題\",\n      children: \"習題\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"以下提供一些題目讓讀者做函式庫的練習。\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1287\",\n      src: \"TIOJ 1287\",\n      name: \"基礎排序\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/TIOJ/1287/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1287/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://zerojudge.tw/ShowProblem?problemid=k026\",\n      src: \"ZeroJudge k026\",\n      name: \"中位數\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/ZeroJudge/k026/description.mdx\",\n      importMdx: \"guide/problems/ZeroJudge/k026/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://cses.fi/problemset/task/1621\",\n      src: \"CSES 1621\",\n      name: \"Distinct Numbers\",\n      expanded: \"false\",\n      difficulty: \"1\",\n      descriptionMdx: \"guide/problems/CSES/1621/description.mdx\",\n      importMdx: \"guide/problems/CSES/1621/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/2193\",\n      src: \"2021 TOI 入營考 pA\",\n      name: \"原始人排序\",\n      expanded: \"false\",\n      difficulty: \"2\",\n      descriptionMdx: \"guide/problems/TOI/2021_pre_A/description.mdx\",\n      importMdx: \"guide/problems/TOI/2021_pre_A/description.mdx\"\n    }), \"\\n\", _jsx(Problem, {\n      url: \"https://tioj.ck.tp.edu.tw/problems/1617\",\n      src: \"IOI 2000 Day 1\",\n      name: \"中位數\",\n      expanded: \"false\",\n      difficulty: \"4\",\n      descriptionMdx: \"guide/problems/TIOJ/1617/description.mdx\",\n      constraintsMdx: \"guide/problems/TIOJ/1617/constraints.mdx\",\n      importMdx: \"guide/problems/TIOJ/1617/description.mdx\",\n      importMdx: \"guide/problems/TIOJ/1617/constraints.mdx\"\n    }), \"\\n\", _jsx(_components.h2, {\n      refId: \"小結\",\n      children: \"小結\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"C++ 提供的內建函式可不只以上這些，只是礙於篇幅，我們這裡只特別挑了一些常用的出來講，更有一些函式需要對演算法有一定程度的認識才好使用，讀者若有興趣，可以參考 \", _jsx(_components.a, {\n        href: \"https://cppreference.com/\",\n        children: \"https://cppreference.com/\"\n      }), \" 內 \", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/algorithm\",\n        children: _jsx(_components.code, {\n          children: \"<algorithm>\"\n        })\n      }), \" 和 \", _jsx(_components.a, {\n        href: \"https://en.cppreference.com/w/cpp/numeric\",\n        children: _jsx(_components.code, {\n          children: \"<numeric>\"\n        })\n      }), \" 的章節，搞不好可以找到更多可以讓程式碼更簡潔的工具。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1287/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"輸入一個 $n$ 與 $n$ 個數字，輸出排序後的結果。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"*本題需要輸入到 EOF（檔案結尾，End of File）\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/ZeroJudge/k026/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"輸入 $n$ 和 $n$ 個數字，輸出這些數字的中位數。若 $n$ 為偶數，需要輸出中間兩個數字的平均值。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/CSES/1621/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsx(_components.p, {\n    children: \"輸入一個 $n$ 與 $n$ 個數字，輸出這 $n$ 個數字有多少種數字。\"\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TOI/2021_pre_A/description.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    br: \"br\",\n    p: \"p\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.p, {\n    children: [\"布朗博士搭乘著時光機器回到了原始人出現的年代，他打算教導原始人現代的資訊技術。首先，布朗博士教原始人們數字的二進位表示法，他由小而大列下了幾個數字：\", _jsx(_components.br, {}), \"\\n\", \"$000, 001, 010, 011, 100, 101, 110, 111$\", _jsx(_components.br, {}), \"\\n\", \"剛列完，原始人的首領就糾正他，說下面的列法才是正確由小到大的順序：\", _jsx(_components.br, {}), \"\\n\", \"$000, 001, 010, 100, 011, 101, 110, 111$\", _jsx(_components.br, {}), \"\\n\", \"爭吵了半天，布朗博士才發現，原來原始人在計數時是用石頭在牆上刻劃一道道的痕跡，每道痕跡 就算計數一次，因此在二進位的表示法下，$1$ 的次數愈多，在原始人心中認定的數值愈大。\", _jsx(_components.br, {}), \"\\n\", \"請你寫一支程式幫助布朗博士，將 $n$ 個十進位表示的數字依原始人認定的順序（即二進位表示法中 $1$ 的個數）由小而大排序；倘若兩數字的二進位表示中 $1$ 的個數相同，則視為相同，依輸入時的順序輸出。\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1617/description.mdx",{"compiledSource":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    p: \"p\",\n    strong: \"strong\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"本題為互動題\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在你面前有 $n$ 個箱子，編號依序為 $1 \\\\sim n$。每個箱子裡面都有一個數字 $Y_i$，$1 \\\\le Y_i \\\\le n$ 且每個箱子的數字都不重複，換句話說箱子裡的數字，$1 \\\\sim n$ 都會剛好出現一次。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"你必須要使用給定的函式 \", _jsx(_components.code, {\n        children: \"Med3(a, b, c)\"\n      }), \" 來求出這些數字的中位數在哪個位置。其中 \", _jsx(_components.code, {\n        children: \"Med3(a, b, c)\"\n      }), \" 會回傳一個數字 $k$ 表示 $Y_a, Y_b, Y_c$ 三個數的中位數是 $Y_k$。\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}],["guide/problems/TIOJ/1617/constraints.mdx",{"compiledSource":"\"use strict\";\nconst {jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = {\n    code: \"code\",\n    li: \"li\",\n    ul: \"ul\",\n    ..._provideComponents(),\n    ...props.components\n  };\n  return _jsxs(_components.ul, {\n    children: [\"\\n\", _jsx(_components.li, {\n      children: \"$n \\\\le 1499$，而且 $n$ 是奇數\"\n    }), \"\\n\", _jsxs(_components.li, {\n      children: [\"你只能呼叫 \", _jsx(_components.code, {\n        children: \"Med3\"\n      }), \" $7777$ 次\"]\n    }), \"\\n\"]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = {\n    ..._provideComponents(),\n    ...props.components\n  };\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}]],"sections":[{"text":"不要造輪子","depth":1,"code":"不要造輪子"},{"text":"<algorithm>","depth":1,"code":"<algorithm>"},{"text":"介紹","depth":2,"code":"<algorithm>-介紹"},{"text":"swap(val1, val2)","depth":2,"code":"<algorithm>-swap(val1, val2)"},{"text":"min(val1, val2)","depth":2,"code":"<algorithm>-min(val1, val2)"},{"text":"min_element(first, last)","depth":2,"code":"<algorithm>-min_element(first, last)"},{"text":"sort(first, last)","depth":2,"code":"<algorithm>-sort(first, last)"},{"text":"nth_element(first, nth_pos, last)","depth":2,"code":"<algorithm>-nth_element(first, nth_pos, last)"},{"text":"unique(first, last)","depth":2,"code":"<algorithm>-unique(first, last)"},{"text":"<numeric>","depth":1,"code":"<numeric>"},{"text":"accumulate(first, last, init_value)","depth":2,"code":"<numeric>-accumulate(first, last, init_value)"},{"text":"iota(first, last, init_value)","depth":2,"code":"<numeric>-iota(first, last, init_value)"},{"text":"自定義比較函式","depth":1,"code":"自定義比較函式"},{"text":"簡介","depth":2,"code":"自定義比較函式-簡介"},{"text":"實作","depth":2,"code":"自定義比較函式-實作"},{"text":"延伸","depth":2,"code":"自定義比較函式-延伸"},{"text":"習題","depth":1,"code":"習題"},{"text":"小結","depth":1,"code":"小結"}],"gaId":"G-XCS0L6MZE3"}},"__N_SSG":true}